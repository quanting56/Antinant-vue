const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/D3jsSelectionEnterDemo-B2QKU-2I.js","assets/transform-DNQUPihx.js","assets/index-B1OBybhT.js","assets/index-CtERxmw5.css","assets/select-1EGbaqqT.js","assets/D3jsSelectionExitDemo-Db7WdHE0.js","assets/D3jsSelectionJoin1Demo-BFZnb5Xt.js","assets/D3jsSelectionJoin2Demo-CP9LZPga.js","assets/D3jsDataBindingPractice-DcVlnjVu.js","assets/D3jsDataBindingPractice-Cc-4O5tI.css","assets/D3jsLinesDemo-FB6ga7PK.js","assets/line-CnRH6wfh.js","assets/array-DEnAxiAM.js","assets/constant-BhYcI2Bl.js","assets/path-CsjuoHvu.js","assets/D3jsAreasDemo-DoTeoTgc.js","assets/area-C0N4KdZA.js","assets/D3jsCurvesDemo-CKgTDDX2.js","assets/basis-UEinyaHF.js","assets/D3jsArcsDemo-DIVjfv0n.js","assets/arc-DcE2_U0A.js","assets/D3jsAxesDemo-Bl5bgkuh.js","assets/linear-IoaARM7T.js","assets/continuous-DdKr3jbY.js","assets/value-BWAEs6ZY.js","assets/round-O1hten6x.js","assets/init-Dmth1JHB.js","assets/defaultLocale-B0Uv6ZVb.js","assets/max-DBeXZoyG.js","assets/axis-qL51v-F_.js","assets/D3jsStacksDemo-8Ob5ccmS.js","assets/ordinal-BXh_4XLC.js","assets/stack-D1BzCQg9.js","assets/D3jsScaleWithNiceComparison-6DSrBcsG.js","assets/extent-Ccx1MofX.js","assets/D3jsAxesGraphExplanation-D2Wb_v3H.js","assets/D3jsAxesDirectionsDemo-BFbwlM7k.js","assets/D3jsXAxisDemo-BxhbmTmH.js","assets/D3jsAxisTickTestDemo-DB2Mp5o4.js","assets/D3jsFormatTestDemo-Cr6HuFWv.js","assets/D3jsAxisTimeTickTestDemo-C_qZZbqi.js","assets/time-58CfGA5l.js","assets/D3jsAxisTickValueTestDemo-AQ-yLvbo.js","assets/D3jsScaleBandTickValueTestDemo-2QMfZjYb.js","assets/band-CibOmBXR.js","assets/range-OtVwhkKS.js","assets/D3jsAxisTickFormatTestDemo-DGf7Fstd.js","assets/D3jsAxisTickFormatUnitTestDemo-9LMu1DQ8.js","assets/D3jsAxisTickSizeTestDemo-40YqPSdB.js","assets/D3jsAxisTickSizeIOTestDemo-DnBGBDkT.js","assets/D3jsAxisTickSizeIO2TestDemo-Cesrdtzk.js","assets/D3jsAxisTickPaddingTestDemo-D6ji7rLc.js","assets/D3jsXYAxesDemo-BfueNQnj.js","assets/D3jsXYAxesCheckerBoardStyleDemo-BsF00Lq-.js","assets/D3jsXYAxesHashtagStyleDemo-BNJJUnFu.js","assets/D3jsXYAxesGridStyleDemo-Dw3rnPQs.js","assets/D3jsXYAxesTickTextRotationDemo-6Qfzpj-y.js","assets/D3jsClockAxisDemo-BlHgpfrW.js","assets/D3jsRWDAxisTestDemo-BhXEfb1V.js","assets/D3jsMoveDemo-BM6l3jTW.js","assets/D3jsMoveDemo-QfcxFu6Z.css","assets/D3jsTransitionDemo-CPY-ZzLU.js","assets/D3jsTransitionDemo-CGIw5Ik4.css","assets/D3jsTransitionDurationDemo-CX6KAJ-O.js","assets/D3jsTransitionDurationDemo-CwsQ_eNE.css","assets/D3jsTransitionColorDemo-C0YHmJCH.js","assets/D3jsTransitionColorDemo-C1Y_Euny.css","assets/D3jsTransitionColorAndDelayDemo-Bf6_8_CZ.js","assets/D3jsTransitionColorAndDelayDemo-DL4wgsfH.css","assets/D3jsDelayCircleMove-ClrL32VE.js","assets/D3jsDelayCircleMove-BQHjnSbm.css","assets/D3jsEaseDemonstration-BuPL7xlT.js","assets/brush-CU99m-Ch.js","assets/pointer-BV9FWJ6s.js","assets/nodrag-CZbKbhqk.js","assets/active-CAUcpjGt.js","assets/zoom-Du-Duwsy.js","assets/category10-aLVps2F5.js","assets/colors-Cc3OSVma.js","assets/min-D1slsF82.js","assets/mercator-BOuc4nnK.js","assets/pie-Vk8EeaUu.js","assets/dsv-CbZ0YcQP.js","assets/text-5Xu4kz8q.js","assets/drag-D7PSiu5c.js","assets/back-iwqdOgzu.js","assets/xml-D5mMVlHt.js","assets/Set2-BlATX450.js","assets/Tableau10-Ci8Hh9LU.js","assets/selectAll-BYWdlUMy.js","assets/D3jsEaseDemonstration-qL_EgsNe.css","assets/D3jsLoopAnimationDemo-B6A51X8v.js","assets/D3jsClickSvgDemo-CcsguwzW.js","assets/D3jsMouseOverDemo-CdSYXV2b.js","assets/D3jsPointerSvgDemo-jebybE5-.js","assets/D3jsTooltipDemo-BiTFzFHY.js","assets/D3jsTooltipDemo-BRysmw1r.css","assets/D3jsAdvancedTooltipDemo-DfUuuMZ-.js","assets/D3jsAdvancedTooltipDemo-CFPEvH5g.css","assets/D3jsMouseEventInsertHtmlWeb-ZD2XubBA.js","assets/D3jsMouseEventInsertHtmlWeb-CzGF-jk9.css","assets/D3jsDragDemo-DIi7j8OL.js","assets/D3jsZoomDemo-BkPAmFhC.js","assets/D3jsZoomDemo-CVbpTAlC.css","assets/D3jsBrushDemo-CY0o2GKn.js","assets/D3jsPieChartDemo-DSo8z5Va.js","assets/D3jsSwitchPieChartsDemo-D5pVh93O.js","assets/D3jsSwitchPieChartsDemo-C4z2fP4X.css","assets/D3jsScatterChartDemo-kz9gApzt.js","assets/D3jsThreeScatterChartsDemo-BwozaJHi.js","assets/第11屆全國不分區及僑居國外國民立法委員選舉各政黨在北北基桃各投開票所得票數一覽表-CaMA2Gpg.js","assets/D3jsAddPointScatterChartDemo-CRzroDll.js","assets/D3jsBubbleChartDemo-CcMbqQMg.js","assets/D3jsSwitchBubbleChartsDemo-DUBzxzVu.js","assets/D3jsSwitchBubbleChartsDemo-DL9QYMhM.css","assets/D3jsBarChartDemo-DLx_3KKX.js","assets/D3jsBarChartDemo-BdlAilwa.css","assets/D3jsMultiBarChartDemo-Domvuh7o.js","assets/D3jsStackedBarChartDemo-C6PjaQZ-.js","assets/D3jsLineChartDemo-C6n4wHkD.js","assets/vs2015-txMzNINg.js","assets/vs2015-CgoTCXaG.css","assets/D3jsInteractLineChartDemo-BjQCqKa4.js","assets/D3jsDefinedLineChartGraphExplanation-DwSMY8uQ.js","assets/D3jsDefinedLineChartDemo-DdQDvm38.js","assets/D3jsMultiLineChartDemo-D_muSQXb.js","assets/D3jsMultiLineChartWithBrushDemo-D3GNxcim.js"])))=>i.map(i=>d[i]);
import{m as t,q as e,_ as C,r as k,k as T,o as w,p as v,c as i,b as s,g as A,F as p,d as x,u as _,w as D,T as R,f as a,j as G,t as d,h as r,n as L,s as y,v as f,i as b}from"./index-B1OBybhT.js";import{H as h}from"./vs2015-txMzNINg.js";import{x as j,j as M}from"./javascript-BK9ByurK.js";const E=[{id:"d3jsStartNote",title:"開始使用 D3.js",description:`<p><a href="https://d3js.org" target="_blank">D3.js 官網</a></p>
<p><a href="https://github.com/d3/d3/releases" target="_blank">D3.js 各版本程式碼</a><small>（GitHub頁面）</small></p>
<p><a href="https://observablehq.com/@d3/gallery" target="_blank">D3.js 圖表範例庫</a></p>
<p><a href="https://d3-graph-gallery.com" target="_blank">D3.js Graph Gallery</a></p>`,descriptionComponent:null,descriptionComponentStyle:null,lists:[{listTitle:"CDN 安裝",listSubtitle:"用純 html 方式導入",listComponent:null,listCode:{htmlCode:null,jsCode:null,vueCode:null},listDetails:[{detailTitle:"將 js 文件引用到 <code>&lt;head&gt;</code> 裡：",detailSubtitle:null,detailComponent:null,detailCode:{htmlCode:`<head>
  ...
  <script src="js/d3_v7.9.0_min.js"><\/script>
  ...
</head>`,jsCode:null,vueCode:null}},{detailTitle:"或是以 CDN 連結的方式引用到 <code>&lt;head&gt;</code> 裡：",detailSubtitle:null,detailComponent:null,detailCode:{htmlCode:`<head>
  ...
  <script src="https://d3js.org/d3.v7.min.js"><\/script>
  ...
</head>`,jsCode:null,vueCode:null}}]},{listTitle:"NPM 安裝",listSubtitle:null,listComponent:null,listCode:{htmlCode:null,jsCode:`// 先用終端機安裝 D3.js
npm install d3


// 再匯入 D3.js
import * as d3 from "d3";`,vueCode:null},listDetails:[{detailTitle:null,detailSubtitle:null,detailComponent:null,detailCode:{htmlCode:null,jsCode:null,vueCode:null}}]}]},{id:"d3jsDataBindingNote",title:"資料綁定",description:`<svg width="420" height="320">
  <circle cx="150" cy="180" r="100" stroke="orange" stroke-width="5" fill="none"></circle>
  <circle cx="250" cy="180" r="100" stroke="#ffd382" stroke-width="5" fill="none"></circle>
  <text x="135" y="50" text-anchor="middle" font-size="20" font-family="Heiti TC" fill="orange">
    資料
  </text>
  <text x="270" y="50" text-anchor="middle" font-size="20" font-family="Heiti TC" fill="#ffd382">
    DOM元素
  </text>
  <text x="115" y="180" text-anchor="middle" font-size="16" font-family="Heiti TC">
    <tspan x="115" dy="0">資料多</tspan>
    <tspan x="115" dy="1.5em">enter</tspan>
  </text>
  <text x="200" y="180" text-anchor="middle" font-size="16" font-family="Heiti TC">
    <tspan x="200" dy="0">一樣多</tspan>
    <tspan x="200" dy="1.5em">update</tspan>
  </text>
  <text x="285" y="180" text-anchor="middle" font-size="16" font-family="Heiti TC">
    <tspan x="285" dy="0">元素多</tspan>
    <tspan x="285" dy="1.5em">exit</tspan>
  </text>
</svg>`,descriptionComponent:null,descriptionComponentStyle:"style='width: 800px; height: 400px;'",lists:[{listTitle:"資料綁定 API",listSubtitle:null,listComponent:null,listCode:{htmlCode:null,jsCode:null,vueCode:null},listDetails:[{detailTitle:"<code>selection.enter()</code>",detailSubtitle:"DOM 比較少的話，用 <code>enter()</code> 和 <code>append()</code> 調整。",detailComponent:t(()=>e(()=>import("./D3jsSelectionEnterDemo-B2QKU-2I.js"),__vite__mapDeps([0,1,2,3,4]))),detailCode:{htmlCode:`<div class="d3-Enter">
  <p></p>
  <p></p>
  <p></p>
</div>

<script>
  const enterData = ['我', '是', '資', '料'];
  const d3DataEnter = d3.select('.d3-Enter')
                        .selectAll('p')
                        .data(enterData)
                        .text(d => d)
                        .enter()
                        .append('p')
                        .text(d => d)
                        .attr('class', 'text-danger fw-bold');

  // 此處console.log資訊要由開發者工具的console來看
  console.log('d3DataEnter', d3DataEnter);
<\/script>`,jsCode:null,vueCode:null}},{detailTitle:"<code>selection.exit()</code>",detailSubtitle:"DOM 比較多的話，用 <code>exit()</code> 和 <code>remove()</code> 調整。",detailComponent:t(()=>e(()=>import("./D3jsSelectionExitDemo-Db7WdHE0.js"),__vite__mapDeps([5,1,2,3,4]))),detailCode:{htmlCode:`<div class="d3-Exit">
  <p></p>
  <p></p>
  <p></p>
  <p></p>
  <p></p>
  <p></p>
</div>

<script>
  const exitData = ['我', '是', '資', '料'];
  const d3DataExit = d3.select('.d3-Exit')
                       .selectAll('p')
                       .data(exitData)
                       .text(d => d)
                       .exit()
                       .remove();

  // 此處console.log資訊要由開發者工具的console來看
  console.log('d3DataExit', d3DataExit);
<\/script>`,jsCode:null,vueCode:null}},{detailTitle:"<code>selection.join()</code>",detailSubtitle:"用 <code>join()</code> 來調整 DOM 與 data 的數量差異。",detailComponent:t(()=>e(()=>import("./D3jsSelectionJoin1Demo-BFZnb5Xt.js"),__vite__mapDeps([6,1,2,3,4]))),detailCode:{htmlCode:`<div class="d3-Join1">
  <p></p>
  <p></p>
  <p></p>
</div>

<script>
  const joinData1 = ['我', '是', '資', '料'];
  const d3DataJoin1 = d3.select('.d3-Join1')
                        .selectAll('p')
                        .data(joinData1)
                        .join('p')
                        .text(d => d)
                        .attr('class', 'text-danger fw-bold');

  // 此處console.log資訊要由開發者工具的console來看
  console.log('d3DataJoin1', d3DataJoin1);
<\/script>`,jsCode:null,vueCode:null}},{detailTitle:"<code>selection.join(<i>enter[, update][, exit]</i>)</code>",detailSubtitle:"用 <code>join(<i>enter, update, exit</i>)</code> 來調整 DOM 與 data 的數量差異。",detailComponent:t(()=>e(()=>import("./D3jsSelectionJoin2Demo-CP9LZPga.js"),__vite__mapDeps([7,1,2,3,4]))),detailCode:{htmlCode:`<div class="d3-Join2">
  <p></p>
  <p></p>
  <p></p>
</div>

<script>
  const joinData2 = ['我', '是', '資', '料'];
  const d3DataJoin2 = d3.select('.d3-Join2')
                        .selectAll('p')
                        .data(joinData2)
                        .join(
                           enter => enter.append('p')
                                         .text(d => d)
                                         .attr('class', 'text-danger fw-bold'),
                           update => update,
                           exit => exit.remove()
                        )
                        .text(d => d);

  // 此處console.log資訊要由開發者工具的console來看
  console.log('d3DataJoin2', d3DataJoin2);
<\/script>`,jsCode:null,vueCode:null}}]},{listTitle:"一個範例（原小工具練習）",listSubtitle:`<ol>
  <li>畫面上有一個輸入資料數量的框框、隨機產生資料的按紐、目前的資料集，以及與資料搭配的柱狀圖表。</li>
  <li>每次點擊按鈕時，會根據資料數量隨機產生不同的資料，柱狀圖表也會隨著資料更新而變化。</li>
</ol>`,listComponent:t(()=>e(()=>import("./D3jsDataBindingPractice-DcVlnjVu.js"),__vite__mapDeps([8,2,3,1,4,9]))),listCode:{htmlCode:`<div>
  <label>資料數量</label>
  <input type="number" id="d3jsPractice_dataLength">
  <button type="button" id="d3jsPractice_getRandomData">點擊產生隨機資料</button>
</div>
<div class="my-2">data資料集：<span id="d3jsPractice_showData"></span></div>
<div id="d3jsPractice_chartWrap"></div>

<script>
  const getRandomData = document.querySelector('#d3jsPractice_getRandomData');
  const dataLength = document.querySelector('#d3jsPractice_dataLength');
  const showData = document.querySelector('#d3jsPractice_showData');
  let randomData = [];
  
  getRandomData.addEventListener("click", (e) => {
    randomData.length = 0;
  
    for (i = 0; i < dataLength.value; i++) {
      // 產生並塞入隨機亂數資料
      let random = Math.floor(Math.random() * 5);
      randomData.push(random);
    };

    // 畫面呈現目前資料集
    showData.innerHTML = randomData;

    // 繪製圖表
    drawDiagram();
  });

  // 建立SVG畫布
  const rangeSelect = d3.select('#d3jsPractice_chartWrap')
                        .append('svg')
                        .attr('width', 400)
                        .attr('height', 300)
                        .style('border', '1px solid rgb(96, 96, 96)');

  const drawDiagram = () => {
    // 綁定update資料
    let rects = rangeSelect.selectAll('rect')
                           .data(randomData);

    rects.enter()
         .append('rect')
         .attr('width', 0) // 初始化寬度為0
         .attr('height', 40)
         .style('fill', '#967259')
         .attr('x', (d, index) => 0)
         .attr('y', (d, index) => index * 60)
         .transition()
         .duration(500)
         .attr('width', (d) => d * 60);

    // 更新資料，重新設定長條圖的寬度
    rects.transition()
         .duration(500)
         .attr('width', (d) => d * 60);

    // 移除多的DOM元素
    rects.exit().remove();
  };
<\/script>`,jsCode:`// 而亦可將其中下面這段enter、update、exit分開寫的code改寫成join()的形式

// 此為原始code

const drawDiagram = () => {
  // 綁定update資料
  let rects = rangeSelect.selectAll('rect')
                         .data(randomData);
  
  rects.enter()
       .append('rect')
       .attr('width', 0) // 初始化寬度為0
       .attr('height', 40)
       .style('fill', '#967259')
       .attr('x', (d, index) => 0)
       .attr('y', (d, index) => index * 60)
       .transition()
       .duration(500)
       .attr('width', (d) => d * 60);

  // 更新資料，重新設定長條圖的寬度
  rects.transition()
       .duration(500)
       .attr('width', (d) => d * 60);
  
  // 移除多的DOM元素
  rects.exit().remove();
};
  
  
  
// 下面這段code為改寫成join()的形式

const drawDiagram = () => {
  // 綁定update資料
  let rects = rangeSelect.selectAll('rect')
                         .data(randomData)
                         .join(
                           (enter) => enter.append('rect')
                                           .attr('width', 0) // 初始化寬度為0
                                           .attr('height', 40)
                                           .style('fill', '#967259')
                                           .attr('x', (d, index) => 0)
                                           .attr('y', (d, index) => index * 60)
                                           .transition()
                                           .duration(500)
                                           .attr('width', (d) => d * 60),
                           (update) => update.transition()
                                             .duration(500)
                                             .attr('width', (d) => d * 60),
                           (exit) => exit.remove()
                         );
};`,vueCode:`<template>
  <div class="random-bar-chart">
    <label>資料數量</label>
    <input
      type="number"
      v-model.number="dataLength"
      placeholder="請輸入 0 ~ 5 的數"/>
    <button @click="generateRandomData">點擊產生隨機資料</button>

    <div>
      產生的 data 資料集：<span>{{ randomData.join(", ") }}</span>
    </div>

    <div ref="chartWrap" class="chart-wrap"></div>
  </div>
</template>

<script setup>
import { ref, onMounted } from "vue";
import * as d3 from "d3";

const dataLength = ref(5);
const randomData = ref([]);
const chartWrap = ref(null);
let svg = null;

const generateRandomData = () => {
  // 用 Array.from 建立一個長度為 dataLength 的陣列，每個元素都是 0～4 的隨機整數
  randomData.value = Array.from({ length: dataLength.value }, () =>
    Math.floor(Math.random() * 5)
  );
  drawDiagram();
};

const drawDiagram = () => {
  if (!svg) return;

  svg.selectAll("rect")
    .data(randomData.value)
    .join(
      (enter) =>
        enter
          .append("rect")
          .attr("width", 0)
          .attr("height", 40)
          .style("fill", "#967259")
          .attr("x", 0)
          .attr("y", (d, i) => i * 60)
          .transition()
          .duration(500)
          .attr("width", (d) => d * 60),
      (update) =>
        update
          .transition()
          .duration(500)
          .attr("width", (d) => d * 60),
      (exit) => exit.remove()
    );
};

onMounted(() => {
  svg = d3
    .select(chartWrap.value)
    .append("svg")
    .attr("width", 400)
    .attr("height", 300)
    .style("border", "1px solid rgb(96, 96, 96)");

  generateRandomData(); // 初始渲染
});
<\/script>

<style scoped>
.random-bar-chart input {
  margin: 0 8px;
}
.chart-wrap {
  margin-top: 8px;
}
</style>
`},listDetails:[{detailTitle:null,detailSubtitle:null,detailComponent:null,detailCode:{htmlCode:null,jsCode:null,vueCode:null}}]}]},{id:"d3jsApiForDataImportingNote",title:"匯入資料的 API",description:"<p>通常有 <u>JSON</u> / <u>CSV</u> 兩種。</p>",descriptionComponent:null,descriptionComponentStyle:null,lists:[{listTitle:"以 JSON 的方式匯入",listSubtitle:null,listComponent:null,listCode:{htmlCode:null,jsCode:null,vueCode:null},listDetails:[{detailTitle:"沒有 CORS 錯誤問題（例如 JSON 資料在本地端）",detailSubtitle:null,detailComponent:null,detailCode:{htmlCode:null,jsCode:`const url = "串接網址 or 檔案路徑";
const getJSONData = async () => {
  const resData = await d3.json(url);
  console.log("d3.json()", resData);
};

getJSONData();`,vueCode:null}},{detailTitle:"有 CORS 錯誤問題（此例用 AllOrigins API 來繞過 CORS（跨來源資源共享）限制的基本 URL）",detailSubtitle:null,detailComponent:null,detailCode:{htmlCode:null,jsCode:`const cors = "https://api.allorigins.win/get?url=";
const url = "目標 JSON 資料的 URL";
const getCorsData = async () => {
  const dataGet = await d3.json(\`\${cors}\${url}\`); // 串接網址
  console.log("d3.json()", dataGet);
};

getCorsData();`,vueCode:null}}]},{listTitle:"以 CSV 的方式匯入",listSubtitle:null,listComponent:null,listCode:{htmlCode:null,jsCode:null,vueCode:null},listDetails:[{detailTitle:"取得 csv 資料",detailSubtitle:null,detailComponent:null,detailCode:{htmlCode:null,jsCode:`const getCsvData = async () => {
  const csvData = await d3.csv("串接網址 or 檔案路徑");
  console.log("csvData", csvData);
};

getCsvData();
`,vueCode:null}},{detailTitle:"只取得 csv 資料中所有特定類別的資料（類似 R 語言中 <code>food$vegetable</code> 的用法）",detailSubtitle:null,detailComponent:null,detailCode:{htmlCode:null,jsCode:`const getCsvSpecificData = async () => {
  const csvData = await d3.csv("檔案路徑", (d) => d.特定類別名);
  // 例：const csvData = await d3.csv("data/food.csv", (d) => d.vegetable);
  console.log("csvData", csvData);
};

getCsvSpecificData();`,vueCode:null}}]}]},{id:"d3jsApiForDataOrganizationNote",title:"資料整理",description:`<h4>Array 分類</h4>
<table>
  <thead>
    <tr>
      <th>Array 分類</th>
      <th>常用的 API</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Statistics（統計數據）</td>
      <td><code>d3.min</code>、<code>d3.max</code>、<code>d3.extent</code>、<code>d3.sum</code></td>
    </tr>
    <tr>
      <td>Search（尋找）</td>
      <td><code>d3.ascending</code>、<code>d3.descending</code></td>
    </tr>
    <tr>
      <td>Transformations（改變結構）</td>
      <td><code>d3.merge</code>、<code>d3.range</code></td>
    </tr>
    <tr>
      <td>Iterables（迭代）</td>
      <td><code>d3.every</code>、<code>d3.some</code>、<code>d3.map</code>、<code>d3.filter</code>、<code>d3.sort</code></td>
    </tr>
    <tr>
      <td>Sets（數組）</td>
      <td></td>
    </tr>
    <tr>
      <td>Histograms（直條圖）</td>
      <td></td>
    </tr>
    <tr>
      <td>Interning</td>
      <td></td>
    </tr>
  </tbody>
</table>`,descriptionComponent:null,descriptionComponentStyle:null,lists:[{listTitle:"Arrays 分類的常用 API",listSubtitle:null,listComponent:null,listCode:{htmlCode:null,jsCode:null,vueCode:null},listDetails:[{detailTitle:"<code>d3.min()</code> 尋找最小值",detailSubtitle:null,detailComponent:null,detailCode:{htmlCode:null,jsCode:`const numberData = [5, 1, 35, 13, 15, 18, 21, 31, 29];
const minNumber = d3.min(numberData);
console.log("minimum", minNumber);

// return 'minimum' 1`,vueCode:null}},{detailTitle:"<code>d3.max()</code> 尋找最大值",detailSubtitle:null,detailComponent:null,detailCode:{htmlCode:null,jsCode:`const numberData = [5, 1, 35, 13, 15, 18, 21, 31, 29];
const maxNumber = d3.max(numberData);
console.log("maximum", maxNumber);

// return 'maximum' 35`,vueCode:null}},{detailTitle:"<code>d3.extent()</code> 同時找出最小值與最大值",detailSubtitle:null,detailComponent:null,detailCode:{htmlCode:null,jsCode:`const numberData = [5, 1, 35, 13, 15, 18, 21, 31, 29];
const extent = d3.extent(numberData);
console.log("minimum and maximum", extent);

// return 'minimum and maximum' [1, 35]`,vueCode:null}},{detailTitle:"<code>d3.sum()</code> 加總",detailSubtitle:null,detailComponent:null,detailCode:{htmlCode:null,jsCode:`const numberData = [5, 1, 35, 13, 15, 18, 21, 31, 29];
const sum = d3.sum(numberData);
console.log("sum", sum);

// return 'sum' 168`,vueCode:null}},{detailTitle:"<code>d3.every(<i>資料, 方法</i>)</code> 遍歷資料陣列，確認陣列內的值是否都符合條件",detailSubtitle:null,detailComponent:null,detailCode:{htmlCode:null,jsCode:`const numberData = [5, 1, 35, 13, 15, 18, 21, 31, 29];
const isAllIntegerBiggerThanTwenty = d3.every(numberData, (d) => d > 20);
console.log("every > 20", isAllIntegerBiggerThanTwenty);

// return 'every > 20' false`,vueCode:null}},{detailTitle:"<code>d3.some(<i>資料, 方法</i>)</code>遍歷資料陣列，確認陣列內的值是否至少有一項符合條件",detailSubtitle:null,detailComponent:null,detailCode:{htmlCode:null,jsCode:`const numberData = [5, 1, 35, 13, 15, 18, 21, 31, 29];
const isAnyIntegerBiggerThanTwenty = d3.some(numberData, (d) => d > 20);
console.log("any > 20", isAnyIntegerBiggerThanTwenty);

// return 'any > 20' true`,vueCode:null}},{detailTitle:"<code>d3.filter(<i>資料, 方法</i>)</code>遍歷資料陣列，回傳所有符合條件的資料",detailSubtitle:null,detailComponent:null,detailCode:{htmlCode:null,jsCode:`const numberData = [5, 1, 35, 13, 15, 18, 21, 31, 29];
const filter = d3.filter(numberData, (d) => d > 20);
console.log("filter", filter);

// return 'filter' [35, 21, 31, 29]`,vueCode:null}},{detailTitle:"<code>d3.sort(<i>資料[, 方法]</i>)</code>整理並排序陣列中的資料，預設是由小到大排序陣列",detailSubtitle:null,detailComponent:null,detailCode:{htmlCode:null,jsCode:`const numberData = [5, 1, 35, 13, 15, 18, 21, 31, 29];
const sort = d3.sort(numberData);
console.log("sort", sort);

// return 'sort' [1, 5, 13, 15, 18, 21, 29, 31, 35]`,vueCode:null}}]},{listTitle:"Time Formats 分類的常用 API",listSubtitle:`<ul><li>
<h6>Time Formats 常用說明字符如下：</h6>
<table style="width: 100%;">
  <thead>
    <tr>
      <th>參數</th>
      <th>說明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>%Y</code></td>
      <td>西元年。</td>
    </tr>
    <tr>
      <td><code>%y</code></td>
      <td>西元年最末的兩位數。</td>
    </tr>
    <tr>
      <td><code>%m</code></td>
      <td>一年的某一個月（01~12）。</td>
    </tr>
    <tr>
      <td><code>%d</code></td>
      <td>一月的某一天（01~31）。</td>
    </tr>
    <tr>
      <td><code>%j</code></td>
      <td>一年的某一天（001~366）。</td>
    </tr>
    <tr>
      <td><code>%B</code></td>
      <td>月份。</td>
    </tr>
    <tr>
      <td><code>%b</code></td>
      <td>月份的縮寫。</td>
    </tr>
    <tr>
      <td><code>%A</code></td>
      <td>星期幾。</td>
    </tr>
    <tr>
      <td><code>%a</code></td>
      <td>星期幾的縮寫。</td>
    </tr>
  </tbody>
</table>
</li></ul>`,listComponent:null,listCode:{htmlCode:null,jsCode:null,vueCode:null},listDetails:[{detailTitle:"<code>d3.timeParse(<i>說明字符</i>)</code> 將日期資訊轉換成 d3.js 能夠看得懂的數值",detailSubtitle:null,detailComponent:null,detailCode:{htmlCode:null,jsCode:`// 其中一種寫法
const timeData = "2024-07-25";
const timeParse = d3.timeParse("%Y-%m-%d");
console.log("d3標準格式時間", timeParse(timeData));

// return 'd3標準格式時間' Thu Jul 25 2024 00:00:00 GMT+0800 (台北標準時間)



// 另外一種寫法
const timeParse = d3.timeParse("%Y-%m-%d")("2024-07-25");
console.log("d3標準格式時間", timeParse);

// return 'd3標準格式時間' Thu Jul 25 2024 00:00:00 GMT+0800 (台北標準時間)`,vueCode:null}},{detailTitle:"<code>d3.timeFormat(<i>轉換出來的方式</i>)</code> 將 d3.js 能夠看得懂的數值轉換成我們要的日期格式",detailSubtitle:null,detailComponent:null,detailCode:{htmlCode:null,jsCode:`// 若已有d3標準格式時間，可以直接套入以下code
const timeFormat = d3.timeFormat("%Y.%m.%d");
console.log("我們要的時間格式", timeFormat(此處放入d3標準格式時間));



// 也可用於先將一般格式轉換成d3標準格式時間
const timeParse = d3.timeParse("%Y-%m-%d")("2024-07-25");
console.log("d3標準格式時間", timeParse);

// 再套入函式轉換為我們要的時間格式
const timeFormat = d3.timeFormat("%Y.%m.%d");
console.log("我們要的時間格式", timeFormat(timeParse));

// return 'd3標準格式時間' Thu Jul 25 2024 00:00:00 GMT+0800 (台北標準時間)
// return '我們要的時間格式' 2024.07.25`,vueCode:null}}]},{listTitle:"Number Formats 分類的常用 API",listSubtitle:null,listComponent:null,listCode:{htmlCode:null,jsCode:null,vueCode:null},listDetails:[{detailTitle:"<code>d3.format(<i>說明字符</i>)</code> 處理數字，說明字符填入數字格式的方法。以下舉例三種常見用法。",detailSubtitle:null,detailComponent:null,detailCode:{htmlCode:null,jsCode:`// 將數字四捨五入到某位（此處以取至第四位做舉例）
const numberFormat = d3.format(".4f");
const roundFormat = numberFormat(Math.PI);
console.log("四捨五入至小數點後第四位", roundFormat);

// return '四捨五入至小數點後第四位' 3.1416



// 將數字轉換成二進位數字
const numberFormat = d3.format("b");
const binaryFormat = numberFormat(2024);
console.log("二進位數字", binaryFormat);

// return '二進位數字' 11111101000



// 將數值每三位加上一個逗號
const data = [99920, 11022, 35352, 11442];
const dataAdjusted = data.map((d) => d3.format(",")(d));
console.log("將數值千位一個逗號", dataAdjusted);

// return '將數值千位一個逗號' ['99,920', '11,022', '35,352', '11,442']`,vueCode:null}}]},{listTitle:"Random Numbers 分類的常用 API",listSubtitle:null,listComponent:null,listCode:{htmlCode:null,jsCode:null,vueCode:null},listDetails:[{detailTitle:"<code>d3.randomInt(<i>[最小值, ]最大值</i>)</code> 產生隨機整數。若未設定最小值，最小值預設為 0。",detailSubtitle:null,detailComponent:null,detailCode:{htmlCode:null,jsCode:` // 沒有設定最小值
const randomNum = d3.randomInt(100)();

// 有設定最大值
const randomNum = d3.randomInt(50, 100)();

console.log("隨機變數", randomNum);`,vueCode:null}}]},{listTitle:"來自 ChatGPT 的重點整理",listSubtitle:`<div style="border-left: 5px solid #a8a8a8; padding-left: 24px;">
  <h3>《D3 實用工具函式整理（不含繪圖功能）》</h3>

  <h4>統計類（Statistics）</h4>
  <ul>
    <li><code>d3.min(array)</code>：取得陣列中的最小值</li>
    <li><code>d3.max(array)</code>：取得陣列中的最大值</li>
    <li><code>d3.extent(array)</code>：同時回傳最小與最大值，結果為 <code>[min, max]</code></li>
    <li><code>d3.sum(array)</code>：計算總和</li>
    <li><code>d3.mean(array)</code>：平均數</li>
    <li><code>d3.median(array)</code>：中位數</li>
  </ul>

  <h4>邏輯類（Boolean 判斷）</h4>
  <ul>
    <li><code>d3.every(array, fn)</code>：是否所有項目都符合條件</li>
    <li><code>d3.some(array, fn)</code>：是否有任一項目符合條件</li>
  </ul>

  <h4>搜尋與排序</h4>
  <ul>
    <li><code>d3.ascending(a, b)</code>：升冪排序用的 compare 函式</li>
    <li><code>d3.descending(a, b)</code>：降冪排序用的 compare 函式</li>
    <li><code>d3.bisect</code>：對已排序的陣列進行二分搜尋（快速找插入點）</li>
  </ul>

  <h4>資料處理</h4>
  <ul>
    <li><code>d3.group(array, keyFn)</code>：根據 key 分組，結果為 Map</li>
    <li><code>d3.rollup(array, reduceFn, keyFn)</code>：先分組，再統計</li>
    <li><code>d3.merge(arrays)</code>：將多個陣列合併成一個</li>
    <li><code>d3.range(start, stop[, step])</code>：生成數字範圍陣列</li>
  </ul>

  <h4>亂數產生</h4>
  <ul>
    <li><code>d3.randomUniform(min, max)</code>：生成均勻分佈亂數函式</li>
    <li><code>d3.randomInt(min, max)</code>：生成整數亂數函式（v7+）</li>
  </ul>

  <h4>時間處理</h4>
  <ul>
    <li><code>d3.timeParse(format)</code>：回傳一個函式，將字串轉為 <code>Date</code></li>
    <li><code>d3.timeFormat(format)</code>：回傳一個函式，將 <code>Date</code> 格式化為字串</li>
  </ul>

  <h4>格式化</h4>
  <ul>
    <li><code>d3.format(specifier)</code>：數字格式化（例：千分位、小數位數、補零）</li>
  </ul>
</div>`,listComponent:null,listCode:{htmlCode:null,jsCode:null,vueCode:null},listDetails:[{detailTitle:null,detailSubtitle:null,detailComponent:null,detailCode:{htmlCode:null,jsCode:null,vueCode:null}}]}]},{id:"d3jsHelperFunctionNote",title:"繪圖 HelperFunction",description:`<table>
  <thead>
    <tr>
      <th>Function 類別</th>
      <th>說明</th>
      <th>常用的 API</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><b>Generators</b></td>
      <td>接受陣列類型的資料，產生 <code>&lt;path&gt;</code> 的 <code>d</code> 標籤路徑，用以繪製 svg。</td>
      <td><code>line()</code>、<code>area()</code>、<code>arc()</code></td>
    </tr>
    <tr>
      <td><b>Components</b></td>
      <td>接受方法類型的資料，產生 DOM 元素。</td>
      <td><code>axis()</code>、<code>brush()</code>、<code>zoom()</code></td>
    </tr>
    <tr>
      <td><b>Layouts</b></td>
      <td>接受完整資料集，產生整張圖表。</td>
      <td><code>stack()</code>、<code>pie()</code>、<code>chord()</code></td>
    </tr>
  </tbody>
</table>`,descriptionComponent:null,descriptionComponentStyle:null,lists:[{listTitle:"Generators",listSubtitle:null,listComponent:null,listCode:{htmlCode:null,jsCode:null,vueCode:null},listDetails:[{detailTitle:"Lines",detailSubtitle:null,detailComponent:t(()=>e(()=>import("./D3jsLinesDemo-FB6ga7PK.js"),__vite__mapDeps([10,1,2,3,11,12,13,14,4]))),detailCode:{htmlCode:`<svg id="lineWrapper"></svg>

<script>
  const lineData = [
    { x: 50, y: 180 },
    { x: 50, y: 100 },
    { x: 200, y: 100 },
    { x: 200, y: 20 },
    { x: 400, y: 20 },
  ];
  const drawLine = d3.line().x((d) => d.x)
                            .y((d) => d.y);

  d3.select("#lineWrapper")
    .append("path")
    .attr("d", drawLine(lineData))
    .attr("stroke", "black")
    .attr("stroke-width", "2")
    .attr("fill", "none");


  // 這整段code，為的是寫出
  // <svg id="lineWrapper">
  //   <path d="M50,180L50,100L200,100L200,20L400,20" stroke="black" stroke-width="2" fill="none"></path>
  // </svg>
  // 其中<path>中的d，因不易用人工直接寫出，所以需要這段d3.js的code協助。
<\/script>`,jsCode:null,vueCode:`<template>
  <svg ref="svgRef" width="500" height="150"></svg>
</template>

<script setup>
import { ref, onMounted } from "vue";
import * as d3 from "d3";

const svgRef = ref(null);

onMounted(() => {
  const data = [
    { x: 50, y: 180 },
    { x: 50, y: 100 },
    { x: 200, y: 100 },
    { x: 200, y: 20 },
    { x: 400, y: 20 },
  ];

  const drawLine = d3.line()
    .x((d) => d.x)
    .y((d) => d.y);
  
  d3.select(svgRef.value)
    .append("path")
    .attr("d", drawLine(data))
    .attr("stroke", "black")
    .attr("stroke-width", "2")
    .attr("fill", "none");
});
<\/script>

<style scoped></style>`}},{detailTitle:"Areas",detailSubtitle:null,detailComponent:t(()=>e(()=>import("./D3jsAreasDemo-DoTeoTgc.js"),__vite__mapDeps([15,1,2,3,16,12,13,11,14,4]))),detailCode:{htmlCode:`<svg id="areaWrapper"></svg>

<script>
  const areaData = [
    { x: 30, y: 180 },
    { x: 50, y: 100 },
    { x: 200, y: 100 },
    { x: 200, y: 20 },
    { x: 400, y: 20 },
  ];
  const drawArea = d3.area()
                     .x((d) => d.x)
                     .y0(10)
                     .y1((d) => d.y);
  // 此處一般至少會有三個參數，例如：area.x().y0().y1()

  d3.select("#areaWrapper")
    .append("path")
    .attr("d", drawArea(areaData))
    .attr("stroke", "black")
    .attr("stroke-width", "2")
    .attr("fill", "rgba(31, 211, 255, 0.2)");
<\/script>`,jsCode:null,vueCode:`<template>
  <svg ref="areaSvgRef" width="500" height="200"></svg>
</template>

<script setup>
import { ref, onMounted } from "vue";
import * as d3 from "d3";

const areaSvgRef = ref(null);

onMounted(() => {
  const data = [
    { x: 30, y: 180 },
    { x: 50, y: 100 },
    { x: 200, y: 100 },
    { x: 200, y: 20 },
    { x: 400, y: 20 },
  ];

  const drawArea = d3.area()
    .x((d) => d.x)
    .y0(10)
    .y1((d) => d.y);
  // 此處一般至少會有三個參數，例如：area.x().y0().y1()

  d3.select(areaSvgRef.value)
    .append("path")
    .attr("d", drawArea(data))
    .attr("stroke", "black")
    .attr("stroke-width", "2")
    .attr("fill", "rgba(31, 211, 255, 0.2)");
});
<\/script>

<style scoped></style>`}},{detailTitle:"Curves",detailSubtitle:null,detailComponent:t(()=>e(()=>import("./D3jsCurvesDemo-CKgTDDX2.js"),__vite__mapDeps([17,1,2,3,11,12,13,14,18,4]))),detailCode:{htmlCode:`<svg id="curveWrapper"></svg>

<script>
  const curveData = [
    { x: 50, y: 180 },
    { x: 50, y: 100 },
    { x: 200, y: 100 },
    { x: 200, y: 20 },
    { x: 400, y: 20 },
  ];
  const drawLineCurveBasis = d3.line()
                            .curve(d3.curveBasis)  // 選好要代入的d3.js曲線種類參數
                            .x((d) => d.x)
                            .y((d) => d.y);

  d3.select("#curveWrapper")
    .append("path")
    .attr("d", drawLineCurveBasis(curveData))
    .attr("stroke", "black")
    .attr("stroke-width", "2")
    .attr("fill", "none");
<\/script>`,jsCode:null,vueCode:`<template>
  <svg ref="curveSvgRef" width="500" height="200"></svg>
</template>

<script setup>
import { ref, onMounted } from "vue";
import * as d3 from "d3";

const curveSvgRef = ref(null);

onMounted(() => {
  const data = [
    { x: 50, y: 180 },
    { x: 50, y: 100 },
    { x: 200, y: 100 },
    { x: 200, y: 20 },
    { x: 400, y: 20 },
  ];

  const drawLineCurvesBasis = d3.line()
    .curve(d3.curveBasis)  // 選好要代入的d3.js曲線種類參數
    .x((d) => d.x)
    .y((d) => d.y);

  d3.select(curveSvgRef.value)
    .append("path")
    .attr("d", drawLineCurvesBasis(data))
    .attr("stroke", "black")
    .attr("stroke-width", "2")
    .attr("fill", "none");
});
<\/script>

<style scoped></style>`}},{detailTitle:"Arcs",detailSubtitle:null,detailComponent:t(()=>e(()=>import("./D3jsArcsDemo-DIVjfv0n.js"),__vite__mapDeps([19,1,2,3,20,13,14,4]))),detailCode:{htmlCode:`<svg id="arcWrapper"></svg>

<script>
  const drawArc = d3.arc()
                    .innerRadius(80)
                    .outerRadius(90)
                    .startAngle(Math.PI * 1.2)
                    .endAngle(Math.PI * 2.8);

  d3.select("#arcWrapper")
    .append("g")
    .attr("transform", "translate(200, 100)")  // 圓心預設在[0, 0]，要透過transform移到畫面中
    .append("path")
    .attr("d", drawArc)
    .attr("stroke", "black")
    .attr("fill", "rgba(31, 211, 255, 0.2)");
<\/script>`,jsCode:null,vueCode:`<template>
  <svg ref="arcSvgRef" width="500" height="200"></svg>
</template>

<script setup>
import { ref, onMounted } from "vue";
import * as d3 from "d3";

const arcSvgRef = ref(null);

onMounted(() => {
  const drawArc = d3.arc()
    .innerRadius(80)
    .outerRadius(90)
    .startAngle(Math.PI * 1.2)
    .endAngle(Math.PI * 2.8);

  d3.select(arcSvgRef.value)
    .append("g")
    .attr("transform", "translate(200, 100)")  // 圓心預設在[0, 0]，要透過transform移到畫面中
    .append("path")
    .attr("d" ,drawArc)
    .attr("stroke", "black")
    .attr("fill", "rgba(31, 211, 255, 0.2)");
});
<\/script>

<style scoped></style>`}}]},{listTitle:"Components",listSubtitle:null,listComponent:null,listCode:{htmlCode:null,jsCode:null,vueCode:null},listDetails:[{detailTitle:"Axes",detailSubtitle:null,detailComponent:t(()=>e(()=>import("./D3jsAxesDemo-Bl5bgkuh.js"),__vite__mapDeps([21,1,22,23,24,25,26,27,28,2,3,29,4]))),detailCode:{htmlCode:`<svg id="axeWrapper"></svg>

<script>
  // 預設一組資料，用這組資料來繪製出一條X軸線
  const axeData = [
    { x: 10, y: 100 },
    { x: 20, y: 100 },
    { x: 30, y: 100 },
    { x: 90, y: 20 },
    { x: 220, y: 10 },
  ];

  // 抓出X軸要使用的資料
  const xData = axeData.map((i) => i.x);

  // 設定X軸的比例尺與繪製範圍
  const xScale = d3.scaleLinear()
                   .domain([0, d3.max(xData)])
                   .range([10, 290]);

  // 使用xScale的設定，繪製刻度(ticks)朝下的軸線
  const xAxis= d3.axisBottom(xScale);

  // 繪製軸線
  d3.select("#axeWrapper")
    .append("g")
    .call(xAxis)
    .attr("transform", "translate(0, 130)");  // 調整X軸位置
<\/script>`,jsCode:null,vueCode:`<template>
  <svg ref="axisSvgRef" width="500" height="120"></svg>
</template>

<script setup>
import { ref, onMounted } from "vue";
import * as d3 from "d3";

const axisSvgRef = ref(null);

onMounted(() => {
  // 預設一組資料，用這組資料來繪製出一條X軸線
  const data = [
    { x: 10, y: 100 },
    { x: 20, y: 100 },
    { x: 30, y: 100 },
    { x: 90, y: 20 },
    { x: 220, y: 10 },
  ];

  // 抓出X軸要使用的資料
  const xData = data.map((d) => d.x);

  // 設定X軸的比例尺與繪製範圍
  const xScale = d3.scaleLinear()
    .domain([0, d3.max(xData)])
    .range([10, 290]);

  // 使用xScale的設定，繪製刻度(ticks)朝下的軸線
  const xAxis = d3.axisBottom(xScale);

  // 繪製軸線
  d3.select(axisSvgRef.value)
    .append("g")
    .call(xAxis)
    .attr("transform", "translate(0, 50)")  // 調整X軸位置
});
<\/script>

<style scoped></style>`}}]},{listTitle:"Layouts",listSubtitle:null,listComponent:null,listCode:{htmlCode:null,jsCode:null,vueCode:null},listDetails:[{detailTitle:"Stacks",detailSubtitle:null,detailComponent:t(()=>e(()=>import("./D3jsStacksDemo-8Ob5ccmS.js"),__vite__mapDeps([30,1,31,26,2,3,32,12,13,4]))),detailCode:{htmlCode:`<svg id="stackWrapper"></svg>

<script>
  const dataStack = [
    { month: new Date(2023, 0, 1), China: 132, America: 120, Taiwan: 30 },
    { month: new Date(2023, 1, 1), China: 70, America: 127, Taiwan: 98 },
    { month: new Date(2023, 2, 1), China: 130, America: 33, Taiwan: 118 },
    { month: new Date(2023, 3, 1), China: 60, America: 90, Taiwan: 60 },
  ];

  // 設定資料的keys
  const stackGenerator = d3.stack()
                           .keys(["China", "America", "Taiwan"]);

  // 把資料帶入stack方法
  const stackedSeries = stackGenerator(dataStack);

  // 設定顏色
  const colorScale = d3.scaleOrdinal()
                       .domain(["China", "America", "Taiwan"])
                       .range(["red", "blue", "orange"]);

  // 建立集合g、設定顏色
  const g = d3.select("#stackWrapper")
              .attr("width", 300)
              .selectAll("#stackWrapper g")
              .data(stackedSeries)
              .enter()
              .append("g")
              .attr("fill", (d) => colorScale(d.key));

  // 繪製長條圖
  g.selectAll("rect")
   .data((d) => d)
   .join("rect")
   .attr("width", (d) => d[1] - d[0])
   .attr("x", (d) => d[0])
   .attr("y", (d, i) => i * 35)
   .attr("height", 20);
<\/script>`,jsCode:null,vueCode:`<template>
  <svg ref="stackSvgRef" width="500" height="140"></svg>
</template>

<script setup>
import { ref, onMounted } from "vue";
import * as d3 from "d3";

const stackSvgRef = ref(null);

onMounted(() => {
  const data = [
    { month: new Date(2023, 0, 1), China: 132, America: 120, Taiwan: 30 },
    { month: new Date(2023, 1, 1), China: 70, America: 127, Taiwan: 98 },
    { month: new Date(2023, 2, 1), China: 130, America: 33, Taiwan: 118 },
    { month: new Date(2023, 3, 1), China: 60, America: 90, Taiwan: 60 },
  ];

  // 設定資料的keys
  const stackGenerator = d3.stack()
    .keys(["China", "America", "Taiwan"]);

  // 把資料帶入stack方法
  const stackedSeries = stackGenerator(data);

  // 設定顏色
  const colorScale = d3.scaleOrdinal()
    .domain(["China", "America", "Taiwan"])
    .range(["red", "blue", "orange"]);

  // 建立集合g、設定顏色
  const g = d3.select(stackSvgRef.value)
    .attr("width", 300)
    .selectAll(stackSvgRef.value.g)
    .data(stackedSeries)
    .enter()
    .append("g")
    .attr("fill", (d) => colorScale(d.key));

  // 繪製長條圖
  g.selectAll("rect")
    .data((d) => d)
    .join("rect")
    .attr("width", (d) => d[1] - d[0])
    .attr("x" ,(d) => d[0])
    .attr("y" , (d, i) => i * 35)
    .attr("height", 20);
});
<\/script>

<style scoped></style>`}}]}]},{id:"d3jsScalesNote",title:"各種比例尺",description:`<svg width="450" height="120">
  <rect width="150" height="50" x="20" y="25" rx="10" stroke="#ffd382" stroke-width="4" fill="none"></rect>
  <text x="42" y="55" font-size="18">輸入域domain</text>
  <text x="200" y="62" font-size="40">&rarr;</text>
  <rect width="150" height="50" x="270" y="25" rx="10" stroke="orange" stroke-width="4" fill="none"></rect>
  <text x="300" y="55" font-size="18">輸出域range</text>
</svg>

<table>
  <tr>
    <td>「<b>連續性資料輸入</b>」與「<b>連續性資料輸出</b>」的比例尺</td>
    <td>連續性比例尺（Continuous Scale）、序列比例尺（Sequential Scale）、發散比例尺（Diverging Scale）</td>
  </tr>
  <tr>
    <td>「<b>連續性資料輸入</b>」與「<b>離散性資料輸出</b>」的比例尺</td>
    <td>量化比例尺（Quantize Scale）</td>
  </tr>
  <tr>
    <td>「<b>離散性資料輸入</b>」與「<b>離散性資料輸出</b>」的比例尺</td>
    <td>次序／序位比例尺（Ordinal Scale）</td>
  </tr>
</table>

<table style="margin-top: 16px;">
  <tr>
    <td>連續性比例尺（Continuous Scale）</td>
    <td>
      線性比例尺 <code>d3.scaleLinear()</code><br>
      冪比比例尺 d3.scalePow<br>
      對數比例尺 d3.scaleLog<br>
      恆等比例尺 d3.scaleIdentity<br>
      放射比例尺 d3.scaleRadial<br>
      時間比例尺 <code>d3.scaleTime()</code>、<code>d3.scaleUtc()</code>
    </td>
    <td rowspan="3">
      三者差異：
      <ul>
        <li style="margin-top: 4px;"><b>連續性比例尺</b>：<br>適用於連續數據的平滑變化，例如顏色連續過渡。</li>
        <li style="margin-top: 4px;"><b>序列比例尺</b>：<br>適用於有序數據的單向變化，例如顏色從淺到深或從深到淺。</li>
        <li style="margin-top: 4px;"><b>發散比例尺</b>：<br>適用於有兩個極端的數據，中間值對稱變化，例如強調正負或增減。</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>序列比例尺（Sequential Scale）</td>
    <td>
      <code>d3.scaleSequential()</code><br>
    </td>
  </tr>
  <tr>
    <td>發散比例尺（Diverging Scale）</td>
    <td>
      <code>d3.scaleDiverging()</code><br>
    </td>
  </tr>
  <tr>
    <td>量化比例尺（Quantize Scale）</td>
    <td colspan="2">
      量化比例尺 <code>d3.scaleQuantize()</code><br>
      分位數比例尺 d3.scaleQuantile<br>
      閾值／臨界值比例尺 d3.scaleThreshold
    </td>
  </tr>
  <tr>
    <td>次序／序位比例尺（Ordinal Scale）</td>
    <td colspan="2">
      次序比例尺 <code>d3.scaleOrdinal()</code><br>
      隱含比例尺 d3.scaleImplicit<br>
      區段比例尺 <code>d3.scaleBand()</code><br>
      點比例尺 <code>d3.scalePoint()</code>
    </td>
  </tr>
</table>`,descriptionComponent:null,descriptionComponentStyle:null,lists:[{listTitle:"連續性比例尺（Continuous Scale）",listSubtitle:null,listComponent:null,listCode:{htmlCode:null,jsCode:null,vueCode:null},listDetails:[{detailTitle:"<code>d3.scaleLinear()</code> 線性比例尺",detailSubtitle:null,detailComponent:null,detailCode:{htmlCode:null,jsCode:`const linearScale = d3.scaleLinear()
                      .domain([0, 100])
                      .range([0, 50]);

// 線性比例尺也可以用來換算顏色的色度
const colorScale = d3.scaleLinear()
                     .domain([0, 10])
                     .range(['yellow', 'red']);`,vueCode:null}},{detailTitle:"<code>d3.scaleTime()</code> （本地）時間比例尺、<code>d3.scaleUtc()</code> 世界標準時間比例尺",detailSubtitle:null,detailComponent:null,detailCode:{htmlCode:null,jsCode:`const timeScale = d3.scaleTime()
                    .domain([new Date(2024, 0, 1), new Date(2024, 8, 1)])
                    .range([0, 100]);

const utcScale = d3.scaleUtc()
                   .domain([new Date(Date.UTC(2024, 1, 1)), new Date(Date.UTC(2024, 12, 31))])
                   .range([0, 100]);

// 兩者用法類似，有以下差別：
// '.scaleTime()'是D3.js中的時間尺度，用來處理本地時間（Local Time），根據使用者系統設定的時區來計算。
// '.scaleUtc()'則是處理UTC（Coordinated Universal Time，世界標準時間），時間不受時區影響。若在全球範圍內需要統一時間基準時，使用'.scaleUtc()'會更合適。
`,vueCode:null}},{detailTitle:"<code>continuous.invert()</code>、<code>continuous.clamp()</code>、<code>continuous.nice()</code>一些連續比例尺的細節設定 API",detailSubtitle:null,detailComponent:t(()=>e(()=>import("./D3jsScaleWithNiceComparison-6DSrBcsG.js"),__vite__mapDeps([33,1,22,23,24,25,26,27,34,2,3,29,4]))),detailCode:{htmlCode:null,jsCode:`// continuous.invert() 反推轉換
const linearScale = d3.scaleLinear()
                      .domain([0, 10])
                      .range([0, 100]);

console.log("invertTest", linearScale.invert(50));  // return 5



// continuous.clamp() 斬斷超過範圍的數值
const linearScaleClamp = d3.scaleLinear()
                           .domain([0, 10])
                           .range([0, 100])
                           .clamp(true);  // 截斷超過範圍的數值，例如此例的輸出域就不會超過[0, 100]

console.log("linearScaleClampTest", linearScaleClamp(-5));  // return 0
console.log("linearScaleClampTest", linearScaleClamp(3));  // return 30
console.log("linearScaleClampTest", linearScaleClamp(10.6));  // return 100



// continuous.nice() 延展終始值
const d3TestScaleNiceData = [0.243, 0.584, 0.987, 0.153, 0.433];
const d3TestScaleWithoutNice = d3.scaleLinear()
                                 .domain(d3.extent(data))
                                 .range([0, 300]);  // 此時比例尺輸出的軸線會有不完整的刻度（如上左圖）
const d3TestScaleWithNice = d3.scaleLinear()
                              .domain(d3.extent(data))
                              .range([0, 300]);  // 此時比例尺輸出的軸線終始值會有較好看的刻度（如上右圖）`,vueCode:null}}]},{listTitle:"序列比例尺（Sequential Scale）",listSubtitle:"與連續比例尺不同的是，序列比例尺只能根據指定的內建插補器來設定，且輸出域、插補方式不可更動。",listComponent:null,listCode:{htmlCode:null,jsCode:`const sequentialScale = d3.scaleSequential()
                          .domain([0, 100])
                          .interpolator(d3.interpolateRainbow);

console.log("sequentialScaleTest", sequentialScale(0));  // return 'rgb(110, 64, 170)'
console.log("sequentialScaleTest", sequentialScale(50));  // return 'rgb(175, 240, 91)'
console.log("sequentialScaleTest", sequentialScale(100));  // return 'rgb(110, 64, 170)'`,vueCode:null},listDetails:[{detailTitle:null,detailSubtitle:null,detailComponent:null,detailCode:{htmlCode:null,jsCode:null,vueCode:null}}]},{listTitle:"發散比例尺（Diverging Scale）",listSubtitle:"主要用來將兩個相反方向的現象視覺化，像是正負數、朝上朝下。需帶入三個數值（兩個極端值與一個中間值），輸出域必須按照內建的插補值去設定。",listComponent:null,listCode:{htmlCode:null,jsCode:`const scaleAnomalyPuOr = d3.scaleDiverging()
                           .domain([-10, 0, 10])
                           .interpolator(d3.interpolatePuOr);

console.log("divergingScaleTest", scaleAnomalyPuOr(-10));  // return 'rgb(45, 0, 75)' 深紫色
console.log("divergingScaleTest", scaleAnomalyPuOr(0));  // return 'rgb(243, 238, 234)' 類白色
console.log("divergingScaleTest", scaleAnomalyPuOr(10));  // return 'rgb(127, 59, 8)' 橘色`,vueCode:null},listDetails:[{detailTitle:null,detailSubtitle:null,detailComponent:null,detailCode:{htmlCode:null,jsCode:null,vueCode:null}}]},{listTitle:"量化比例尺（Quantize Scale）",listSubtitle:"將一組連續性的資料，映射到另一組離散性的資料中。",listComponent:null,listCode:{htmlCode:null,jsCode:null,vueCode:null},listDetails:[{detailTitle:"<code>d3.scaleQuentize()</code> 量化比例尺",detailSubtitle:null,detailComponent:null,detailCode:{htmlCode:null,jsCode:`const quantizeScale = d3.scaleQuantize()
                        .domain([0, 100])
                        .range(['lightblue', 'orange', 'lightgreen', 'red']);

console.log("quantizeScaleTest", quantizeScale(3));  // return 'lightblue'
console.log("quantizeScaleTest", quantizeScale(73));  // return 'lightgreen'`,vueCode:null}}]},{listTitle:"次序／序位比例尺（Ordinal Scale）",listSubtitle:"將一組離散性的資料，映射到另一組離散性的資料中。",listComponent:null,listCode:{htmlCode:null,jsCode:null,vueCode:null},listDetails:[{detailTitle:"<code>d3.scaleOrdinal()</code> 次序比例尺",detailSubtitle:null,detailComponent:null,detailCode:{htmlCode:null,jsCode:`const ordinalData = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
const ordinalScale = d3.scaleOrdinal()
                       .domain(ordinalData)
                       .range(['black', 'red', 'green']);

console.log("ordinalScaleTest", ordinalScale('Jan'));  // return 'black'
console.log("ordinalScaleTest", ordinalScale('May'));  // return 'red'

// 輸入的數值不在輸入域範圍的話，自動被加進輸入域的最後一位
console.log("ordinalScaleTest", ordinalScale('Sunday'));  // return 'black'
console.log("ordinalScaleTest", ordinalScale('Monday'));  // return 'red'`,vueCode:null}},{detailTitle:"<code>d3.scaleBand()</code> 區段比例尺",detailSubtitle:null,detailComponent:null,detailCode:{htmlCode:null,jsCode:`const bandScale = d3.scaleBand()
                    .domain(['狗', '貓', '天竺鼠', '烏龜', '海豚'])
                    .range([0, 200]);

console.log("bandScaleTest", bandScale('狗'));  // return 0
console.log("bandScaleTest", bandScale('貓'));  // return 40
console.log("bandScaleTest", bandScale('海豚'));  // return 160


// 透過band.bandwidth()取得各刻度間距
console.log("bandwidthTest", bandScale.bandwidth());  // return 40`,vueCode:null}},{detailTitle:"<code>d3.scalePoint()</code> 點比例尺",detailSubtitle:null,detailComponent:null,detailCode:{htmlCode:null,jsCode:`const pointScale = d3.scalePoint()
                     .domain(['狗', '貓', '天竺鼠', '烏龜', '海豚'])
                     .range([0, 200]);

console.log("pointScaleTest", pointScale('狗'));  // return 0
console.log("pointScaleTest", pointScale('貓'));  // return 50
console.log("pointScaleTest", pointScale('海豚'));  // return 200

// 透過point.step()取得各刻度間距
console.log("pointStepTest", pointScale.step());  // return 50`,vueCode:null}}]}]},{id:"d3jsAxesNote",title:"各種軸線與刻度",description:`軸線由以下三種DOM元素構成：
<ul style="line-height: 1.65;">
  <li><code>&lt;path&gt;</code>：一條直線，繪製軸線的線段。</li>
  <li><code>&lt;line&gt;</code>：一組延著軸線的刻度記號。</li>
  <li><code>&lt;text&gt;</code>：每個刻度記號的標籤文字。</li>

  <p style="color: #248666;"><i>（右下待補圖（SvgCoordinateComparison.vue））</i></p>
</ul>`,descriptionComponent:t(()=>e(()=>import("./D3jsAxesGraphExplanation-D2Wb_v3H.js"),__vite__mapDeps([35,1,22,23,24,25,26,27,2,3,29,4]))),descriptionComponentStyle:null,lists:[{listTitle:"各種軸線與刻度（Axes & Ticks）",listSubtitle:null,listComponent:null,listCode:{htmlCode:null,jsCode:null,vueCode:null},listDetails:[{detailTitle:"各種刻度方向的軸線",detailSubtitle:null,detailComponent:t(()=>e(()=>import("./D3jsAxesDirectionsDemo-BFbwlM7k.js"),__vite__mapDeps([36,1,22,23,24,25,26,27,2,3,29,4]))),detailCode:{htmlCode:null,jsCode:null,vueCode:null}},{detailTitle:"繪製一般的 x 軸",detailSubtitle:null,detailComponent:t(()=>e(()=>import("./D3jsXAxisDemo-BxhbmTmH.js"),__vite__mapDeps([37,1,22,23,24,25,26,27,2,3,29,4]))),detailCode:{htmlCode:`<div id="xAxis"></div>

<script>
  // 設定width、height、margin
  const width = 300;
  const height = 200;
  const margin = ( width - height ) / 2;

  // 建立繪製圖表的<svg>
  d3.select("#xAxis")
    .append("svg")
    .attr("width", width)
    .attr("height", height)
    .style("border", "1px solid lightgray");

  // 設定比例尺
  const xScale = d3.scaleLinear()
                   .domain([0, 100])
                   .range([margin, width - margin]);

  // 設定軸線產生方式
  const xAxisGenerator = d3.axisBottom(xScale);

  // 建立<g>元素並呼叫軸線產生方式，生成軸線
  d3.select("#xAxis svg")
    .append("g")
    .call(xAxisGenerator)
    .attr("transform", \`translate(0, \${ height / 2 })\`);
<\/script>`,jsCode:null,vueCode:`<template>
  <svg
    ref="xAxisSvgRef"
    :width="width"
    :height="height"
    style="border: 1px solid lightgray;"
  ></svg>
</template>

<script setup>
import { ref, onMounted } from "vue";
import * as d3 from "d3";

// 圖表尺寸與內邊距設定
const width = 300;
const height = 200;
const margin = (width - height) / 2;

const xAxisSvgRef = ref(null);

onMounted(() => {
  // 設定比例尺
  const xScale = d3.scaleLinear()
                   .domain([0, 100])
                   .range([margin, width - margin]);

  // 設定軸線產生方式
  const xAxisGenerator = d3.axisBottom(xScale);

  // 建立<g>元素並呼叫軸線產生方式，生成軸線
  d3.select(xAxisSvgRef.value)
    .append("g")
    .call(xAxisGenerator)
    .attr("transform", \`translate(0, \${ height / 2 })\`);
});
<\/script>

<style scoped></style>`}},{detailTitle:"<code>axis.ticks(<i>刻度數[, 格式]</i>)</code> 調整刻度（tick）數量",detailSubtitle:"該方法僅接受 2、5、10 倍數的刻度數量，否則會自動抓取最近倍數來調整。",detailComponent:t(()=>e(()=>import("./D3jsAxisTickTestDemo-DB2Mp5o4.js"),__vite__mapDeps([38,1,22,23,24,25,26,27,2,3,29,4]))),detailCode:{htmlCode:`<div id="axisTickTest"></div>

<script>
  // 設定width、height、margin
  const width = 300;
  const height = 200;
  const margin = ( width - height ) / 2;

  // 建立繪製圖表的<svg>
  d3.select("#axisTickTest")
    .append("svg")
    .attr("width", width)
    .attr("height", height)
    .style("border", "1px solid lightgray");

  // 設定比例尺
  const axisTickTestScale = d3.scaleLinear()
                              .domain([0, 100])
                              .range([margin, width - margin]);

  // 設定軸線產生方式
  const axisTickTestAxisGenerator = d3.axisBottom(axisTickTestScale)
                                      .ticks(5);  // 軸線刻度數量5個，以及最前方的1個起始值

  // 建立<g>元素並呼叫軸線產生方式，生成軸線
  d3.select("#axisTickTest svg")
    .append("g")
    .call(axisTickTestAxisGenerator)
    .attr("transform", \`translate(0, \${ height / 2 })\`);
<\/script>`,jsCode:null,vueCode:`<template>
  <svg
    ref="axisTickTestSvgRef"
    :width="width"
    :height="height"
    style="border: 1px solid lightgray"
  ></svg>
</template>

<script setup>
import { ref, onMounted } from "vue";
import * as d3 from "d3";

// 圖表尺寸與內邊距設定
const width = 300;
const height = 200;
const margin = (width - height) / 2;

const axisTickTestSvgRef = ref(null);

onMounted(() => {
  // 設定比例尺
  const axisTickTestScale = d3.scaleLinear()
                              .domain([0, 100])
                              .range([margin, width - margin]);

  // 設定軸線產生方式
  const axisTickTestAxisGenerator = d3.axisBottom(axisTickTestScale)
                                      .ticks(5);  // 軸線刻度數量5個，以及最前方的1個起始值

  // 建立<g>元素並呼叫軸線產生方式，生成軸線
  d3.select(axisTickTestSvgRef.value)
    .append("g")
    .call(axisTickTestAxisGenerator)
    .attr("transform", \`translate(0, \${ height / 2 })\`);
});
<\/script>

<style scoped></style>`}},{detailTitle:"<code>axis.ticks(<i>刻度數[, 格式]</i>)</code> 調整刻度的數字格式",detailSubtitle:"亦可改用 <code>axis.tickFormat()</code> 調整（見第 8 點）。",detailComponent:t(()=>e(()=>import("./D3jsFormatTestDemo-Cr6HuFWv.js"),__vite__mapDeps([39,1,22,23,24,25,26,27,2,3,29,4]))),detailCode:{htmlCode:`<div id="axisFormatTest"></div>

<script>
  // 設定width、height、margin
  const width = 300;
  const height = 200;
  const margin = ( width - height ) / 2;

  // 建立繪製圖表的<svg>
  d3.select("#axisFormatTest")
    .append("svg")
    .attr("width", width)
    .attr("height", height)
    .style("border", "1px solid lightgray");

  // 設定比例尺
  const axisFormatTestScale = d3.scaleLinear()
                                .domain([0, 100])
                                .range([margin, width - margin]);
                            
  // 設定軸線產生方式
  const axisFormatTestAxisGenerator = d3.axisBottom(axisFormatTestScale)
                                        .ticks(5, '.1f');  // 本行亦可換成".ticks(5).tickFormat(d3.format('.1f'))"

  // 建立<g>元素並呼叫軸線產生方式，生成軸線
  d3.select("#axisFormatTest svg")
    .append("g")
    .call(axisFormatTestAxisGenerator)
    .attr("transform", \`translate(0, \${ height / 2 })\`);
<\/script>`,jsCode:null,vueCode:`<template>
  <svg
    ref="axisFormatTestSvgRef"
    :width="width"
    :height="height"
    style="border: 1px solid lightgray;"
  ></svg>
</template>

<script setup>
import { ref, onMounted } from "vue";
import * as d3 from "d3";

// 圖表尺寸與內邊距設定
const width = 300;
const height = 200;
const margin = (width - height) / 2;

const axisFormatTestSvgRef = ref(null);

onMounted(() => {
  // 設定比例尺
  const axisFormatTestScale = d3.scaleLinear()
                                .domain([0, 100])
                                .range([margin, width - margin]);
                            
  // 設定軸線產生方式
  const axisFormatTestAxisGenerator = d3.axisBottom(axisFormatTestScale)
                                        .ticks(5, '.1f');  // 本行亦可換成".ticks(5).tickFormat(d3.format('.1f'))"

  // 建立<g>元素並呼叫軸線產生方式，生成軸線
  d3.select(axisFormatTestSvgRef.value)
    .append("g")
    .call(axisFormatTestAxisGenerator)
    .attr("transform", \`translate(0, \${ height / 2 })\`);
});
<\/script>

<style scoped></style>`}},{detailTitle:"時間比例尺的軸線",detailSubtitle:null,detailComponent:t(()=>e(()=>import("./D3jsAxisTimeTickTestDemo-C_qZZbqi.js"),__vite__mapDeps([40,1,41,23,24,25,26,2,3,29,4]))),detailCode:{htmlCode:`<div id="axisTimeTickTest"></div>

<script>
  // 設定width、height、margin
  const width = 300;
  const height = 200;
  const margin = ( width - height ) / 2;
  const January = new Date(2024, 0);
  const December = new Date(2024, 11);

  // 建立繪製圖表的<svg>
  d3.select("#axisTimeTickTest")
    .append("svg")
    .attr("width", width)
    .attr("height", height)
    .style("border", "1px solid lightgray");

  // 設定比例尺
  const axisTimeTickTestScale = d3.scaleTime()
                                  .domain([January, December])
                                  .range([margin , width - margin]);

  // 設定軸線產生方式
  const axisTimeTickTestAxisGenerator = d3.axisBottom(axisTimeTickTestScale)
                                          .ticks(12, '%B');

  // 建立<g>元素並呼叫軸線產生方式，生成軸線
  d3.select("#axisTimeTickTest svg")
    .append("g")
    .call(axisTimeTickTestAxisGenerator)
    .attr("transform", \`translate(0, \${ height / 2 })\`);
<\/script>`,jsCode:`// 註：Time Formats常用說明字符如下：
// '%Y' => 西元年。
// '%y'	=> 西元年最末的兩位數。
// '%m'	=> 一年的某一個月（01~12）。
// '%d'	=> 一月的某一天（01~31）。
// '%j'	=> 一年的某一天（001~366）。
// '%B'	=> 月份。
// '%b'	=> 月份的縮寫。
// '%A'	=> 星期幾。
// '%a'	=> 星期幾的縮寫。`,vueCode:`<template>
  <svg
    ref="axisTimeTickTestSvgRef"
    :width="width"
    :height="height"
    style="border: 1px solid lightgray;"
  ></svg>
</template>

<script setup>
import { onMounted, ref } from "vue";
import * as d3 from "d3";

// 圖表尺寸與內邊距設定
const width = 300;
const height = 200;
const margin = 20;

const January = new Date(2024, 0);
const December = new Date(2024, 11);

const axisTimeTickTestSvgRef = ref(null);

onMounted(() => {
  // 設定比例尺
  const axisTimeTickTestScale = d3.scaleTime()
                                  .domain([January, December])
                                  .range([margin , width - margin]);

  // 設定軸線產生方式
  const axisTimeTickTestAxisGenerator = d3.axisBottom(axisTimeTickTestScale)
                                          .ticks(12, "%b");

  // 建立<g>元素並呼叫軸線產生方式，生成軸線
  d3.select(axisTimeTickTestSvgRef.value)
    .append("g")
    .call(axisTimeTickTestAxisGenerator)
    .attr("transform", \`translate(0, \${ height / 2 })\`);
});
<\/script>

<style scoped></style>`}},{detailTitle:"<code>axis.tickValues()</code> 指定特殊刻度",detailSubtitle:null,detailComponent:t(()=>e(()=>import("./D3jsAxisTickValueTestDemo-AQ-yLvbo.js"),__vite__mapDeps([42,1,22,23,24,25,26,27,2,3,29,4]))),detailCode:{htmlCode:`<div id="axisTickValueTest"></div>

<script>
  // 設定width、height、margin
  const width = 300;
  const height = 200;
  const margin = ( width - height ) / 2;

  // 建立繪製圖表的<svg>
  d3.select("#axisTickValueTest")
    .append("svg")
    .attr("width", width)
    .attr("height", height)
    .style("border", "1px solid lightgray");

  // 設定比例尺
  const axisTickValueTestScale = d3.scaleLinear()
                                   .domain([0, 100])
                                   .range([margin, width - margin]);

  // 設定軸線產生方式
  const axisTickValueTestAxisGenerator = d3.axisBottom(axisTickValueTestScale)
                                           .tickValues([0, 15, 23, 34, 60, 81, 100]);

  // 建立<g>元素並呼叫軸線產生方式，生成軸線
  d3.select("#axisTickValueTest svg")
    .append("g")
    .call(axisTickValueTestAxisGenerator)
    .attr("transform", \`translate(0, \${ height / 2 })\`);
<\/script>`,jsCode:null,vueCode:`<template>
  <svg
    ref="axisTickValueTestSvgRef"
    :width="width"
    :height="height"
    style="border: 1px solid lightgray;"
  ></svg>
</template>

<script setup>
import { ref, onMounted } from "vue";
import * as d3 from "d3";

// 圖表尺寸與內邊距設定
const width = 300;
const height = 200;
const margin = ( width - height ) / 2;

const axisTickValueTestSvgRef = ref(null);

onMounted(() => {
  // 設定比例尺
  const axisTickValueTestScale = d3.scaleLinear()
                                   .domain([0, 100])
                                   .range([margin, width - margin]);

  // 設定軸線產生方式
  const axisTickValueTestAxisGenerator = d3.axisBottom(axisTickValueTestScale)
                                           .tickValues([0, 15, 23, 34, 60, 81, 100]);

  // 建立<g>元素並呼叫軸線產生方式，生成軸線
  d3.select(axisTickValueTestSvgRef.value)
    .append("g")
    .call(axisTickValueTestAxisGenerator)
    .attr("transform", \`translate(0, \${ height / 2 })\`);
});
<\/script>

<style scoped></style>`}},{detailTitle:"<code>axis.tickValues()</code> 指定特殊刻度（用動態方式減少顯示的標籤數，以利閱讀）",detailSubtitle:"ScaleBand 比例尺呈現指定刻度。",detailComponent:t(()=>e(()=>import("./D3jsScaleBandTickValueTestDemo-2QMfZjYb.js"),__vite__mapDeps([43,1,44,26,31,45,2,3,29,4]))),detailCode:{htmlCode:`<div id="axisScaleBandTickValueTest"></div>

<script>
  // 設定width、height、margin、數據
  const width = 300;
  const height = 200;
  const margin = ( width - height ) / 2;
  const zodiacData = ['鼠', '牛', '虎', '兔', '龍', '蛇', '馬', '羊', '猴', '雞', '狗', '豬'];

  // 建立繪製圖表的<svg>
  const axisScaleBandTickValueTestSVG = d3.select("#axisScaleBandTickValueTest")
                                          .append("svg")
                                          .attr("width", width)
                                          .attr("height", height)
                                          .style("border", "1px solid lightgray");

  // 設定比例尺
  const axisScaleBandTickValueTestScale = d3.scaleBand()
                                            .domain(zodiacData)
                                            .range([margin, width - margin]);

  // 設定軸線產生方式
  const axisScaleBandTickValueTestAxisGenerator = d3.axisBottom(axisScaleBandTickValueTestScale)
                                                    .tickValues(axisScaleBandTickValueTestScale.domain().filter((i, idx) => idx%2 === 0));  // 加這行減少顯示的標籤數（即指定刻度），以利閱讀

  // 建立<g>元素並呼叫軸線產生方式，生成軸線
  axisScaleBandTickValueTestSVG.append("g")
                               .call(axisScaleBandTickValueTestAxisGenerator)
                               .attr("transform", \`translate(0, \${ height / 2})\`);
<\/script>`,jsCode:null,vueCode:`<template>
  <svg
    ref="axisScaleBandTickValueTestSvgRef"
    :width="width"
    :height="height"
    style="border: 1px solid lightgray;"
  ></svg>
</template>

<script setup>
import { onMounted, ref } from "vue";
import * as d3 from "d3";

// 圖表尺寸與內邊距設定
const width = 300;
const height = 200;
const margin = ( width - height ) / 2;

const axisScaleBandTickValueTestSvgRef = ref(null);

const zodiacData = ["鼠", "牛", "虎", "兔", "龍", "蛇", "馬", "羊", "猴", "雞", "狗", "豬"];

onMounted(() => {
  // 設定比例尺
  const axisScaleBandTickValueTestScale = d3.scaleBand()
                                            .domain(zodiacData)
                                            .range([margin, width - margin]);

  // 設定軸線產生方式
  const axisScaleBandTickValueTestAxisGenerator = d3.axisBottom(axisScaleBandTickValueTestScale)
                                                    .tickValues(axisScaleBandTickValueTestScale.domain().filter((d, idx) => idx%2 === 0));  // 加這行減少顯示的標籤數（即指定刻度），以利閱讀

  // 建立<g>元素並呼叫軸線產生方式，生成軸線
  d3.select(axisScaleBandTickValueTestSvgRef.value)
    .append("g")
    .call(axisScaleBandTickValueTestAxisGenerator)
    .attr("transform", \`translate(0, \${ height / 2})\`);
});
<\/script>

<style scoped></style>`}},{detailTitle:"<code>axis.tickFormat(<i>[format]</i>)</code> 調整刻度文字的樣式",detailSubtitle:null,detailComponent:t(()=>e(()=>import("./D3jsAxisTickFormatTestDemo-DGf7Fstd.js"),__vite__mapDeps([46,1,22,23,24,25,26,27,2,3,29,4]))),detailCode:{htmlCode:`<div id="axisTickFormatTest"></div>

<script>
  // 設定width、height、margin
  const width = 300;
  const height = 200;
  const margin = ( width - height ) / 2;

  // 建立繪製圖表的<svg>
  d3.select("#axisTickFormatTest")
    .append("svg")
    .attr("width", width)
    .attr("height", height)
    .style("border", "1px solid lightgray");

  // 設定比例尺
  const axisTickFormatTestScale = d3.scaleLinear()
                                    .domain([0, 100])
                                    .range([margin, width - margin]);

  // 設定軸線產生方式
  const axisTickFormatTestAxisGenerator = d3.axisBottom(axisTickFormatTestScale)
                                            .ticks(5)
                                            .tickFormat(d3.format('.2f'));  // 兩位小數

  // 建立<g>元素並呼叫軸線產生方式，生成軸線
  d3.select("#axisTickFormatTest svg")
    .append("g")
    .call(axisTickFormatTestAxisGenerator)
    .attr("transform", \`translate(0, \${ height / 2 })\`);
<\/script>`,jsCode:null,vueCode:`<template>
  <svg
    ref="axisTickFormatTestSvgRef"
    :width="width"
    :height="height"
    style="border: 1px solid lightgray;"
  ></svg>
</template>

<script setup>
import { ref, onMounted } from "vue";
import * as d3 from "d3";

// 圖表尺寸與內邊距設定
const width = 300;
const height = 200;
const margin = ( width - height ) / 2;

const axisTickFormatTestSvgRef = ref(null);

onMounted(() => {
  // 設定比例尺
  const axisTickFormatTestScale = d3.scaleLinear()
                                    .domain([0, 100])
                                    .range([margin, width - margin]);

  // 設定軸線產生方式
  const axisTickFormatTestAxisGenerator = d3.axisBottom(axisTickFormatTestScale)
                                            .ticks(5)
                                            .tickFormat(d3.format('.2f'));  // 兩位小數

  // 建立<g>元素並呼叫軸線產生方式，生成軸線
  d3.select(axisTickFormatTestSvgRef.value)
    .append("g")
    .call(axisTickFormatTestAxisGenerator)
    .attr("transform", \`translate(0, \${ height / 2 })\`);
});
<\/script>

<style scoped></style>`}},{detailTitle:"增加刻度單位（類調整刻度文字樣式）",detailSubtitle:"使用 <code>axis.tickFormat()</code> 調整。",detailComponent:t(()=>e(()=>import("./D3jsAxisTickFormatUnitTestDemo-9LMu1DQ8.js"),__vite__mapDeps([47,1,22,23,24,25,26,27,2,3,29,4]))),detailCode:{htmlCode:`<div id="axisTickFormatUnitTest"></div>

<script>
  // 設定width、height、margin
  const width = 300;
  const height = 200;
  const margin = ( width - height ) / 2;

  // 建立繪製圖表的<svg>
  d3.select("#axisTickFormatUnitTest")
    .append("svg")
    .attr("width", width)
    .attr("height", height)
    .style("border", "1px solid lightgray");

  // 設定比例尺
  const axisTickFormatUnitTestScale = d3.scaleLinear()
                                        .domain([0, 100])
                                        .range([margin, width - margin]);

  // 設定軸線產生方式
  const axisTickFormatUnitTestAxisGenerator = d3.axisBottom(axisTickFormatUnitTestScale)
                                                .ticks(5)
                                                .tickFormat(d => \`\${d}元\`);  // 增加文字單位

  // 建立<g>元素並呼叫軸線產生方式，生成軸線
  d3.select("#axisTickFormatUnitTest svg")
    .append("g")
    .call(axisTickFormatUnitTestAxisGenerator)
    .attr("transform", \`translate(0, \${ height / 2 })\`);
<\/script>`,jsCode:null,vueCode:`<template>
  <svg
    ref="axisTickFormatUnitTestSvgRef"
    :width="width"
    :height="height"
    style="border: 1px solid lightgray;"
  ></svg>
</template>

<script setup>
import { ref, onMounted } from "vue";
import * as d3 from "d3";

// 圖表尺寸與內邊距設定
const width = 300;
const height = 200;
const margin = ( width - height ) / 2;

const axisTickFormatUnitTestSvgRef = ref(null);

onMounted(() => {
  // 設定比例尺
  const axisTickFormatUnitTestScale = d3.scaleLinear()
                                        .domain([0, 100])
                                        .range([margin, width - margin]);

  // 設定軸線產生方式
  const axisTickFormatUnitTestAxisGenerator = d3.axisBottom(axisTickFormatUnitTestScale)
                                                .ticks(5)
                                                .tickFormat(d => \`\${d}元\`);  // 增加文字單位

  // 建立<g>元素並呼叫軸線產生方式，生成軸線
  d3.select(axisTickFormatUnitTestSvgRef.value)
    .append("g")
    .call(axisTickFormatUnitTestAxisGenerator)
    .attr("transform", \`translate(0, \${ height / 2 })\`);
});
<\/script>

<style scoped></style>`}},{detailTitle:"<code>axis.tickSize()</code> 調整刻度線段長度",detailSubtitle:"刻度線段長度預設長度為 6。",detailComponent:t(()=>e(()=>import("./D3jsAxisTickSizeTestDemo-40YqPSdB.js"),__vite__mapDeps([48,1,22,23,24,25,26,27,2,3,29,4]))),detailCode:{htmlCode:`<div id="axisTickSizeTest"></div>

<script>
  // 設定width、height、margin
  const width = 300;
  const height = 200;
  const margin = ( width - height ) / 2;

  // 建立繪製圖表的<svg>
  const axisTickSizeTestSVG = d3.select("#axisTickSizeTest")
                                .append("svg")
                                .attr("width", width)
                                .attr("height", height)
                                .style("border", "1px solid lightgray");

  // 設定比例尺
  const axisTickSizeTestScale = d3.scaleLinear()
                                  .domain([0, 100])
                                  .range([margin, width - margin]);

  // 設定軸線產生方式，以此例來說，代入正數向下延伸，代入負數向上延伸
  const axisTickSizeTestAxisGenerator = d3.axisBottom(axisTickSizeTestScale)
                                          .tickSize(30);

  // 建立<g>元素並呼叫軸線產生方式，生成軸線
  axisTickSizeTestSVG.append("g")
                     .call(axisTickSizeTestAxisGenerator)
                     .attr("transform", \`translate(0, \${ height / 2 })\`)
<\/script>`,jsCode:null,vueCode:`<template>
  <svg
    ref="axisTickSizeTestSvgRef"
    :width="width"
    :height="height"
    style="border: 1px solid lightgray;"
  ></svg>
</template>

<script setup>
import { ref, onMounted } from "vue";
import * as d3 from "d3";

// 圖表尺寸與內邊距設定
const width = 300;
const height = 200;
const margin = ( width - height ) / 2;

const axisTickSizeTestSvgRef = ref(null);

onMounted(() => {
  // 設定比例尺
  const axisTickSizeTestScale = d3.scaleLinear()
                                  .domain([0, 100])
                                  .range([margin, width - margin]);

  // 設定軸線產生方式，以此例來說，代入正數向下延伸，代入負數向上延伸
  const axisTickSizeTestAxisGenerator = d3.axisBottom(axisTickSizeTestScale)
                                          .tickSize(30);

  // 建立<g>元素並呼叫軸線產生方式，生成軸線
  d3.select(axisTickSizeTestSvgRef.value)
    .append("g")
    .call(axisTickSizeTestAxisGenerator)
    .attr("transform", \`translate(0, \${ height / 2 })\`);
});
<\/script>

<style scoped></style>`}},{detailTitle:"<code>axis.tickSizeInner()</code>、<code>axis.tickSizeOuter()</code> 分開調整長度",detailSubtitle:"D3.js 的刻度線段分成 Inner 與 Outer，可分開調整。",detailComponent:t(()=>e(()=>import("./D3jsAxisTickSizeIOTestDemo-DnBGBDkT.js"),__vite__mapDeps([49,1,44,26,31,45,2,3,29,4]))),detailCode:{htmlCode:`<div id="axisTickSizeIOTest"></div>

<script>
  // 設定width、height、margin
  const width = 300;
  const height = 200;
  const margin = ( width - height ) / 2;
  const zodiacData = ['鼠', '牛', '虎', '兔', '龍', '蛇', '馬', '羊', '猴', '雞', '狗', '豬'];

  // 建立繪製圖表的<svg>
  d3.select("#axisTickSizeIOTest")
    .append("svg")
    .attr("width", width)
    .attr("height", height)
    .style("border", "1px solid lightgray");

  // 設定比例尺
  const axisTickSizeIOTestScale = d3.scaleBand()
                                    .domain(zodiacData)
                                    .range([margin, width - margin]);

  // 設定軸線產生方式
  const axisTickSizeIOTestAxisGeneratorInner = d3.axisBottom(axisTickSizeIOTestScale)
                                                 .tickSizeInner(30);  // 調Inner用這個
                                                 // .tickSizeOuter(30);  調Outer用這個

  // 建立<g>元素並呼叫軸線產生方式，生成軸線
  d3.select("#axisTickSizeIOTest svg")
    .append("g")
    .call(axisTickSizeIOTestAxisGeneratorInner)
    .attr("transform", \`translate(0, \${ height / 2 })\`);
<\/script>`,jsCode:null,vueCode:`<template>
  <svg
    ref="axisTickSizeIOTestSvgRef"
    :width="width"
    :height="height"
    style="border: 1px solid lightgray;"
  ></svg>
</template>

<script setup>
import { ref, onMounted } from "vue";
import * as d3 from "d3";

// 圖表尺寸與內邊距設定
const width = 300;
const height = 200;
const margin = ( width - height ) / 2;

const axisTickSizeIOTestSvgRef =ref(null);

const zodiacData = ["鼠", "牛", "虎", "兔", "龍", "蛇", "馬", "羊", "猴", "雞", "狗", "豬"];

onMounted(() => {
  // 設定比例尺
  const axisTickSizeIOTestScale = d3.scaleBand()
                                    .domain(zodiacData)
                                    .range([margin, width - margin]);

  // 設定軸線產生方式
  const axisTickSizeIOTestAxisGeneratorInner = d3.axisBottom(axisTickSizeIOTestScale)
                                                 .tickSizeInner(30);  // 調Inner用這個
                                                 // .tickSizeOuter(30);  調Outer用這個

  // 建立<g>元素並呼叫軸線產生方式，生成軸線
  d3.select(axisTickSizeIOTestSvgRef.value)
    .append("g")
    .call(axisTickSizeIOTestAxisGeneratorInner)
    .attr("transform", \`translate(0, \${ height / 2 })\`);
});
<\/script>

<style scoped></style>`}},{detailTitle:"<code>axis.tickSizeInner()</code>、<code>axis.tickSizeOuter()</code> 無法完全分開調整長度？",detailSubtitle:"由於 Outer 刻度其實並非刻度線段之一，而是隸屬軸線，所以 Outer 在某些情況下會和首末 Inner 刻度線段重疊，例如使用連續性比例尺（d3.scaleLinear）時。",detailComponent:t(()=>e(()=>import("./D3jsAxisTickSizeIO2TestDemo-Cesrdtzk.js"),__vite__mapDeps([50,1,22,23,24,25,26,27,2,3,29,4]))),detailCode:{htmlCode:`<div id="axisTickSizeIO2Test"></div>

<script>
  // 設定width、height、margin
  const width = 300;
  const height = 200;
  const margin = ( width - height ) / 2;

  // 建立繪製圖表的<svg>
  d3.select("#axisTickSizeIO2Test")
    .append("svg")
    .attr("width", width)
    .attr("height", height)
    .style("border", "1px solid lightgray");

  // 設定比例尺
  const axisTickSizeIO2TestScale = d3.scaleLinear()
                                     .domain([0, 100])
                                     .range([margin, width - margin]);

  // 設定軸線產生方式
  const axisTickSizeIO2TestAxisGeneratorInner = d3.axisBottom(axisTickSizeIO2TestScale)
                                                  .tickSizeInner(30);  // 調Inner用這個
                                                  // .tickSizeOuter(30);  調Outer用這個

  // 建立<g>元素並呼叫軸線產生方式，生成軸線
  d3.select("#axisTickSizeIO2Test svg")
    .append("g")
    .call(axisTickSizeIO2TestAxisGeneratorInner)
    .attr("transform", \`translate(0, \${ height / 2 })\`)
<\/script>`,jsCode:null,vueCode:`<template>
  <svg
    ref="axisTickSizeIO2TestSvgRef"
    :width="width"
    :height="height"
    style="border: 1px solid lightgray;"
  ></svg>
</template>

<script setup>
import { ref, onMounted } from "vue";
import * as d3 from "d3";

// 圖表尺寸與內邊距設定
const width = 300;
const height = 200;
const margin = ( width - height ) / 2;

const axisTickSizeIO2TestSvgRef = ref(null);

onMounted(() => {
  // 設定比例尺
  const axisTickSizeIO2TestScale = d3.scaleLinear()
                                     .domain([0, 100])
                                     .range([margin, width - margin]);

  // 設定軸線產生方式
  const axisTickSizeIO2TestAxisGeneratorInner = d3.axisBottom(axisTickSizeIO2TestScale)
                                                  .tickSizeInner(30);  // 調Inner用這個
                                                  // .tickSizeOuter(30);  調Outer用這個

  // 建立<g>元素並呼叫軸線產生方式，生成軸線
  d3.select(axisTickSizeIO2TestSvgRef.value)
    .append("g")
    .call(axisTickSizeIO2TestAxisGeneratorInner)
    .attr("transform", \`translate(0, \${ height / 2 })\`)
});
<\/script>

<style scoped></style>`}},{detailTitle:"<code>axis.tickPadding()</code> 調整刻度線段與文字標籤的距離",detailSubtitle:"刻度線段與文字標籤的距離預設為 3。",detailComponent:t(()=>e(()=>import("./D3jsAxisTickPaddingTestDemo-D6ji7rLc.js"),__vite__mapDeps([51,1,22,23,24,25,26,27,2,3,29,4]))),detailCode:{htmlCode:`<div id="axisTickPaddingTest"></div>

<script>
  // 設定width、height、margin
  const width = 300;
  const height = 200;
  const margin = ( width - height ) / 2;

  // 建立繪製圖表的<svg>
  d3.select("#axisTickPaddingTest")
    .append("svg")
    .attr("width", width)
    .attr("height", height)
    .style("border", "1px solid lightgray");

  // 設定比例尺
  const axisTickPaddingTestScale = d3.scaleLinear()
                                     .domain([0, 100])
                                     .range([margin, width - margin]);

  // 設定軸線產生方式
  const axisTickPaddingTestAxisGenerator = d3.axisBottom(axisTickPaddingTestScale)
                                             .tickPadding(30);

  // 建立<g>元素並呼叫軸線產生方式，生成軸線
  d3.select("#axisTickPaddingTest svg")
    .append("g")
    .call(axisTickPaddingTestAxisGenerator)
    .attr("transform", \`translate(0, \${ height / 2 })\`);
<\/script>`,jsCode:null,vueCode:`<template>
  <svg
    ref="axisTickPaddingTestSvgRef"
    :width="width"
    :height="height"
    style="border: 1px solid lightgray;"
  ></svg>
</template>

<script setup>
import { ref, onMounted } from "vue";
import * as d3 from "d3";

// 圖表尺寸與內邊距設定
const width = 300;
const height = 200;
const margin = ( width - height ) / 2;

const axisTickPaddingTestSvgRef = ref(null);

onMounted(() => {
  // 設定比例尺
  const axisTickPaddingTestScale = d3.scaleLinear()
                                     .domain([0, 100])
                                     .range([margin, width - margin]);

  // 設定軸線產生方式
  const axisTickPaddingTestAxisGenerator = d3.axisBottom(axisTickPaddingTestScale)
                                             .tickPadding(30);

  // 建立<g>元素並呼叫軸線產生方式，生成軸線
  d3.select(axisTickPaddingTestSvgRef.value)
    .append("g")
    .call(axisTickPaddingTestAxisGenerator)
    .attr("transform", \`translate(0, \${ height / 2 })\`);
});
<\/script>

<style scoped></style>`}},{detailTitle:"建立 x、y 軸",detailSubtitle:null,detailComponent:t(()=>e(()=>import("./D3jsXYAxesDemo-BfueNQnj.js"),__vite__mapDeps([52,1,22,23,24,25,26,27,28,2,3,29,4]))),detailCode:{htmlCode:`<div id="xyAxes"></div>

<script>
  // 設定width、height、margin
  const width = 300;
  const height = 200;
  const margin = ( width - height ) / 2;

  // 給定的數據
  const xyAxesData = [{x: 100, y: 20}, {x: 18, y: 30}, {x: 90, y: 250}];

  // 建立繪製圖表的<svg>
  const xyAxesSVG = d3.select("#xyAxes")
                      .append("svg")
                      .attr("width", width)
                      .attr("height", height)
                      .style("border", "1px solid lightgray");

  // 抓出x軸、y軸需要用到的資料
  const xyAxesXData = xyAxesData.map((d) => d.x);
  const xyAxesYData = xyAxesData.map((d) => d.y);

  // x比例尺與軸線
  const xyAxesXScale = d3.scaleLinear()
                         .domain([0, d3.max(xyAxesXData)])
                         .range([margin, width - margin])
                         .nice();
  const xyAxesXAxisGenerator = d3.axisBottom(xyAxesXScale)
                                 .ticks(10);  // 調整數量，讓間距看起來跟y軸差不多

  // y比例尺與軸線
  const xyAxesYScale = d3.scaleLinear()
                         .domain([0, d3.max(xyAxesYData)])
                         .range([height - margin * 2, 0])
                         .nice();
  const xyAxesYAxisGenerator = d3.axisLeft(xyAxesYScale)
                                 .ticks(5)  // 調整數量，讓間距看起來跟x軸差不多
                                 .tickSizeOuter(0);  // 消除非整數倍的刻度線段

  // 建立<g>元素並呼叫軸線產生方式，分別生成x與y軸線
  xyAxesSVG.append("g")
           .call(xyAxesXAxisGenerator)
           .attr("transform", \`translate(0, \${ height - margin })\`);

  xyAxesSVG.append("g")
           .call(xyAxesYAxisGenerator)
           .attr("transform", \`translate(\${margin}, \${margin})\`);
<\/script>`,jsCode:null,vueCode:`<template>
  <svg
    ref="xyAxesSvgRef"
    :width="width"
    :height="height"
    style="border: 1px solid lightgray;"
  ></svg>
</template>

<script setup>
import { ref, onMounted } from "vue";
import * as d3 from "d3";

// 圖表尺寸與內邊距設定
const width = 300;
const height = 200;
const margin = ( width - height ) / 2;

const xyAxesSvgRef = ref(null);

// 給定的數據
const data = [
  {x: 100, y: 20},
  {x: 18, y: 30},
  {x: 90, y: 250}
];

// 抓出x軸、y軸需要用到的資料
const xData = data.map((d) => d.x);
const yData = data.map((d) => d.y);

onMounted(() => {
  // x比例尺與軸線
  const xScale = d3.scaleLinear()
                   .domain([0, d3.max(xData)])
                   .range([margin, width - margin])
                   .nice();
  const xAxisGenerator = d3.axisBottom(xScale)
                           .ticks(10);  // 調整數量，讓間距看起來跟y軸差不多

  // y比例尺與軸線
  const yScale = d3.scaleLinear()
                   .domain([0, d3.max(yData)])
                   .range([height - margin * 2, 0])
                   .nice();
  const yAxisGenerator = d3.axisLeft(yScale)
                           .ticks(5)  // 調整數量，讓間距看起來跟x軸差不多
                           .tickSizeOuter(0);  // 消除非整數倍的刻度線段

  // 建立<g>元素並呼叫軸線產生方式，分別生成x與y軸線
  d3.select(xyAxesSvgRef.value)
    .append("g")
    .call(xAxisGenerator)
    .attr("transform", \`translate(0, \${ height - margin })\`);

  d3.select(xyAxesSvgRef.value)
    .append("g")
    .call(yAxisGenerator)
    .attr("transform", \`translate(\${margin}, \${margin})\`);
});
<\/script>

<style scoped></style>`}},{detailTitle:"建立棋盤軸線樣式的 x、y 軸",detailSubtitle:null,detailComponent:t(()=>e(()=>import("./D3jsXYAxesCheckerBoardStyleDemo-BsF00Lq-.js"),__vite__mapDeps([53,1,22,23,24,25,26,27,28,2,3,29,4]))),detailCode:{htmlCode:`<div id="xyAxesCheckerboardStyle"></div>

<script>
  // 設定width、height、margin
  const width = 300;
  const height = 200;
  const margin = ( width - height ) / 2;

  // 給定的數據
  const xyAxesCheckerboardStyleData = [{x: 100, y: 20}, {x: 18, y: 30}, {x: 90, y: 95}];

  // 建立繪製圖表的<svg>
  const xyAxesCheckerboardStyleSVG = d3.select("#xyAxesCheckerboardStyle")
                                       .append("svg")
                                       .attr("width", width)
                                       .attr("height", height)
                                       .style("border", "1px solid lightgray");

  // 抓出x軸、y軸需要用到的資料
  const xyAxesCheckerboardStyleXData = xyAxesCheckerboardStyleData.map((d) => d.x);
  const xyAxesCheckerboardStyleYData = xyAxesCheckerboardStyleData.map((d) => d.y);

  // x比例尺與軸線
  const xyAxesCheckerboardStyleXScale = d3.scaleLinear()
                                          .domain([0, d3.max(xyAxesCheckerboardStyleXData)])
                                          .range([margin, width - margin])
                                          .nice();
  const xyAxesCheckerboardStyleXAxisGenerator = d3.axisBottom(xyAxesCheckerboardStyleXScale)
                                                  .tickSize( -height + margin * 2 )  // y軸線長度
                                                  .tickPadding(7);  // 讓標籤文字跟軸線保持一段距離

  // y比例尺與軸線
  const xyAxesCheckerboardStyleYScale = d3.scaleLinear()
                                          .domain([0, d3.max(xyAxesCheckerboardStyleYData)])
                                          .range([height - margin * 2, 0])
                                          .nice();
  const xyAxesCheckerboardStyleYAxisGenerator = d3.axisLeft(xyAxesCheckerboardStyleYScale)
                                                  .tickSize( -width + margin * 2 )  // x軸線長度
                                                  .tickPadding(7);  // 讓標籤文字跟軸線保持一段距離

  // 建立<g>元素並呼叫軸線產生方式，分別生成x與y軸線
  xyAxesCheckerboardStyleSVG.append("g")
                            .call(xyAxesCheckerboardStyleXAxisGenerator)
                            .attr("transform", \`translate(0, \${ height - margin })\`);

  xyAxesCheckerboardStyleSVG.append("g")
                            .call(xyAxesCheckerboardStyleYAxisGenerator)
                            .attr("transform", \`translate(\${margin}, \${margin})\`);
<\/script>`,jsCode:null,vueCode:`<template>
  <svg
    ref="xyAxesCheckerBoardStyleSvgRef"
    :width="width"
    :height="height"
    style="border: 1px solid lightgray;"
  ></svg>
</template>

<script setup>
import { ref, onMounted } from "vue";
import * as d3 from "d3";

// 圖表尺寸與內邊距設定
const width = 300;
const height = 200;
const margin = ( width - height ) / 2;

const xyAxesCheckerBoardStyleSvgRef = ref(null);

// 給定的數據
const data = [
  {x: 100, y: 20},
  {x: 18, y: 30},
  {x: 90, y: 95}
];

// 抓出x軸、y軸需要用到的資料
const xData = data.map((d) => d.x);
const yData = data.map((d) => d.y);

onMounted(() => {
  // x比例尺與軸線
  const xScale = d3.scaleLinear()
                   .domain([0, d3.max(xData)])
                   .range([margin, width - margin])
                   .nice();
  const xAxisGenerator = d3.axisBottom(xScale)
                           .tickSize( -height + margin * 2 )  // y軸線長度
                           .tickPadding(7);  // 讓標籤文字跟軸線保持一段距離

  // y比例尺與軸線
  const yScale = d3.scaleLinear()
                   .domain([0, d3.max(yData)])
                   .range([height - margin * 2, 0])
                   .nice();
  const yAxisGenerator = d3.axisLeft(yScale)
                           .tickSize( -width + margin * 2 )  // x軸線長度
                           .tickPadding(7);  // 讓標籤文字跟軸線保持一段距離

  // 建立<g>元素並呼叫軸線產生方式，分別生成x與y軸線
  d3.select(xyAxesCheckerBoardStyleSvgRef.value)
    .append("g")
    .call(xAxisGenerator)
    .attr("transform", \`translate(0, \${ height - margin })\`);

  d3.select(xyAxesCheckerBoardStyleSvgRef.value)
    .append("g")
    .call(yAxisGenerator)
    .attr("transform", \`translate(\${margin}, \${margin})\`);
});
<\/script>

<style scoped></style>`}},{detailTitle:"建立井字軸線樣式的 x、y 軸",detailSubtitle:null,detailComponent:t(()=>e(()=>import("./D3jsXYAxesHashtagStyleDemo-BNJJUnFu.js"),__vite__mapDeps([54,1,22,23,24,25,26,27,28,2,3,29,4]))),detailCode:{htmlCode:`<div id="xyAxesHashtagStyle"></div>

<script>
  // 設定width、height、margin
  const width = 300;
  const height = 200;
  const margin = ( width - height ) / 2;

  // 給定的數據
  const xyAxesHashtagStyleData = [{x: 100, y: 20}, {x: 18, y: 30}, {x: 90, y: 95}];

  // 建立繪製圖表的<svg>
  const xyAxesHashtagStyleSVG = d3.select("#xyAxesHashtagStyle")
                                  .append("svg")
                                  .attr("width", width)
                                  .attr("height", height)
                                  .style("border", "1px solid lightgray");

  // 抓出x軸、y軸需要用到的資料
  const xyAxesHashtagStyleXData = xyAxesHashtagStyleData.map((d) => d.x);
  const xyAxesHashtagStyleYData = xyAxesHashtagStyleData.map((d) => d.y);

  // x比例尺與軸線
  const xyAxesHashtagStyleXScale = d3.scaleLinear()
                                     .domain([0, d3.max(xyAxesHashtagStyleXData)])
                                     .range([margin, width - margin])
                                     .nice();
  const xyAxesHashtagStyleXAxisGenerator = d3.axisBottom(xyAxesHashtagStyleXScale)
                                             .tickSize( -height + margin )  // y軸線長度
                                             .tickSizeOuter(0)
                                             .tickPadding( margin / 2 + 7 );  // 讓標籤文字跟軸線保持一段距離

  // y比例尺與軸線
  const xyAxesHashtagStyleYScale = d3.scaleLinear()
                                     .domain([0, d3.max(xyAxesHashtagStyleYData)])
                                     .range([height - margin * 2, 0])
                                     .nice();
  const xyAxesHashtagStyleYAxisGenerator = d3.axisLeft(xyAxesHashtagStyleYScale)
                                             .tickSize( -width + margin )  // x軸線長度
                                             .tickSizeOuter(0)
                                             .tickPadding( margin - 20 );  // 讓標籤文字跟軸線保持一段距離

  // 建立<g>元素並呼叫軸線產生方式，分別生成x與y軸線
  xyAxesHashtagStyleSVG.append("g")
                       .attr("id", "xyAxesHashtagStyleXAxis")
                       .call(xyAxesHashtagStyleXAxisGenerator)
                       .attr("transform", \`translate(0, \${ height - margin })\`)
                       .selectAll("#xyAxesHashtagStyleXAxis line")
                       .attr("transform", \`translate(0, \${ margin / 2 })\`);

  xyAxesHashtagStyleSVG.append("g")
                       .attr("id", "xyAxesHashtagStyleYAxis")
                       .call(xyAxesHashtagStyleYAxisGenerator)
                       .attr("transform", \`translate(\${margin}, \${margin})\`)
                       .selectAll("#xyAxesHashtagStyleYAxis line")
                       .attr("transform", \`translate(\${ -margin / 2 }, 0)\`);
<\/script>`,jsCode:null,vueCode:`<template>
  <svg
    ref="xyAxesHashtagStyleSvgRef"
    :width="width"
    :height="height"
    style="border: 1px solid lightgray;"
  ></svg>
</template>

<script setup>
import { ref, onMounted } from "vue";
import * as d3 from "d3";

// 圖表尺寸與內邊距設定
const width = 300;
const height = 200;
const margin = ( width - height ) / 2;

const xyAxesHashtagStyleSvgRef = ref(null);

// 給定的數據
const data = [
  {x: 100, y: 20},
  {x: 18, y: 30},
  {x: 90, y: 95}
];

// 抓出x軸、y軸需要用到的資料
const xData = data.map((d) => d.x);
const yData = data.map((d) => d.y);

onMounted(() => {
  // x比例尺與軸線
  const xScale = d3.scaleLinear()
                   .domain([0, d3.max(xData)])
                   .range([margin, width - margin])
                   .nice();
  const xAxisGenerator = d3.axisBottom(xScale)
                           .tickSize( -height + margin )  // y軸線長度
                           .tickSizeOuter(0)
                           .tickPadding( margin / 2 + 7 );  // 讓標籤文字跟軸線保持一段距離

  // y比例尺與軸線
  const yScale = d3.scaleLinear()
                   .domain([0, d3.max(yData)])
                   .range([height - margin * 2, 0])
                   .nice();
  const yAxisGenerator = d3.axisLeft(yScale)
                           .tickSize( -width + margin )  // x軸線長度
                           .tickSizeOuter(0)
                           .tickPadding( margin - 20 );  // 讓標籤文字跟軸線保持一段距離

  // 建立<g>元素並呼叫軸線產生方式，分別生成x與y軸線
  d3.select(xyAxesHashtagStyleSvgRef.value)
    .append("g")
    .call(xAxisGenerator)
    .attr("transform", \`translate(0, \${ height - margin })\`)
    .selectAll("line")
    .attr("transform", \`translate(0, \${ margin / 2 })\`);

  d3.select(xyAxesHashtagStyleSvgRef.value)
    .append("g")
    .call(yAxisGenerator)
    .attr("transform", \`translate(\${margin}, \${margin})\`)
    .selectAll("line")
    .attr("transform", \`translate(\${ -margin / 2 }, 0)\`);
});
<\/script>

<style scoped></style>`}},{detailTitle:"建立 Grid 軸線樣式的 x、y 軸",detailSubtitle:null,detailComponent:t(()=>e(()=>import("./D3jsXYAxesGridStyleDemo-Dw3rnPQs.js"),__vite__mapDeps([55,1,22,23,24,25,26,27,28,2,3,4,29]))),detailCode:{htmlCode:`<div id="xyAxesGridStyle"></div>

<script>
  // 設定width、height、margin
  const width = 300;
  const height = 200;
  const margin = ( width - height ) / 2;

  // 給定的數據
  const xyAxesGridStyleData = [{x: 100, y: 20}, {x: 18, y: 30}, {x: 105, y: 250}];

  // 建立繪製圖表的<svg>
  const xyAxesGridStyleSVG = d3.select("#xyAxesGridStyle")
                               .append("svg")
                               .attr("width", width)
                               .attr("height", height)
                               .style("border", "1px solid lightgray");

  // 抓出x軸、y軸需要用到的資料
  const xyAxesGridStyleXData = xyAxesGridStyleData.map((d) => d.x);
  const xyAxesGridStyleYData = xyAxesGridStyleData.map((d) => d.y);

  // x比例尺與軸線
  const xyAxesGridStyleXScale = d3.scaleLinear()
                                  .domain([0, d3.max(xyAxesGridStyleXData)])
                                  .range([margin, width - margin]);
                                  // .nice();  // 加不加'.nice()'看情況
  const xyAxesGridStyleXAxisGenerator = d3.axisBottom(xyAxesGridStyleXScale)
                                          .ticks(10)  // 調整數量，讓間距看起來跟y軸差不多
                                          .tickSizeOuter(0);  // 消除非整數倍的刻度線段

  // y比例尺與軸線
  const xyAxesGridStyleYScale = d3.scaleLinear()
                                  .domain([0, d3.max(xyAxesGridStyleYData)])
                                  .range([height - margin * 2, 0])
                                  .nice();  // 加不加'.nice()'看情況
  const xyAxesGridStyleYAxisGenerator = d3.axisLeft(xyAxesGridStyleYScale)
                                          .ticks(5)  // 調整數量，讓間距看起來跟x軸差不多
                                          .tickSizeOuter(0);  // 消除非整數倍的刻度線段

  // 建立<g>元素並呼叫軸線產生方式，分別生成x與y軸線
  xyAxesGridStyleSVG.append("g")
                    .attr("id", "xyAxesGridStyleXAxis")  // 增加id，方便之後選擇而用以增添不同色軸線
                    .call(xyAxesGridStyleXAxisGenerator)
                    .attr("transform", \`translate(0, \${ height - margin })\`);

  xyAxesGridStyleSVG.append("g")
                    .attr("id", "xyAxesGridStyleYAxis")  // 增加id，方便之後選擇而用以增添不同色軸線
                    .call(xyAxesGridStyleYAxisGenerator)
                    .attr("transform", \`translate(\${margin}, \${margin})\`);

  // 繪製x軸向上的不同色軸線
  xyAxesGridStyleSVG.selectAll("#xyAxesGridStyleXAxis .tick")  // '.tick'為預設的class名稱
                    .append("line")
                    .attr("x1", 0)
                    .attr("x2", 0)
                    .attr("y1", 0)
                    .attr("y2", -height + margin * 2 )
                    .attr("stroke", "#e4e4e4");

  // 繪製y軸向右的不同色軸線
  xyAxesGridStyleSVG.selectAll("#xyAxesGridStyleYAxis .tick")  // '.tick'為預設的class名稱
                    .filter((d, i) => i !== 0)  // 不繪製第一條與x軸重疊的y軸線
                    .append("line")
                    .attr("x1", 0)
                    .attr("x2", width - margin * 2)
                    .attr("y1", 0)
                    .attr("y2", 0)
                    .attr("stroke", "#e4e4e4");
<\/script>`,jsCode:null,vueCode:`<template>
  <svg
    ref="xyAxesGridStyleSvgRef"
    :width="width"
    :height="height"
    style="border: 1px solid lightgray;"
  ></svg>
</template>

<script setup>
import { ref, onMounted } from "vue";
import * as d3 from "d3";

// 圖表尺寸與內邊距設定
const width = 300;
const height = 200;
const margin = ( width - height ) / 2;

const xyAxesGridStyleSvgRef = ref(null);

// 給定的數據
const data = [
  {x: 100, y: 20},
  {x: 18, y: 30},
  {x: 105, y: 250}
];

// 抓出x軸、y軸需要用到的資料
const xData = data.map((d) => d.x);
const yData = data.map((d) => d.y);

onMounted(() => {
  const svg = d3.select(xyAxesGridStyleSvgRef.value);

  // x比例尺與軸線
  const xScale = d3.scaleLinear()
                   .domain([0, d3.max(xData)])
                   .range([margin, width - margin]);
                   // .nice();  // 加不加'.nice()'看情況

  const xAxisGenerator = d3.axisBottom(xScale)
                           .ticks(10)  // 調整數量，讓間距看起來跟y軸差不多
                           .tickSizeOuter(0);  // 消除非整數倍的刻度線段

  // y比例尺與軸線
  const yScale = d3.scaleLinear()
                   .domain([0, d3.max(yData)])
                   .range([height - margin * 2, 0])
                   .nice();  // 加不加'.nice()'看情況

  const yAxisGenerator = d3.axisLeft(yScale)
                           .ticks(5)  // 調整數量，讓間距看起來跟x軸差不多
                           .tickSizeOuter(0);  // 消除非整數倍的刻度線段

  // 建立<g>元素並呼叫軸線產生方式，先分別生成x與y軸線，再繪製x軸向上與y軸向右的不同色軸線
  svg.append("g")
     .call(xAxisGenerator)
     .attr("transform", \`translate(0, \${ height - margin })\`)
     .selectAll(".tick")  // '.tick'為預設的class名稱
     .append("line")
     .attr("x1", 0)
     .attr("x2", 0)
     .attr("y1", 0)
     .attr("y2", -height + margin * 2 )
     .attr("stroke", "#e4e4e4");

  svg.append("g")
     .call(yAxisGenerator)
     .attr("transform", \`translate(\${margin}, \${margin})\`)
     .selectAll(".tick")  // '.tick'為預設的class名稱
     .filter((d, i) => i !== 0)  // 不繪製第一條與x軸重疊的y軸線
     .append("line")
     .attr("x1", 0)
     .attr("x2", width - margin * 2)
     .attr("y1", 0)
     .attr("y2", 0)
     .attr("stroke", "#e4e4e4");
});
<\/script>

<style scoped></style>`}},{detailTitle:"文字標籤旋轉",detailSubtitle:null,detailComponent:t(()=>e(()=>import("./D3jsXYAxesTickTextRotationDemo-6Qfzpj-y.js"),__vite__mapDeps([56,1,41,23,24,25,26,22,27,28,2,3,4,29]))),detailCode:{htmlCode:`<div id="xyAxesTickTextRotation"></div>

<script>
  // 設定width、height、margin
  const width = 300;
  const height = 200;
  const margin = ( width - height ) / 2;

  // 給定的數據
  const xyAxesTickTextRotationData = [
    {x: new Date(2024, 0), y: 30},
    {x: new Date(2024, 2), y: 80},
    {x: new Date(2024, 8), y: 90},
    {x: new Date(2024, 11), y: 20},
  ];

  // 建立繪製圖表的<svg>
  const xyAxesTickTextRotationSVG = d3.select("#xyAxesTickTextRotation")
                                      .append("svg")
                                      .attr("width", width)
                                      .attr("height", height)
                                      .style("border", "1px solid lightgray");

  // 抓出x軸、y軸需要用到的資料
  const xyAxesTickTextRotationXData = xyAxesTickTextRotationData.map((d) => d.x);
  const xyAxesTickTextRotationYData = xyAxesTickTextRotationData.map((d) => d.y);

  // x比例尺與軸線
  const xyAxesTickTextRotationXScale = d3.scaleTime()
                                         .domain([new Date(2024, 0), new Date(2024, 11)])
                                         .range([margin, width - margin]);
  const xyAxesTickTextRotationXAxisGenerator = d3.axisBottom(xyAxesTickTextRotationXScale)
                                                 .tickFormat(d3.timeFormat("%Y-%m-%d"))
                                                 .tickSize(10);  // 延長刻度線，方便判讀

  // y比例尺與軸線
  const xyAxesTickTextRotationYScale = d3.scaleLinear()
                                         .domain([0, d3.max(xyAxesTickTextRotationYData)])
                                         .range([height - margin * 2, 0]);
  const xyAxesTickTextRotationYAxisGenerator = d3.axisLeft(xyAxesTickTextRotationYScale)
                                                 .ticks(5)
                                                 .tickSize(10)  // 延長刻度線，方便判讀
                                                 .tickSizeOuter(0);  // 消除非整數倍的刻度線段                          

  // 建立<g>元素並呼叫軸線產生方式，分別生成x與y軸線
  xyAxesTickTextRotationSVG.append("g")
                           .attr("id", "xyAxesTickTextRotationXAxis")  // 增加id，方便之後選擇而用以增添不同色軸線
                           .call(xyAxesTickTextRotationXAxisGenerator)
                           .attr("transform", \`translate(0, \${ height - margin - 15})\`);

  xyAxesTickTextRotationSVG.append("g")
                           .call(xyAxesTickTextRotationYAxisGenerator)
                           .attr("transform", \`translate(\${margin}, \${margin - 15})\`);

  // 旋轉x軸上的文字標籤
  xyAxesTickTextRotationSVG.selectAll("#xyAxesTickTextRotationXAxis text")  // '.tick'為預設的class名稱
                           .attr("transform", "translate(-27, 22) rotate(-45)");
<\/script>`,jsCode:null,vueCode:`<template>
  <svg
    ref="xyAxesTickTextRotationSvgRef"
    :width="width"
    :height="height"
    style="border: 1px solid lightgray;"
  ></svg>
</template>

<script setup>
import { ref, onMounted } from "vue";
import * as d3 from "d3";

// 圖表尺寸與內邊距設定
const width = 300;
const height = 200;
const margin = ( width - height ) / 2;

const xyAxesTickTextRotationSvgRef = ref(null);

// 給定的數據
const data = [
  {x: new Date(2024, 0), y: 30},
  {x: new Date(2024, 2), y: 80},
  {x: new Date(2024, 8), y: 90},
  {x: new Date(2024, 11), y: 20},
];

// 抓出x軸、y軸需要用到的資料
const xData = data.map((d) => d.x);
const yData = data.map((d) => d.y);

onMounted(() => {
  const svg = d3.select(xyAxesTickTextRotationSvgRef.value);

  // x比例尺與軸線
  const xScale = d3.scaleTime()
                   .domain([new Date(2024, 0), new Date(2024, 11)])
                   .range([margin, width - margin]);
  const xAxisGenerator = d3.axisBottom(xScale)
                           .tickFormat(d3.timeFormat("%Y-%m-%d"))
                           .tickSize(10);  // 延長刻度線，方便判讀

  // y比例尺與軸線
  const yScale = d3.scaleLinear()
                   .domain([0, d3.max(yData)])
                   .range([height - margin * 2, 0]);
  const yAxisGenerator = d3.axisLeft(yScale)
                           .ticks(5)
                           .tickSize(10)  // 延長刻度線，方便判讀
                           .tickSizeOuter(0);  // 消除非整數倍的刻度線段                          

  // 建立<g>元素並呼叫軸線產生方式，分別生成x與y軸線
  svg.append("g")
     .call(xAxisGenerator)
     .attr("transform", \`translate(0, \${ height - margin - 15})\`)
     .selectAll("text")  // '.tick'為預設的class名稱
     .attr("transform", "translate(-27, 22) rotate(-45)");  // 旋轉x軸上的文字標籤

  svg.append("g")
     .call(yAxisGenerator)
     .attr("transform", \`translate(\${margin}, \${margin - 15})\`);
});
<\/script>

<style scoped></style>`}},{detailTitle:"時鐘刻度軸線",detailSubtitle:null,detailComponent:t(()=>e(()=>import("./D3jsClockAxisDemo-BlHgpfrW.js"),__vite__mapDeps([57,1,22,23,24,25,26,27,45,2,3,4]))),detailCode:{htmlCode:`<div id="clockAxisTest"></div>

<script>
  // 設定繪製圖表的<svg>大小，並建立之
  const height = 300;
  const width = height;
  const SVG = d3.select("#clockAxisTest")
                .append("svg")
                .attr("width", width)
                .attr("height", height)
                .style("border", "1px solid lightgray");

  // 設定變數
  const clockRadius = height / 3;  // 時鐘半徑，設定為<svg>高度的三分之一
  const minuteTickInnerRadius = clockRadius - 10;  // 分鐘刻度線長度，設定為10
  const hourTickInnerRadius = clockRadius - 17;  // 小時刻度線長度，設定為17
  const degToRad = Math.PI / 180;  // 弧度，將度數轉換為弧度
  const minuteLabelRadius = clockRadius + 15;  // 分鐘文字標籤半徑，設定為時鐘半徑+15
  const minuteLabelYOffset = 5;  // 分鐘文字標籤Y方向的偏移量（y位置為文字基線，需再修正），避免標籤與刻度線重疊
  const hourLabelRadius = clockRadius - 35;  // 小時文字標籤半徑，設定為時鐘半徑-15
  const hourLabelYOffset = 6;  // 小時文字標籤Y方向上的偏移量（y位置為文字基線，需再修正）

  // 設定小時刻度比例尺和分鐘刻度比例尺
  // 小時比例尺（12小時映射到360度）
  const hourScale = d3.scaleLinear()
                      .domain([0, 12])
                      .range([0, 360]);
  // 分鐘比例尺（60分鐘映射到360度）
  const minuteScale = d3.scaleLinear()
                        .domain([0, 60])
                        .range([0, 360]);

  // 建立<g>，起始點移動到<svg>中心
  const G = SVG.append("g")
               .attr("transform", \`translate(\${[Math.round( width / 2 ), Math.round( height / 2 )]})\`);

  // 分鐘刻度
  G.selectAll(".minuteTicks")
   .data(d3.range(0, 60))  // 建立0到59的數列
   .enter()
   .append("line")
   .attr("class", "minuteTicks")
   .attr("x1", "0")
   .attr("x2", "0")
   .attr("y1", clockRadius)
   .attr("y2", minuteTickInnerRadius)
   .attr("stroke-width", "3")
   .attr("stroke", "black")
   .attr("transform", (d) => \`rotate(\${minuteScale(d)})\`);

  // 分鐘數字標籤
  G.selectAll(".minuteLabels")
   .data(d3.range(5, 61, 5))  // 5到60，間隔5
   .enter()
   .append("text")
   .attr("class", "minuteLabels")
   .attr("x", (d) => minuteLabelRadius * Math.sin(minuteScale(d) * degToRad))  // 標籤的半徑乘以sin(比例尺承弧度)
   .attr("y", (d) => -minuteLabelRadius * Math.cos(minuteScale(d) * degToRad) + minuteLabelYOffset)  // 標籤的半徑乘以cos(比例尺承弧度)
   .text((d) => d)
   .attr("text-anchor", "middle")
   .attr("font-size", "14")
   .style("fill", "#a0a0a0");

  // 時鐘刻度
  G.selectAll(".hourTicks")
   .data(d3.range(0, 12))  // 建立0到11的數列
   .enter()
   .append("line")
   .attr("class", "hourTicks")
   .attr("x1", "0")
   .attr("x2", "0")
   .attr("y1", clockRadius)
   .attr("y2", hourTickInnerRadius)
   .attr("stroke-width", "5")
   .attr("stroke", "black")
   .attr("transform", (d) => \`rotate(\${hourScale(d)})\`);

  // 時鐘數字標籤
  G.selectAll(".hourLabels")
   .data(d3.range(3, 13, 3))  // 3到12，間隔3
   .enter()
   .append("text")
   .attr("class", "hourLabels")
   .attr("x", (d) => hourLabelRadius * Math.sin(hourScale(d) * degToRad))  // 標籤的半徑乘以sin(比例尺承弧度)
   .attr("y", (d) => -hourLabelRadius * Math.cos(hourScale(d) * degToRad) + hourLabelYOffset)  // 標籤的半徑乘以cos(比例尺承弧度)
   .text((d) => d)
   .attr("text-anchor", "middle")
   .style("font-weight", "bolder");
<\/script>`,jsCode:null,vueCode:`<template>
  <svg
    ref="clockAxisSvgRef"
    :width="width"
    :height="height"
    style="border: 1px solid lightgray;"
  ></svg>
</template>

<script setup>
import { ref, onMounted } from "vue";
import * as d3 from "d3";

// 圖表尺寸與內邊距設定
const width = 300;
const height = width;
// const margin = ( width - height ) / 2; 此例不用另外設定margin

const clockAxisSvgRef = ref(null);

onMounted(() => {
  const svg = d3.select(clockAxisSvgRef.value);

  // 設定變數
  const clockRadius = height / 3;  // 時鐘半徑，設定為<svg>高度的三分之一
  const minuteTickInnerRadius = clockRadius - 10;  // 分鐘刻度線長度，設定為10
  const hourTickInnerRadius = clockRadius - 17;  // 小時刻度線長度，設定為17
  const degToRad = Math.PI / 180;  // 弧度，將度數轉換為弧度
  const minuteLabelRadius = clockRadius + 15;  // 分鐘文字標籤半徑，設定為時鐘半徑+15
  const minuteLabelYOffset = 5;  // 分鐘文字標籤Y方向的偏移量（y位置為文字基線，需再修正），避免標籤與刻度線重疊
  const hourLabelRadius = clockRadius - 35;  // 小時文字標籤半徑，設定為時鐘半徑-15
  const hourLabelYOffset = 6;  // 小時文字標籤Y方向上的偏移量（y位置為文字基線，需再修正）

  // 設定小時刻度比例尺和分鐘刻度比例尺
  // 小時比例尺（12小時映射到360度）
  const hourScale = d3.scaleLinear()
                      .domain([0, 12])
                      .range([0, 360]);
  // 分鐘比例尺（60分鐘映射到360度）
  const minuteScale = d3.scaleLinear()
                        .domain([0, 60])
                        .range([0, 360]);

  // 建立<g>，起始點移動到<svg>中心
  const G = svg.append("g")
               .attr("transform", \`translate(\${[Math.round( width / 2 ), Math.round( height / 2 )]})\`);

  // 分鐘刻度
  G.selectAll(".minuteTicks")
   .data(d3.range(0, 60))  // 建立0到59的數列
   .join("line")
   .attr("class", "minuteTicks")
   .attr("x1", "0")
   .attr("x2", "0")
   .attr("y1", clockRadius)
   .attr("y2", minuteTickInnerRadius)
   .attr("stroke-width", "3")
   .attr("stroke", "black")
   .attr("transform", (d) => \`rotate(\${minuteScale(d)})\`);

  // 分鐘數字標籤
  G.selectAll(".minuteLabels")
   .data(d3.range(5, 61, 5))  // 5到60，間隔5
   .join("text")
   .attr("class", "minuteLabels")
   .attr("x", (d) => minuteLabelRadius * Math.sin(minuteScale(d) * degToRad))  // 標籤的半徑乘以sin(比例尺承弧度)
   .attr("y", (d) => -minuteLabelRadius * Math.cos(minuteScale(d) * degToRad) + minuteLabelYOffset)  // 標籤的半徑乘以cos(比例尺承弧度)
   .text((d) => d)
   .attr("text-anchor", "middle")
   .attr("font-size", "14")
   .style("fill", "#a0a0a0");

  // 時鐘刻度
  G.selectAll(".hourTicks")
   .data(d3.range(0, 12))  // 建立0到11的數列
   .join("line")
   .attr("class", "hourTicks")
   .attr("x1", "0")
   .attr("x2", "0")
   .attr("y1", clockRadius)
   .attr("y2", hourTickInnerRadius)
   .attr("stroke-width", "5")
   .attr("stroke", "black")
   .attr("transform", (d) => \`rotate(\${hourScale(d)})\`);

  // 時鐘數字標籤
  G.selectAll(".hourLabels")
   .data(d3.range(3, 13, 3))  // 3到12，間隔3
   .join("text")
   .attr("class", "hourLabels")
   .attr("x", (d) => hourLabelRadius * Math.sin(hourScale(d) * degToRad))  // 標籤的半徑乘以sin(比例尺承弧度)
   .attr("y", (d) => -hourLabelRadius * Math.cos(hourScale(d) * degToRad) + hourLabelYOffset)  // 標籤的半徑乘以cos(比例尺承弧度)
   .text((d) => d)
   .attr("text-anchor", "middle")
   .style("font-weight", "bolder");
});
<\/script>

<style scoped></style>`}},{detailTitle:"響應式圖表",detailSubtitle:"使用現有寬度來調整寬度大小（需重新整理）。當放置在 Bootstrap 標籤頁（Tabs）裡非首頁時，渲染可能會失敗。",detailComponent:t(()=>e(()=>import("./D3jsRWDAxisTestDemo-BhXEfb1V.js"),__vite__mapDeps([58,1,22,23,24,25,26,27,2,3,4,29]))),detailCode:{htmlCode:`<div id="RWDAxisTest"></div>

<script>
  // 設定width、height、margin
  const RWDAxisTestCurrentWidth = parseInt(d3.select("#RWDAxisTest").style("width"));
  const height = 300;
  const RWDAxisTestCurrentMargin = ( RWDAxisTestCurrentWidth - height ) / 2;

  // 建立繪製圖表的<svg>
  d3.select("#RWDAxisTest")
    .append("svg")
    .attr("width", RWDAxisTestCurrentWidth)
    .attr("height", height)
    .style("border", "1px solid rgb(96, 96, 96)");

  // 設定比例尺
  const RWDAxisTestScale = d3.scaleLinear()
                             .domain([0, 100])
                             .range([RWDAxisTestCurrentMargin, RWDAxisTestCurrentWidth - RWDAxisTestCurrentMargin]);

  // 設定軸線產生方式
  const RWDAxisTestGenerator = d3.axisBottom(RWDAxisTestScale);

  // 再建立<g>元素，並呼叫軸線產生方法，生成軸線
  d3.select("#RWDAxisTest svg")
    .append("g")
    .call(RWDAxisTestGenerator)
    .attr("transform", \`translate(0, \${ height / 2 })\`);
<\/script>`,jsCode:null,vueCode:`<!-- 本例僅在初次掛載時依容器寬度渲染，無監聽resize事件，視窗調整後不會自動更新 -->

<template>
  <svg
    ref="rwdAxisTestSvgRef"
    :width="rwdAxisTestCurrentWidth"
    :height="height"
    style="border: 1px solid lightgray;"
  ></svg>
</template>

<script setup>
import { ref, onMounted } from "vue";
import * as d3 from "d3";

const rwdAxisTestSvgRef = ref(null);

// 圖表尺寸與內邊距設定（初始化）
const rwdAxisTestCurrentWidth = ref("100%");
const height = 300;
const rwdAxisTestCurrentMargin = Math.abs((rwdAxisTestCurrentWidth.value - height) / 2);

onMounted(() => {
  // 圖表尺寸與內邊距設定（需掛載完成才計算）
  const rwdAxisTestCurrentWidth = parseInt(d3.select(rwdAxisTestSvgRef.value).style("width"));
  const height = 300;
  const rwdAxisTestCurrentMargin = rwdAxisTestCurrentWidth > height
    ? ( rwdAxisTestCurrentWidth - height ) / 2
    : ( height - rwdAxisTestCurrentWidth ) / 2;

  // 設定比例尺
  const xScale = d3.scaleLinear()
                   .domain([0, 100])
                   .range([rwdAxisTestCurrentMargin, rwdAxisTestCurrentWidth - rwdAxisTestCurrentMargin]);

  // 設定軸線產生方式
  const xAxisGenerator = d3.axisTop(xScale);

  // 再建立<g>元素，並呼叫軸線產生方法，生成軸線
  d3.select(rwdAxisTestSvgRef.value)
    .append("g")
    .call(xAxisGenerator)
    .attr("transform", \`translate(0, \${ height / 2 })\`);
});
<\/script>

<style scoped></style>`}}]}]},{id:"d3jsAnimationNote",title:"動畫",description:null,descriptionComponent:null,descriptionComponentStyle:null,lists:[{listTitle:"動畫（Transition）",listSubtitle:null,listComponent:null,listCode:{htmlCode:null,jsCode:null,vueCode:null},listDetails:[{detailTitle:"瞬間移動",detailSubtitle:null,detailComponent:t(()=>e(()=>import("./D3jsMoveDemo-BM6l3jTW.js"),__vite__mapDeps([59,1,2,3,4,60]))),detailCode:{htmlCode:`<svg id="move" class="mt-1" style="border: 1px solid rgb(103, 102, 102);"></svg><br>
<button id="moveBtn" class="btn btn-primary mt-2" type="button">移動</button>
<button id="moveBtnReset" class="btn btn-primary mt-2 ms-1" type="button">回復</button>

<script>
  const moveRect = d3.select("#move")
                     .append("rect")
                     .attr("width", 40)
                     .attr("height", 40)
                     .attr("fill", "#f68b47")
                     .attr("stroke", "#f68b47");
  
  document.querySelector("#moveBtn").addEventListener("click", () => {
    moveRect.attr("transform", "translate(140, 60)");
  });

  document.querySelector("#moveBtnReset").addEventListener("click", () => {
    moveRect.attr("transform", "translate(0, 0)");
  });
<\/script>`,jsCode:null,vueCode:`<template>
  <svg
    ref="moveSvgRef"
    :width="width"
    :height="height"
    style="border: 1px solid lightgray;"
  ></svg>
  <div class="btn-container">
    <button
      type="button"
      class="move-btn"
      @click="move"
    >
      移動
    </button>
    <button
      type="button"
      class="reset-btn"
      @click="reset"
    >
      回復
    </button>
  </div>
</template>

<script setup>
import { ref, onMounted } from "vue";
import * as d3 from "d3";

// 圖表尺寸與內邊距設定
const width = 300;
const height = 200;

const moveSvgRef = ref(null);
let moveRect = null;

onMounted(() => {
  moveRect = d3.select(moveSvgRef.value)
               .append("rect")
               .attr("width", 40)
               .attr("height", 40)
               .attr("fill", "#f68b47")
               .attr("stroke", "#f68b47");
});

const move = () => {
  moveRect.attr("transform", "translate(140, 60)");
};

const reset = () => {
  moveRect.attr("transform", "translate(0, 0)");
};
<\/script>

<style scoped>
.btn-container {
  display: flex;
  gap: 5px;
}

.move-btn {
  padding: 6px 12px 6px 12px;
  font-size: 16px;
  font-weight: 400;
  font-family: inherit;
  line-height: 1.5;
  color: #0d6efd;
  background-color: #ffffff;
  border: 1px solid #0d6efd;
  border-radius: 6px;
  cursor: pointer;
  transition:
    color 0.15s ease-in-out,
    background-color 0.15s ease-in-out,
    border-color 0.15s ease-in-out;
}

.move-btn:hover {
  color: #ffffff;
  background-color: #0d6efd;
  border-color: #0d6efd;
}

.reset-btn {
  padding: 6px 12px 6px 12px;
  font-size: 16px;
  font-weight: 400;
  font-family: inherit;
  line-height: 1.5;
  color: #dc3545;
  background-color: #ffffff;
  border: 1px solid #dc3545;
  border-radius: 6px;
  cursor: pointer;
  transition:
    color 0.15s ease-in-out,
    background-color 0.15s ease-in-out,
    border-color 0.15s ease-in-out;
}

.reset-btn:hover {
  color: #ffffff;
  background-color: #dc3545;
  border-color: #dc3545;
}
</style>`}},{detailTitle:"<code>selection.transition()</code> 平滑移動",detailSubtitle:null,detailComponent:t(()=>e(()=>import("./D3jsTransitionDemo-CPY-ZzLU.js"),__vite__mapDeps([61,1,2,3,4,62]))),detailCode:{htmlCode:`<svg id="transition" class="mt-1" style="border: 1px solid rgb(103, 102, 102);"></svg><br>
<button id="transitionBtn" class="btn btn-primary mt-2" type="button">移動</button>
<button id="transitionBtnReset" class="btn btn-primary mt-2 ms-1" type="button">回復</button>

<script>
  const transitionRect = d3.select("#transition")
                           .append("rect")
                           .attr("width", 40)
                           .attr("height", 40)
                           .attr("fill", "#f68b47")
                           .attr("stroke", "#f68b47");
  
  document.querySelector("#transitionBtn").addEventListener("click", () => {
    transitionRect.transition()  // 使用transition()
                  .attr("transform", "translate(140, 60)");
  });

  document.querySelector("#transitionBtnReset").addEventListener("click", () => {
    transitionRect.attr("transform", "translate(0, 0)");
  });
<\/script>`,jsCode:null,vueCode:`<template>
  <svg
    ref="transitionSvgRef"
    :width="width"
    :height="height"
    style="border: 1px solid lightgray;"
  ></svg>
  <div class="btn-container">
    <button
      type="button"
      class="move-btn"
      @click="move"
    >
      移動
    </button>
    <button
      type="button"
      class="reset-btn"
      @click="reset"
    >
      回復
    </button>
  </div>
</template>

<script setup>
import { ref, onMounted } from "vue";
import * as d3 from "d3";

// 圖表尺寸與內邊距設定
const width = 300;
const height = 200;

const transitionSvgRef = ref(null);
let transitionRect = null;

onMounted(() => {
  transitionRect = d3.select(transitionSvgRef.value)
                     .append("rect")
                     .attr("width", 40)
                     .attr("height", 40)
                     .attr("fill", "#f68b47")
                     .attr("stroke", "#f68b47");
});

const move = () => {
  transitionRect.transition()  // 使用transition()
                .attr("transform", "translate(140, 60)");
};

const reset = () => {
  transitionRect.transition()  // 使用transition()
                .attr("transform", "translate(0, 0)");
};
<\/script>

<style scoped>
.btn-container {
  display: flex;
  gap: 5px;
}

.move-btn {
  padding: 6px 12px 6px 12px;
  font-size: 16px;
  font-weight: 400;
  font-family: inherit;
  line-height: 1.5;
  color: #0d6efd;
  background-color: #ffffff;
  border: 1px solid #0d6efd;
  border-radius: 6px;
  cursor: pointer;
  transition:
    color 0.15s ease-in-out,
    background-color 0.15s ease-in-out,
    border-color 0.15s ease-in-out;
}

.move-btn:hover {
  color: #ffffff;
  background-color: #0d6efd;
  border-color: #0d6efd;
}

.reset-btn {
  padding: 6px 12px 6px 12px;
  font-size: 16px;
  font-weight: 400;
  font-family: inherit;
  line-height: 1.5;
  color: #dc3545;
  background-color: #ffffff;
  border: 1px solid #dc3545;
  border-radius: 6px;
  cursor: pointer;
  transition:
    color 0.15s ease-in-out,
    background-color 0.15s ease-in-out,
    border-color 0.15s ease-in-out;
}

.reset-btn:hover {
  color: #ffffff;
  background-color: #dc3545;
  border-color: #dc3545;
}
</style>`}},{detailTitle:"<code>transition.duration()</code> 設定持續時間",detailSubtitle:"單位：ms。",detailComponent:t(()=>e(()=>import("./D3jsTransitionDurationDemo-CX6KAJ-O.js"),__vite__mapDeps([63,1,2,3,4,64]))),detailCode:{htmlCode:`<svg id="transitionDuration" class="mt-1" style="border: 1px solid rgb(103, 102, 102);"></svg><br>
<button id="transitionDurationBtn" class="btn btn-primary mt-2" type="button">移動</button>
<button id="transitionDurationBtnReset" class="btn btn-primary mt-2 ms-1" type="button">回復</button>

<script>
  const transitionDurationRect = d3.select("#transitionDuration")
                                   .append("rect")
                                   .attr("width", 40)
                                   .attr("height", 40)
                                   .attr("fill", "#f68b47")
                                   .attr("stroke", "#f68b47");
  
  document.querySelector("#transitionDurationBtn").addEventListener("click", () => {
    transitionDurationRect.transition()
                          .duration(2000)  // 設定動畫時間持續2秒鐘
                          .attr("transform", "translate(140, 60)");
  });

  document.querySelector("#transitionDurationBtnReset").addEventListener("click", () => {
    transitionDurationRect.attr("transform", "translate(0, 0)");
  });
<\/script>`,jsCode:null,vueCode:`<template>
  <svg
    ref="transitionDurationSvgRef"
    :width="width"
    :height="height"
    style="border: 1px solid lightgray;"
  ></svg>
  <div class="btn-container">
    <button
      type="button"
      class="move-btn"
      @click="move"
    >
      移動
    </button>
    <button
      type="button"
      class="reset-btn"
      @click="reset"
    >
      回復
    </button>
  </div>
</template>

<script setup>
import { ref, onMounted } from "vue";
import * as d3 from "d3";

// 圖表尺寸與內邊距設定
const width = 300;
const height = 200;

const transitionDurationSvgRef = ref(null);
let transitionDurationRect = null;

onMounted(() => {
  transitionDurationRect = d3.select(transitionDurationSvgRef.value)
                             .append("rect")
                             .attr("width", 40)
                             .attr("height", 40)
                             .attr("fill", "#f68b47")
                             .attr("stroke", "#f68b47");
});

const move = () => {
  transitionDurationRect.transition()
                        .duration(2000)  // 設定動畫時間持續2秒鐘
                        .attr("transform", "translate(140, 60)");
};

const reset = () => {
  transitionDurationRect.transition()
                        .attr("transform", "translate(0, 0)");
};
<\/script>

<style scoped>
.btn-container {
  display: flex;
  gap: 5px;
}

.move-btn {
  padding: 6px 12px 6px 12px;
  font-size: 16px;
  font-weight: 400;
  font-family: inherit;
  line-height: 1.5;
  color: #0d6efd;
  background-color: #ffffff;
  border: 1px solid #0d6efd;
  border-radius: 6px;
  cursor: pointer;
  transition:
    color 0.15s ease-in-out,
    background-color 0.15s ease-in-out,
    border-color 0.15s ease-in-out;
}

.move-btn:hover {
  color: #ffffff;
  background-color: #0d6efd;
  border-color: #0d6efd;
}

.reset-btn {
  padding: 6px 12px 6px 12px;
  font-size: 16px;
  font-weight: 400;
  font-family: inherit;
  line-height: 1.5;
  color: #dc3545;
  background-color: #ffffff;
  border: 1px solid #dc3545;
  border-radius: 6px;
  cursor: pointer;
  transition:
    color 0.15s ease-in-out,
    background-color 0.15s ease-in-out,
    border-color 0.15s ease-in-out;
}

.reset-btn:hover {
  color: #ffffff;
  background-color: #dc3545;
  border-color: #dc3545;
}
</style>`}},{detailTitle:"逐漸改變顏色",detailSubtitle:null,detailComponent:t(()=>e(()=>import("./D3jsTransitionColorDemo-C0YHmJCH.js"),__vite__mapDeps([65,1,2,3,4,66]))),detailCode:{htmlCode:`<svg id="transitionColor" class="mt-1" style="border: 1px solid rgb(103, 102, 102);"></svg><br>
<button id="transitionColorBtn" class="btn btn-primary mt-2" type="button">變色</button>
<button id="transitionColorBtnReset" class="btn btn-primary mt-2 ms-1" type="button">回復</button>

<script>
  const transitionColorRect = d3.select("#transitionColor")
                                .append("rect")
                                .attr("width", 40)
                                .attr("height", 40)
                                .attr("fill", "#f68b47")
                                .attr("stroke", "#f68b47")
                                .attr("transform", "translate(140, 60)");
  
  document.querySelector("#transitionColorBtn").addEventListener("click", () => {
    transitionColorRect.transition()
                       .duration(1000)
                       .attr("fill", "green")
                       .attr("stroke-width", 6)
                       .attr("stroke", "red");
  });

  document.querySelector("#transitionColorBtnReset").addEventListener("click", () => {
    transitionColorRect.attr("fill", "#f68b47")
                       .attr("stroke-width", 1)
                       .attr("stroke", "#f68b47");
  });
<\/script>`,jsCode:null,vueCode:`<template>
  <svg
    ref="transitionColorSvgRef"
    :width="width"
    :height="height"
    style="border: 1px solid lightgray;"
  ></svg>
  <div class="btn-container">
    <button
      type="button"
      class="change-color-btn"
      @click="changeColor"
    >
      變色
    </button>
    <button
      type="button"
      class="reset-btn"
      @click="reset"
    >
      回復
    </button>
  </div>
</template>

<script setup>
import { ref, onMounted } from "vue";
import * as d3 from "d3";

// 圖表尺寸與內邊距設定
const width = 300;
const height = 200;

const transitionColorSvgRef = ref(null);
let transitionColorRect = null;

onMounted(() => {
  transitionColorRect = d3.select(transitionColorSvgRef.value)
                          .append("rect")
                          .attr("width", 40)
                          .attr("height", 40)
                          .attr("fill", "#f68b47")
                          .attr("stroke", "#f68b47")
                          .attr("transform", "translate(140, 60)");
});

const changeColor = () => {
  transitionColorRect.transition()
                     .duration(1000)
                     .attr("fill", "green")
                     .attr("stroke-width", 6)
                     .attr("stroke", "red");
};

const reset = () => {
  transitionColorRect.transition()
                     .attr("fill", "#f68b47")
                     .attr("stroke-width", 1)
                     .attr("stroke", "#f68b47");
};
<\/script>

<style scoped>
.btn-container {
  display: flex;
  gap: 5px;
}

.change-color-btn {
  padding: 6px 12px 6px 12px;
  font-size: 16px;
  font-weight: 400;
  font-family: inherit;
  line-height: 1.5;
  color: #0d6efd;
  background-color: #ffffff;
  border: 1px solid #0d6efd;
  border-radius: 6px;
  cursor: pointer;
  transition:
    color 0.15s ease-in-out,
    background-color 0.15s ease-in-out,
    border-color 0.15s ease-in-out;
}

.change-color-btn:hover {
  color: #ffffff;
  background-color: #0d6efd;
  border-color: #0d6efd;
}

.reset-btn {
  padding: 6px 12px 6px 12px;
  font-size: 16px;
  font-weight: 400;
  font-family: inherit;
  line-height: 1.5;
  color: #dc3545;
  background-color: #ffffff;
  border: 1px solid #dc3545;
  border-radius: 6px;
  cursor: pointer;
  transition:
    color 0.15s ease-in-out,
    background-color 0.15s ease-in-out,
    border-color 0.15s ease-in-out;
}

.reset-btn:hover {
  color: #ffffff;
  background-color: #dc3545;
  border-color: #dc3545;
}
</style>`}},{detailTitle:"<code>transition.delay()</code> 延遲發動動畫的時間",detailSubtitle:"本例為逐漸移動再改變顏色",detailComponent:t(()=>e(()=>import("./D3jsTransitionColorAndDelayDemo-Bf6_8_CZ.js"),__vite__mapDeps([67,1,2,3,4,68]))),detailCode:{htmlCode:`<svg id="transitionColorAndDelay" class="mt-1" style="border: 1px solid rgb(103, 102, 102);"></svg><br>
<button id="transitionColorAndDelayBtn" class="btn btn-primary mt-2" type="button">開始動作</button>
<button id="transitionColorAndDelayBtnReset" class="btn btn-primary mt-2 ms-1" type="button">回復</button>

<script>
  const transitionColorAndDelayRect = d3.select("#transitionColorAndDelay")
                                        .append("rect")
                                        .attr("width", 40)
                                        .attr("height", 40)
                                        .attr("fill", "#f68b47")
                                        .attr("stroke", "#f68b47")
  
  document.querySelector("#transitionColorAndDelayBtn").addEventListener("click", () => {
    transitionColorAndDelayRect.transition()  // 這裡開始第一段動畫
                               .duration(1500)
                               .delay(300)  // 按下按鈕後，延遲0.3秒再執行下列動作
                               .attr("transform", "translate(140, 60)")
                               .transition()  // 這裡開始第二段動畫
                               .delay(500)  // 移動到定位後，延遲0.5秒再執行下列動作
                               .attr("fill", "green")
                               .attr("stroke-width", 6)
                               .attr("stroke", "red");
  });

  document.querySelector("#transitionColorAndDelayBtnReset").addEventListener("click", () => {
    transitionColorAndDelayRect.attr("transform", "translate(0, 0)")
                               .attr("fill", "#f68b47")
                               .attr("stroke-width", 1)
                               .attr("stroke", "#f68b47");
  });
<\/script>`,jsCode:null,vueCode:`<template>
  <svg
    ref="transitionColorAndDelaySvgRef"
    :width="width"
    :height="height"
    style="border: 1px solid lightgray;"
  ></svg>
  <div class="btn-container">
    <button
      type="button"
      class="move-and-change-btn"
      @click="moveAndChangeColor"
    >
      開始動作
    </button>
    <button
      type="button"
      class="reset-btn"
      @click="reset"
    >
      回復
    </button>
  </div>
</template>

<script setup>
import { ref, onMounted } from "vue";
import * as d3 from "d3";

// 圖表尺寸與內邊距設定
const width = 300;
const height = 200;

const transitionColorAndDelaySvgRef = ref(null);
let transitionColorAndDelayRect = null;

onMounted(() => {
  transitionColorAndDelayRect = d3.select(transitionColorAndDelaySvgRef.value)
                                  .append("rect")
                                  .attr("width", 40)
                                  .attr("height", 40)
                                  .attr("fill", "#f68b47")
                                  .attr("stroke", "#f68b47");
});

const moveAndChangeColor = () => {
  transitionColorAndDelayRect.transition()  // 這裡開始第一段動畫
                             .duration(1500)
                             .delay(300)  // 按下按鈕後，延遲0.3秒再執行下列動作
                             .attr("transform", "translate(140, 60)")
                             .transition()  // 這裡開始第二段動畫
                             .delay(500)  // 移動到定位後，延遲0.5秒再執行下列動作
                             .attr("fill", "green")
                             .attr("stroke-width", 6)
                             .attr("stroke", "red");
};

const reset = () => {
  transitionColorAndDelayRect.transition()
                             .attr("fill", "#f68b47")
                             .attr("stroke-width", 1)
                             .attr("stroke", "#f68b47")
                             .transition()
                             .delay(300)
                             .attr("transform", "translate(0, 0)");
};
<\/script>

<style scoped>
.btn-container {
  display: flex;
  gap: 5px;
}

.move-and-change-btn {
  padding: 6px 12px 6px 12px;
  font-size: 16px;
  font-weight: 400;
  font-family: inherit;
  line-height: 1.5;
  color: #0d6efd;
  background-color: #ffffff;
  border: 1px solid #0d6efd;
  border-radius: 6px;
  cursor: pointer;
  transition:
    color 0.15s ease-in-out,
    background-color 0.15s ease-in-out,
    border-color 0.15s ease-in-out;
}

.move-and-change-btn:hover {
  color: #ffffff;
  background-color: #0d6efd;
  border-color: #0d6efd;
}

.reset-btn {
  padding: 6px 12px 6px 12px;
  font-size: 16px;
  font-weight: 400;
  font-family: inherit;
  line-height: 1.5;
  color: #dc3545;
  background-color: #ffffff;
  border: 1px solid #dc3545;
  border-radius: 6px;
  cursor: pointer;
  transition:
    color 0.15s ease-in-out,
    background-color 0.15s ease-in-out,
    border-color 0.15s ease-in-out;
}

.reset-btn:hover {
  color: #ffffff;
  background-color: #dc3545;
  border-color: #dc3545;
}
</style>`}},{detailTitle:"<code>transition.delay()</code> 動畫逐漸發動",detailSubtitle:"本例為球依次移動。",detailComponent:t(()=>e(()=>import("./D3jsDelayCircleMove-ClrL32VE.js"),__vite__mapDeps([69,1,2,3,4,70]))),detailCode:{htmlCode:`<svg id="delayCircleMove" style="border: 1px solid rgb(103, 102, 102);"></svg><br>
<button id="delayCircleMoveBtn" class="btn btn-primary mt-3" type="button">開始動作</button>
<button id="delayCircleMoveBtnReset" class="btn btn-primary mt-3 ms-1" type="button">回復上一動</button>

<script>
  // 用for迴圈設定延遲時間
  const dataDelay = [];
  for (let i = 0; i < 8; i++) {
    dataDelay.push(160 - i * 20);
  };
  // 160 140 120 100 ... 20

  const delayCircleMove = d3.select("#delayCircleMove")
                            .selectAll("circle")
                            .data(dataDelay)
                            .join("circle")
                            .attr("cx", (d) => d)
                            .attr("cy", 30)
                            .attr("r", 15)
                            .attr("fill", "#f48b47")
                            .attr("opacity", 0.5);

  document.querySelector("#delayCircleMoveBtn").addEventListener("click", () => {
    delayCircleMove.transition()
                   .delay((d, i) => i * 200)  // 分別延遲
                   .attr("cx", (d) => d + 120);  // 位移距離
  });

  document.querySelector("#delayCircleMoveBtnReset").addEventListener("click", () => {
    delayCircleMove.transition()
                   .delay((d, i) => 1600 - i * 200)  // 先進後出
                   .attr("cx", (d) => d);  // 回復原位
  });
<\/script>`,jsCode:null,vueCode:`<template>
  <svg
    ref="delayCircleMoveSvgRef"
    :width="width"
    :height="height"
    style="border: 1px solid lightgray;"
  ></svg>
  <div class="btn-container">
    <button
      type="button"
      class="move-btn"
      @click="move"
    >
      開始動作
    </button>
    <button
      type="button"
      class="reset-btn"
      @click="reset"
    >
      回復上一動
    </button>
  </div>
</template>

<script setup>
import { ref, onMounted } from "vue";
import * as d3 from "d3";

// 圖表尺寸與內邊距設定
const width = 300;
const height = 200;

const delayCircleMoveSvgRef = ref(null);
let circles = null;
const dataDelay = Array.from({ length: 8}, (d, i) => 160 - i * 20);  // 用Array.from()設定延遲時間
// [160, 140, 120, 100, ... 20]

onMounted(() => {
  circles = d3.select(delayCircleMoveSvgRef.value)
              .selectAll("circle")
              .data(dataDelay)
              .join("circle")
              .attr("cx", (d) => d)
              .attr("cy", 30)
              .attr("r", 15)
              .attr("fill", "#f48b47")
              .attr("opacity", 0.5);
});

const move = () => {
  circles.transition()
         .delay((d, i) => i * 200)  // 分別延遲
         .attr("cx", (d) => d + 120);  // 位移距離
};

const reset = () => {
  circles.transition()
         .delay((d, i) => 1600 - i * 200)  // 先進後出
         .attr("cx", (d) => d);  // 回復原位（每個圓形<circle>的cx起始位置就是它的d值，它們在前面就「記住了」自己的資料值）
};
<\/script>

<style scoped>
.btn-container {
  display: flex;
  gap: 5px;
}

.move-btn {
  padding: 6px 12px 6px 12px;
  font-size: 16px;
  font-weight: 400;
  font-family: inherit;
  line-height: 1.5;
  color: #0d6efd;
  background-color: #ffffff;
  border: 1px solid #0d6efd;
  border-radius: 6px;
  cursor: pointer;
  transition:
    color 0.15s ease-in-out,
    background-color 0.15s ease-in-out,
    border-color 0.15s ease-in-out;
}

.move-btn:hover {
  color: #ffffff;
  background-color: #0d6efd;
  border-color: #0d6efd;
}

.reset-btn {
  padding: 6px 12px 6px 12px;
  font-size: 16px;
  font-weight: 400;
  font-family: inherit;
  line-height: 1.5;
  color: #dc3545;
  background-color: #ffffff;
  border: 1px solid #dc3545;
  border-radius: 6px;
  cursor: pointer;
  transition:
    color 0.15s ease-in-out,
    background-color 0.15s ease-in-out,
    border-color 0.15s ease-in-out;
}

.reset-btn:hover {
  color: #ffffff;
  background-color: #dc3545;
  border-color: #dc3545;
}
</style>`}},{detailTitle:"<code>transition.ease()</code>",detailSubtitle:"ease動畫展示。",detailComponent:t(()=>e(()=>import("./D3jsEaseDemonstration-BuPL7xlT.js"),__vite__mapDeps([71,2,3,72,1,24,4,73,74,75,76,23,25,34,77,31,26,78,28,79,80,45,81,12,13,20,14,82,83,27,44,22,41,29,84,85,86,87,88,89,16,11,18,32,90]))),detailCode:{htmlCode:`<svg id="easeDemonstration" class="mt-1" style="border: 1px solid rgb(103, 102, 102);"></svg>
<div class="d-flex align-items-baseline">
  <select name="easeDemonstration" id="easeDemonstrationSelection" class="m-3">
    <option></option>
  </select>
  <button id="easeDemonstrationBtn" class="btn btn-primary mt-3" type="button" onclick="updateEase()">Ease開始</button>
</div>

<script>
  const easeDot = d3.select("#easeDemonstration")
                    .append("circle")
                    .attr("cx", 40)
                    .attr("cy", 40)
                    .attr("r", 30)
                    .attr("fill", "#f68b47");
              
  // 抓出 D3.js 中所有 API 中名稱帶有 ease 開頭的 API
  const easeNames = Object.keys(d3).filter((d) => d.slice(0, 4) === "ease");  // 註：'slice(0, 4)'是將字符串的第0個到第4個字符提取出來（不包含第4個字符）
              
  d3.select("#easeDemonstrationSelection")
    .selectAll("option")
    .data(easeNames)
    .join("option")
    .attr("value", (d) => d)
    .text((d) => \`d3.\${d}\`);

  const updateEase = () => {
    const easeName = d3.select("#easeDemonstrationSelection")
                       .node().value;
    easeDot.attr("cx", 40)  // 回原點
           .transition()
           .ease(d3[easeName])  // 設定動畫效果
           .attr("cx", 200);
  };
<\/script>`,jsCode:null,vueCode:`<template>
  <svg
    ref="easeDemonstrationSvgRef"
    :width="width"
    :height="height"
    style="border: 1px solid lightgray;"
  ></svg>
  <div class="ease-container">
    <select v-model="selectedEase" class="ease-select">
      <option value="">請選擇</option>
      <option
        v-for="ease in easeNames"
        :key="ease"
        :value="ease"
      >
        d3.{{ ease }}
      </option>
    </select>

    <button
      type="button"
      class="ease-button"
      @click="updateEase"
    >
      Ease 開始
    </button>
  </div>
</template>

<script setup>
import { ref, onMounted } from "vue";
import * as d3 from "d3";

// 圖表尺寸與內邊距設定
const width = 300;
const height = 200;

const easeDemonstrationSvgRef = ref(null);
const selectedEase = ref("");
const easeNames = Object.keys(d3).filter(((d) => d.startsWith("ease")));

let easeDot = null;

onMounted(() =>{
  // 建立圓點
  easeDot = d3.select(easeDemonstrationSvgRef.value)
              .append("circle")
              .attr("cx", 40)
              .attr("cy", 40)
              .attr("r", 30)
              .attr("fill", "#f68b47");
});

const updateEase = () => {
  if (!selectedEase) return;

  easeDot.attr("cx", 40)  // 回原點
         .transition()
         .duration(500)
         .ease(d3[selectedEase.value])  // 設定動畫效果
         .attr("cx", 200);
};
<\/script>

<style scoped>
.ease-container {
  display: flex;
  gap: 8px
}

.ease-select {
  font-size: 16px;
  padding-left: 6px;
}

.ease-button {
  padding: 6px 12px 6px 12px;
  font-size: 16px;
  font-weight: 400;
  font-family: inherit;
  line-height: 1.5;
  color: #0d6efd;
  background-color: #ffffff;
  border: 1px solid #0d6efd;
  border-radius: 6px;
  cursor: pointer;
  transition:
    color 0.15s ease-in-out,
    background-color 0.15s ease-in-out,
    border-color 0.15s ease-in-out;
}

.ease-button:hover {
  color: #ffffff;
  background-color: #0d6efd;
  border-color: #0d6efd;
}
</style>`}},{detailTitle:"<code>transition.on(<i>typename[, 想執行的程式]</i>)</code>",detailSubtitle:"<code>typename = ['start', 'end', 'interrupt', 'cancel']</code>",detailComponent:t(()=>e(()=>import("./D3jsLoopAnimationDemo-B6A51X8v.js"),__vite__mapDeps([91,1,75,2,3,4]))),detailCode:{htmlCode:`<svg id="loopAnimation" style="border: 1px solid rgb(103, 102, 102);"></svg>

<script>
  const loopAnimation = d3.select("#loopAnimation")
                          .append("circle")
                          .attr("cx", 50)
                          .attr("cy", 50)
                          .attr("r", 25)
                          .attr("fill", "#f68b47")
                          .transition()
                          .duration(2000)
                          .on("start", goRight);

  function goRight() {
    d3.active(this)  // 取得正在進行中的過渡效果（transition）的函數
      .attr("cx", 250)
      .transition()
      .on("start", goLeft);
  };

  function goLeft() {
    d3.active(this)  // 取得正在進行中的過渡效果（transition）的函數
      .attr("cx", 50)
      .transition()
      .on("start", goRight);
  };
<\/script>`,jsCode:null,vueCode:`<template>
  <svg
    ref="loopAnimationSvgRef"
    :width="width"
    :height="height"
    style="border: 1px solid lightgray;"
  ></svg>
</template>

<script setup>
import { ref, onMounted } from "vue";
import * as d3 from "d3";

// 圖表尺寸與內邊距設定
const width = 300;
const height = 200;

const loopAnimationSvgRef = ref(null);

onMounted(() => {
  d3.select(loopAnimationSvgRef.value)
    .append("circle")
    .attr("cx", 50)
    .attr("cy", 50)
    .attr("r", 25)
    .attr("fill", "#f68b47")
    .transition()
    .duration(2000)
    .on("start", goRight);

  function goRight() {
    d3.active(this)  // 取得正在進行中的過渡效果（transition）的函數
      .attr("cx", 250)
      .transition()
      .on("start", goLeft);
  };

  function goLeft() {
    d3.active(this)  // 取得正在進行中的過渡效果（transition）的函數
      .attr("cx", 50)
      .transition()
      .on("start", goRight);
  };
});
<\/script>

<style scoped></style>`}}]}]},{id:"d3jsMouseEventNote",title:"滑鼠事件",description:"滑鼠事件，常見的事件有 <strong>點擊</strong>＆<strong>拂過</strong>、<strong>拖曳</strong>、<strong>縮放</strong>、<strong>選取刷</strong>。",descriptionComponent:null,descriptionComponentStyle:null,lists:[{listTitle:"點擊＆拂過",listSubtitle:null,listComponent:null,listCode:{htmlCode:null,jsCode:null,vueCode:null},listDetails:[{detailTitle:"<code>selection.on()</code> 滑鼠觸發事件 - 點擊",detailSubtitle:'點擊事件發生。此處使用 <code>.on("click", listener)</code>。',detailComponent:t(()=>e(()=>import("./D3jsClickSvgDemo-CcsguwzW.js"),__vite__mapDeps([92,1,2,3,4,85]))),detailCode:{htmlCode:`<svg id="clickSVG" style="border: 1px solid rgb(103, 102, 102);"></svg>

<script>
  const clickCircle = d3.select("#clickSVG")
                        .append("circle")
                        .attr("cx", 30)
                        .attr("cy", 20)
                        .attr("r", 20)
                        .attr("fill", "#f68b47")
                        .attr("cursor", "pointer");
  let isMoved = false;  // 用來追蹤圓球是否已經移動

  clickCircle.on("click", (e) => {
    if (!isMoved) {
      d3.select(e.target)
        .transition()
        .ease(d3.easeBack)
        .duration(1000)
        .attr("fill", "blue")
        .attr("transform", "translate(240, 0)");
      isMoved = true;  // 更新狀態為已移動
    } else {
      d3.select(e.target)
        .transition()
        .ease(d3.easeBack)
        .duration(1000)
        .attr("fill", "#f68b47")
        .attr("transform", "translate(0, 0)");
      isMoved = false;  // 更新狀態為未移動
    };
  });
<\/script>`,jsCode:null,vueCode:`<template>
  <svg
    ref="clickSvgRef"
    :width="width"
    :height="height"
    style="border: 1px solid lightgray;"
  ></svg>
</template>

<script setup>
import { ref, onMounted } from "vue";
import * as d3 from "d3";

// 圖表尺寸與內邊距設定
const width = 300;
const height = 200;

const clickSvgRef = ref(null);
let isMoved = false;  // 用來追蹤圓球是否已經移動

onMounted(() => {
  const clickCircle = d3.select(clickSvgRef.value)
                        .append("circle")
                        .attr("cx", 30)
                        .attr("cy", 30)
                        .attr("r", 20)
                        .attr("fill", "#f68b47")
                        .attr("cursor", "pointer");

  clickCircle.on("click", (e) => {
    if (!isMoved) {
      d3.select(e.target)
        .transition()
        .ease(d3.easeBack)
        .duration(1000)
        .attr("fill", "blue")
        .attr("transform", "translate(240, 0)");
      isMoved = true;  // 更新狀態為已移動
    } else {
      d3.select(e.target)
        .transition()
        .ease(d3.easeBack)
        .duration(1000)
        .attr("fill", "#f68b47")
        .attr("transform", "translate(0, 0)");
      isMoved = false;  // 更新狀態為未移動
    };
  })
});
<\/script>

<style scoped></style>`}},{detailTitle:"<code>selection.on()</code> 滑鼠觸發事件 - 拂過",detailSubtitle:'滑鼠拂過變色。此處使用 <code>.on("mouseover", listener)</code> 與 <code>.on("mouseleave", listener)</code>。',detailComponent:t(()=>e(()=>import("./D3jsMouseOverDemo-CdSYXV2b.js"),__vite__mapDeps([93,1,2,3,4]))),detailCode:{htmlCode:`<svg id="mouseoverSVG" style="border: 1px solid rgb(103, 102, 102);"></svg>

<script>
  const mouseoverCircle = d3.select("#mouseoverSVG")
                            .append("circle")
                            .attr("cx", 20)
                            .attr("cy", 20)
                            .attr("r", 50)
                            .attr("cursor", "pointer")
                            .attr("fill", "#f68b47")
                            .attr("transform", "translate(130, 55)");

  mouseoverCircle
    .on("mouseover", (e) => {
      d3.select(e.target)
        .transition()
        .duration(2000)
        .attr("fill", "blue");
    })
    .on("mouseleave", (e) => {
      d3.select(e.target)
        .transition()
        .duration(2000)
        .attr("fill", "#f68b47");
    });
<\/script>`,jsCode:null,vueCode:`<template>
  <svg
    ref="mouseOverSvgRef"
    :width="width"
    :height="height"
    style="border: 1px solid lightgray;"
  ></svg>
</template>

<script setup>
import { ref, onMounted } from "vue";
import * as d3 from "d3";

// 圖表尺寸與內邊距設定
const width = 300;
const height = 200;

const mouseOverSvgRef = ref(null);

onMounted(() => {
  const mouseOverCircle = d3.select(mouseOverSvgRef.value)
                            .append("circle")
                            .attr("cx", 20)
                            .attr("cy", 20)
                            .attr("r", 50)
                            .attr("cursor", "pointer")
                            .attr("fill", "#f68b47")
                            .attr("transform", "translate(130, 55)");

  mouseOverCircle.on("mouseover", (e) => {
                    d3.select(e.target)
                      .transition()
                      .duration(2000)
                      .attr("fill", "blue");
                  })
                  .on("mouseleave", (e) => {
                    d3.select(e.target)
                      .transition()
                      .duration(2000)
                      .attr("fill", "#f68b47");
                  });
});
<\/script>

<style scoped></style>`}},{detailTitle:"<code>d3.pointer(<i>event[, target]</i>)</code> 取得 DOM 節點的座標軸座標",detailSubtitle:"<code>event</code> 代表進行的事件；<code>target</code> 代表指定（要顯示座標）的目標。",detailComponent:t(()=>e(()=>import("./D3jsPointerSvgDemo-jebybE5-.js"),__vite__mapDeps([94,1,2,3,4,73]))),detailCode:{htmlCode:`<svg id="pointerSVG" style="border: 1px solid rgb(103, 102, 102);"></svg>

<script>
  const pointerSVG = d3.select("#pointerSVG")
                       .attr("width", 500)
                       .attr("height", 300)
                       .attr("cursor", "pointer");
  let pointerTxt = pointerSVG.append("text");

  pointerSVG
    .on("mousemove", (e) => {
      let pointerPosition = d3.pointer(e, pointerSVG.node());

      pointerTxt.attr("x", pointerPosition[0])  // 取[x]
                .attr("y", pointerPosition[1])  // 取[y]
                .text(\`x: \${parseInt(pointerPosition[0])},
                       y: \${parseInt(pointerPosition[1])}\`)
                .style("display", "block");
    })
    .on("mouseleave", (e) => {
      pointerTxt.style("display", "none");  // 離開SVG後不顯示文字
    });
<\/script>`,jsCode:null,vueCode:`<template>
  <svg
    ref="pointerSvgRef"
    :width="width"
    :height="height"
    style="border: 1px solid lightgray; cursor: pointer;"
    @mousemove="onMouseMove"
    @mouseleave="onMouseLeave"
  ></svg>
</template>

<script setup>
import { ref, onMounted } from "vue";
import * as d3 from "d3";

// 圖表尺寸與內邊距設定
const width = 300;
const height = 200;

const pointerSvgRef = ref(null);
let pointerTxt = null;

onMounted(() => {
  const pointerSvg = d3.select(pointerSvgRef.value);
  pointerTxt = pointerSvg.append("text")
                         .style("display", "none");
});

// 滑鼠移動時顯示座標
const onMouseMove = (e) => {
  const [x, y] = d3.pointer(e, pointerSvgRef.value);

  pointerTxt.attr("x", x)
            .attr("y", y)
            .text(\`x: \${Math.floor(x)}, y: \${Math.floor(y)}\`)
            .style("display", "block");
};

// 滑鼠離開時隱藏文字
const onMouseLeave = () => {
  pointerTxt.style("display", "none");  // 離開SVG後不顯示文字
};
<\/script>

<style scoped></style>`}},{detailTitle:"工具提示框（Tooltips）",detailSubtitle:null,detailComponent:t(()=>e(()=>import("./D3jsTooltipDemo-BiTFzFHY.js"),__vite__mapDeps([95,2,3,1,4,96]))),detailCode:{htmlCode:`<div id="tooltip"></div>

<script>
  const tooltipCircle = d3.select("#tooltip")
                          .append("svg")
                          .append("circle")
                          .attr("cx", 80)
                          .attr("cy", 75)
                          .attr("r", 40)
                          .attr("cursor", "pointer")
                          .attr("fill", "#f6cefc");
  const tooltip = d3.select("#tooltip")
                    .style("position", "relative")
                    .append("div")
                    .style("position", "absolute")
                    .style("display", "none")  // 初始隱藏Tooltip
                    .style("border", "1px solid black")
                    .style("border-radius", "5px")
                    .style("padding", "8px")
                    .html(
                      \`<p>
                        <b>我是Tooltip</b><br>
                        這裡可以放入想放入的文字，<br>
                        也可以插入圖片
                       </p>
                       <img src="assets/IMG_2073.jpg" width="60px" class="d-inline-block">
                      \`);

  // 加上滑鼠事件
  tooltipCircle
    .on("mouseover", (e) => {
      tooltip.style("display", "block");  
    })
    .on("mousemove", (e) => {
      tooltip.style("top", "-5px")
             .style("left", "180px");
    })
    .on("mouseleave", (e) => {
      tooltip.style("display", "none");
    });
<\/script>`,jsCode:null,vueCode:`<template>
  <div style="position: relative;">
    <svg
      ref="tooltipSvgRef"
      :width="width"
      :height="height"
      style="border: 1px solid lightgray;"
    ></svg>
    <div
      v-show="isTooltipVisible"
      style="position: absolute; top: 15px; left: 220px;"
      class="tooltip"
    >
      <p>
        <b>我是Tooltip</b><br />
        這裡可以放入想放入的文字，<br />
        也可以插入圖片
      </p>
      <img :src="tooltipImg" width="60px">
    </div>
  </div>
</template>

<script setup>
import { ref, onMounted } from "vue";
import * as d3 from "d3";
import tooltipImg from "../../../../assets/IMG_2073.jpg";

// 圖表尺寸與內邊距設定
const width = 200;
const height = 200;

const tooltipSvgRef = ref(null);
const isTooltipVisible = ref(false);
let tooltipCircle = null;

onMounted(() => {
  const tooltipSvg = d3.select(tooltipSvgRef.value);

  tooltipCircle = tooltipSvg.append("circle")
                            .attr("cx", 100)
                            .attr("cy", 100)
                            .attr("r", 40)
                            .attr("cursor", "pointer")
                            .attr("fill", "#f6cefc")
                            .on("mouseover", () => {
                              isTooltipVisible.value = true;
                            })
                            .on("mouseleave", () => {
                              isTooltipVisible.value = false;
                            });
});
<\/script>

<style scoped>
.tooltip {
  border: 1px solid black;
  border-radius: 5px;
  padding: 8px;
}

.tooltip p {
  margin-top: 4px;
}

.tooltip img {
  margin-bottom: 0;
}
</style>`}},{detailTitle:"進階工具提示框（Tooltips）",detailSubtitle:null,detailComponent:t(()=>e(()=>import("./D3jsAdvancedTooltipDemo-DfUuuMZ-.js"),__vite__mapDeps([97,2,3,1,28,31,26,4,88,78,73,98]))),detailCode:{htmlCode:`<div id="d3jsMouseEventAdvancedTooltip"></div>

<script>
  const data = [
    {r: 17, x: 134, y: 181},
    {r: 23, x: 294, y: 131},
    {r: 14, x: 84, y: 273},
    {r: 9, x: 323, y: 59},
    {r: 18, x: 172, y: 251},
    {r: 26, x: 404, y: 154}
  ];
  const svg = d3.select("#d3jsMouseEventAdvancedTooltip")
                .append("svg")
                .style("border", "1px solid rgb(103, 102, 102)")
                .attr("width", 500)
                .attr("height", 300);
  
  // 設定顏色
  const rData = data.map((d) => d.r);
  const colors = d3.scaleOrdinal(d3.schemeTableau10)  // 因'd3.schemeTableau10'已預設輸出域，所以不用另外設定'.range()'
                   .domain(rData);

  // 建立圓點
  const dots = svg.selectAll("circle")
                  .data(data)
                  .join("circle")
                  .attr("cx", (d) => d.x)
                  .attr("cy", (d) => d.y)
                  .attr("r", (d) => d.r)
                  .attr("fill", (d) => colors(d.x))
                  .style("cursor", "pointer");

  // 建立tooltip
  const tooltip = d3.select("#d3jsMouseEventAdvancedTooltip")
                    .style("position", "relative")
                    .append("div")
                    .style("display", "none")
                    .style("position", "absolute")
                    .style("background-color", "white")
                    .style("border", "2px solid")
                    .style("border-radius", "5px")
                    .style("padding", "5px");

  // 顯示tooltip
  dots
    .on("mouseover", (e) => {
      tooltip.style("display", "block");
    })
    .on("mousemove", (e) => {
      let pt = d3.pointer(e, e.target);  // 抓圓點位置
      tooltip.style("left", \`\${pt[0] + 30}px\`)  // 設定tooltip的水平位置
             .style("top", \`\${pt[1]}px\`)  // 設定tooltip的垂直位置
             .html(\`圓半徑：\${e.target.__data__.r}\`);
    })
    .on("mouseleave", (e) => {
      tooltip.style("display", "none");
    });
<\/script>`,jsCode:null,vueCode:`<template>
  <div style="position: relative;">
    <svg
      ref="advancedTooltipSvgRef"
      :width="width"
      :height="height"
      style="border: 1px solid lightgray;"
    ></svg>

    <!-- tooltip -->
    <div
      v-show="tooltip.visible"
      :style="{
        left: tooltip.x + 'px',
        top: tooltip.y + 'px',
      }"
      class="tooltip"
    >
      {{ tooltip.text }}
    </div>
  </div>
</template>

<script setup>
import { ref, onMounted, reactive } from "vue";
import * as d3 from "d3";

const advancedTooltipSvgRef = ref(null);
const tooltip = reactive({
  visible: false,
  x: 0,
  y: 0,
  text: ""
});

const data = [
  {r: 17, x: 134, y: 181},
  {r: 23, x: 294, y: 131},
  {r: 14, x: 84, y: 273},
  {r: 9, x: 323, y: 59},
  {r: 18, x: 172, y: 251},
  {r: 26, x: 404, y: 154}
];

// 圖表尺寸與內邊距設定
const width = d3.max(data, (d) => d.x) + 50;
const height = d3.max(data, (d) => d.y) + 50;

onMounted(() => {
  const svg = d3.select(advancedTooltipSvgRef.value);

  // 設定顏色
  const rData = data.map((d) => d.r);
  const colors = d3.scaleOrdinal(d3.schemeTableau10)  // 因'd3.schemeTableau10'已預設輸出域，所以不用另外設定'.range()'
                   .domain(rData);

  // 建立圓點
  svg.selectAll("circle")
     .data(data)
     .join("circle")
     .attr("cx", (d) => d.x)
     .attr("cy", (d) => d.y)
     .attr("r", (d) => d.r)
     .attr("fill", (d) => colors(d.x))
     .style("cursor", "pointer")
     .on("mouseover", () => {
       tooltip.visible = true;
     })
     .on("mousemove", (e, d) => {
       const pt = d3.pointer(e, svg.node());
       tooltip.x = pt[0] + 30;
       tooltip.y = pt[1];
       tooltip.text = \`圓半徑： \${d.r}\`;
     })
     .on("mouseleave", () => {
       tooltip.visible = false;
     });
});
<\/script>

<style scoped>
.tooltip {
  position: absolute;
  background-color: white;
  border: 2px solid;
  border-radius: 5px;
  padding: 5px;
}
</style>`}},{detailTitle:"插入其他 html 頁面",detailSubtitle:"點擊以打開包含其他 web 的 Tooltip，再點擊一次關閉。",detailComponent:t(()=>e(()=>import("./D3jsMouseEventInsertHtmlWeb-ZD2XubBA.js"),__vite__mapDeps([99,2,3,1,4,86,83,73,100]))),detailCode:{htmlCode:`<div id="d3jsMouseEventInsertHTMLWeb"></div>

<script>
  const tooltipIcon = d3.select("#d3jsMouseEventInsertHTMLWeb")
                        .append("svg")
                        .attr("height", 200)
                        .attr("width", 200)
                        .append("g")
                        .style("cursor", "pointer");
  const tooltipIconCircle = tooltipIcon.append("circle")
                                       .attr("cx", 100)
                                       .attr("cy", 100)
                                       .attr("r", 60)
                                       .attr("fill", "#69b3a2");
  const tooltipIconText = tooltipIcon.append("text")
                                     .text("按鈕")
                                     .attr("fill", "#eeeeee")
                                     .attr("x", 100)
                                     .attr("y", 110)
                                     .attr("text-anchor", "middle")
                                     .attr("font-size", 30)
                                     .attr("font-family", "sans-serif");
  const tooltip = d3.select("#d3jsMouseEventInsertHTMLWeb")
                    .style("position", "relative")
                    .append("div")
                    .attr("id", "tooltipWebsite")
                    .style("position", "absolute")
                    .style("display", "none")
                    .style("border", "2px solid black")
                    .style("border-radius", "10px")
                    .style("width", "700px")
                    .style("max-height", "600px")
                    .style("overflow", "auto")
                    .style("background-color", "#ffffff")
                    .style("padding", "20px");

  // 判斷是否已點擊開啟tooltip用
  let isClick = false;

  tooltipIcon
    .on("click", (e) => {
      if (!isClick) {
        // 引用其他網頁內容
        d3.html("study/statistics_note.html").then( (d) => {
          const bodyContent = d3.select(d).select("body").html();  // 只選取該網頁<body>內的內容

          d3.select("#tooltipWebsite")
            .style("display", "block")
            .html(bodyContent);  // 將選取的內容插入到Tooltip中

          MathJax.typesetPromise();  // 重新渲染 MathJax 公式
        });
        isClick = true;  // 切換至已開啟tooltip狀態
      } else {
        d3.select("#tooltipWebsite")
          .style("display", "none");
        isClick = false;  // 切換至未開啟tooltip狀態
      };
    })
    .on("mouseover", () => {
      tooltipIconCircle.attr("stroke", "#ffffff")
                       .attr("stroke-width", 5);
    })
    .on("mousemove", (e) => {
      let pt = d3.pointer(e, e.target);
      // 設置Tooltip位置
      d3.select("#tooltipWebsite")
        .style("left", \`\${pt[0] + 40}px\`)
        .style("top", \`\${pt[1] - 30}px\`);
    })
    .on("mouseleave", () => {
      tooltipIconCircle.attr("stroke-width", 0);
    });
<\/script>`,jsCode:null,vueCode:`<template>
  <div class="tooltip-container">
    <svg
      class="tooltip-svg"
      ref="insertHtmlSvgRef"
      :width="width"
      :height="height"
    ></svg>

    <div
      class="tooltip-html"
      v-show="tooltip.visible"
      :style="{ left: tooltip.x + 'px', top: tooltip.y + 'px' }"
      v-html="tooltip.html"
    ></div>
  </div>
</template>

<script setup>
import { ref, onMounted, reactive } from "vue";
import * as d3 from "d3";

// 圖表尺寸與內邊距設定
const width = 200;
const height = 200;

const insertHtmlSvgRef = ref(null);
const tooltip = reactive({
  visible: false,
  x: 0,
  y: 0,
  html: ""
});

let isClick = false;

onMounted(() => {
  const svg = d3.select(insertHtmlSvgRef.value)
                .append("g")
                .style("cursor", "pointer");

  const circle = svg.append("circle")
                    .attr("cx", 100)
                    .attr("cy", 100)
                    .attr("r", 60)
                    .attr("fill", "#69b3a2");

  // btnIcon的文字
  svg.append("text")
     .text("按鈕")
     .attr("fill", "#eeeeee")
     .attr("x", 100)
     .attr("y", 110)
     .attr("text-anchor", "middle")
     .attr("font-size", 30)
     .attr("font-family", "sans-serif");

  svg
    .on("click", () => {
      if (!isClick) {
        d3.html("https://quanting56.github.io/Antinant/study/statistics_note.html").then((doc) => {
          const bodyContent = d3.select(doc).select("body").html();
          tooltip.html = bodyContent;
          tooltip.visible = true;

          // MathJax.typesetPromise();  // 重新渲染MathJax公式（但前端使用上建議用CDN方式引入，真有需要再用）
        });
        isClick = true;
      } else {
        tooltip.visible = false;
        isClick = false;
      };
    })
    .on("mouseover", () => {
      circle.attr("stroke", "#ffffff").attr("stroke-width", 5);
    })
    .on("mousemove", (e) => {
      const pt = d3.pointer(e, svg.node());
      tooltip.x = pt[0] + 40;
      tooltip.y = pt[1] - 30;
    })
    .on("mouseleave", () => {
      circle.attr("stroke-width", 0);
    });
});
<\/script>

<style scoped>
.tooltip-container {
  position: relative;
}

.tooltip-svg {
  border: 1px solid lightgray;
}

.tooltip-html {
  position: absolute;
  border: 2px solid black;
  border-radius: 10px;
  width: 700px;
  max-height: 600px;
  overflow: auto;
  background-color: #ffffff;
  padding: 20px;
}
</style>`}}]},{listTitle:"拖曳",listSubtitle:null,listComponent:null,listCode:{htmlCode:null,jsCode:null,vueCode:null},listDetails:[{detailTitle:`<code>d3.drag()</code> 拖曳
<ul style="list-style-type: circle; margin-top: 16px;">
  <li><code>drag.on(<i>"typenames"[, listener]</i>)</code>：設定拖曳的細節，兩個參數分別是事件 <code>typenames</code> 與函式 <code>listener</code>，其中 <code>typenames</code> 有 <code>"start"</code>、<code>"dragged"</code>、<code>"end"</code> 三個階段。</li>
</ul>`,detailSubtitle:null,detailComponent:t(()=>e(()=>import("./D3jsDragDemo-DIi7j8OL.js"),__vite__mapDeps([101,1,28,2,3,4,84,74,73]))),detailCode:{htmlCode:`<div id="d3jsDragContainer"></div>

<script>
  const data = [
    {name: "A", x: 200, y: 340},
    {name: "B", x: 220, y: 300},
    {name: "C", x: 250, y: 198},
    {name: "D", x: 360, y: 296},
    {name: "E", x: 160, y: 150},
    {name: "F", x: 320, y: 60},
    {name: "G", x: 187, y: 250}
  ];
  const width = 600;
  const height = 400;
  const svg = d3.select("#d3jsDragContainer")
                .append("svg")
                .attr("width", width)
                .attr("height", height)
                .style("border", "1px solid rgb(103, 102, 102)");

  // 建立圓點
  const dots = svg.append("g")
                  .selectAll("circle")
                  .data(data)
                  .join("circle")
                  .attr("r", 25)
                  .attr("cx", (d) => d.x)
                  .attr("cy", (d) => d.y)
                  .style("fill", "#19d3a2")
                  .style("fill-opacity", 0.3)
                  .attr("stroke", "#b3a2c8")
                  .attr("stroke-width", 4)
                  .style("cursor", "pointer");

  // 建立拖曳方法
  // 在d3.drag()事件處理器中，應避免使用箭頭函數來確保'this'能綁定到正確的DOM元素
  const drag = d3.drag()
                 .on("start", function() {  // 因為要用'this'，所以用普通函數
                   d3.select(this).style("stroke", "blue");
                 })
                 .on("drag", function(e) {  // 因為要用'this'，所以用普通函數
                   const pt = d3.pointer(e, this);
                   d3.select(this)
                     .attr("cx", pt[0])
                     .attr("cy", pt[1]);
                 })
                 .on("end", function() {  // 因為要用'this'，所以用普通函數
                   d3.select(this).style("stroke", "#b3a2c8");
                 });

  // 呼叫拖曳方法
  dots.call(drag);
<\/script>`,jsCode:null,vueCode:`<template>
  <svg
    ref="dragSvgRef"
    :width="width"
    :height="height"
    style="border: 1px solid lightgray;"
  ></svg>
</template>

<script setup>
import { ref, onMounted } from "vue";
import * as d3 from "d3";

const dragSvgRef = ref(null);

const data = [
  {name: "A", x: 200, y: 340},
  {name: "B", x: 220, y: 300},
  {name: "C", x: 250, y: 198},
  {name: "D", x: 360, y: 296},
  {name: "E", x: 160, y: 150},
  {name: "F", x: 320, y: 60},
  {name: "G", x: 187, y: 250}
];

// 圖表尺寸與內邊距設定
const width = d3.max(data, (d) => d.x + 40);
const height = d3.max(data, (d) => d.y + 40);

onMounted(() => {
  // 建立圓點
  const dots = d3.select(dragSvgRef.value)
                 .append("g")
                 .selectAll("circle")
                 .data(data)
                 .join("circle")
                 .attr("r", 25)
                 .attr("cx", (d) => d.x)
                 .attr("cy", (d) => d.y)
                 .style("fill", "#19d3a2")
                 .style("fill-opacity", 0.3)
                 .attr("stroke", "#b3a2c8")
                 .attr("stroke-width", 4)
                 .style("cursor", "pointer");

  // 建立拖曳方法
  // 在d3.drag()事件處理器中，應避免使用箭頭函數來確保"this"能綁定到正確的DOM元素
  const drag = d3.drag()
                 .on("start", function() {  // 因為要用"this"，所以用普通函數
                   d3.select(this).style("stroke", "blue");
                 })
                 .on("drag", function(e) {  // 因為要用"this"，所以用普通函數
                   const pt = d3.pointer(e, this);
                   d3.select(this)
                     .attr("cx", pt[0])
                     .attr("cy", pt[1]);
                 })
                 .on("end", function() {  // 因為要用"this"，所以用普通函數
                   d3.select(this).style("stroke", "#b3a2c8");
                 });

  // 呼叫拖曳方法
  dots.call(drag);
});
<\/script>

<style scoped></style>`}}]},{listTitle:"縮放",listSubtitle:null,listComponent:null,listCode:{htmlCode:null,jsCode:null,vueCode:null},listDetails:[{detailTitle:`<code>d3.zoom()</code> 縮放
<ul style="list-style-type: circle; margin-top: 16px; line-height: 1.6;">
  <li><code>zoom.scaleExtent(<i>[k0, k1]</i>)</code>：設定縮放係數的大小範圍，預設是 [0, &infin;]。</li>
  <li><code>zoom.duration()</code>：滑鼠雙擊或觸控雙擊時 zoom 縮放的變換時長。</li>
  <li><code>d3.zoomIdentity()</code>：設定 transform 物件的狀態，可以藉下面的 code，讓縮放後的物件回復到原本大小。</li>
<pre style="padding: 16px;"><code class="javascript">d3.select("#resetBtn")
  .on("click", () => {
    const transformFunction = d3.zoomIdendity.scale(1);
    svg.call(zoomFunction.transform, transformFunction);
  });
</code></pre>
</ul>`,detailSubtitle:null,detailComponent:t(()=>e(()=>import("./D3jsZoomDemo-BkPAmFhC.js"),__vite__mapDeps([102,1,76,4,73,74,2,3,103]))),detailCode:{htmlCode:`<div id="zoomBasic"></div>
<button id="resetBtn" type="button" class="btn btn-primary mt-2">重設</button>

<script>
  const width = 450;
  const height = 300;
  const svg = d3.select("#zoomBasic")
                .append("svg")
                .attr("width", width)
                .attr("height", height)
                .style("border", "1px solid gray");
        
  // 加個圓點
  const circle = svg.append("circle")
                    .attr("id", "dot")
                    .attr("cx", width / 2)
                    .attr("cy", height / 2)
                    .attr("r", 50)
                    .attr("fill", "#69b3a2")
                    .style("cursor", "pointer");

  // 建立Zoom事件
  const zoomEvent = d3.zoom()
                      .extent([
                        [0, 0], [250, 250]
                      ])
                      .scaleExtent([1/5, 5])  // 縮放大小倍率限制
                      .duration(600)
                      .on("zoom", (e) => {
                        const transform = e.transform; // e.transform是一個d3.zoomTransform物件
                        // transfrom裡面有transform.x、transform.y、transform.k三個參數可以調整
                        // transform.x管x平移量，transform.y管y平移量，transform.k管縮放倍率
                        // 這邊決定要放大誰
                        // 使用transform.k調整選定元素屬性的transform的k，避免動到x、y造成元素位置改變
                        // 50為圓原半徑
                        circle.attr("r", (d) => 50 * transform.k);
                      });
        
  // 呼叫Zoom事件
  svg.call(zoomEvent);
  
  // 設立重置按鈕，以回復到原本狀態
  d3.select("#resetBtn")
    .on("click", () => {
      const transform = d3.zoomIdentity.scale(1);
      svg.call(zoomEvent.transform, transform);
    });
<\/script>`,jsCode:null,vueCode:`<template>
  <svg
    ref="zoomSvgRef"
    :width="width"
    :height="height"
    style="border: 1px solid lightgray;"
  ></svg>
  <div class="btn-container">
    <button
      type="button"
      ref="zoomResetBtnRef"
      class="reset-btn">重設</button>
  </div>
</template>

<script setup>
import { ref, onMounted } from "vue";
import * as d3 from "d3";

// 圖表尺寸與內邊距設定
const width = 300;
const height = 200;

const zoomSvgRef = ref(null);
const zoomResetBtnRef = ref(null);

onMounted(() => {
  // 加個圓點
  const circle = d3.select(zoomSvgRef.value)
                   .append("circle")
                   .attr("id", "dot")
                   .attr("cx", width / 2)
                   .attr("cy", height / 2)
                   .attr("r", 50)
                   .attr("fill", "#69b3a2")
                   .style("cursor", "pointer");

  // 建立Zoom事件
  const zoomEvent = d3.zoom()
                      .scaleExtent([1/5, 5])  // 縮放大小倍率限制
                      .duration(600)
                      .on("zoom", (e) => {
                        const transform = e.transform;  // e.transform是一個d3.zoomTransform物件
                        // transfrom裡面有transform.x、transform.y、transform.k三個參數可以調整
                        // transform.x管x平移量，transform.y管y平移量，transform.k管縮放倍率
                        // 使用transform.k調整選定元素屬性的transform的k，避免動到x、y造成元素位置改變
                        // 50為圓原半徑
                        circle.attr("r", (d) => 50 * transform.k);
                      });
        
  // 呼叫Zoom事件
  circle.call(zoomEvent);

  // 設立重置按鈕
  d3.select(zoomResetBtnRef.value)
    .on("click", () => {
      const transformReset = d3.zoomIdentity.scale(1);
      circle.transition()
            .call(zoomEvent.transform, transformReset);
    });
});
<\/script>

<style scoped>
.btn-container {
  display: flex;
  gap: 5px;
}

.reset-btn {
  padding: 6px 12px 6px 12px;
  font-size: 16px;
  font-weight: 400;
  font-family: inherit;
  line-height: 1.5;
  color: #dc3545;
  background-color: #ffffff;
  border: 1px solid #dc3545;
  border-radius: 6px;
  cursor: pointer;
  transition:
    color 0.15s ease-in-out,
    background-color 0.15s ease-in-out,
    border-color 0.15s ease-in-out;
}

.reset-btn:hover {
  color: #ffffff;
  background-color: #dc3545;
  border-color: #dc3545;
}
</style>`}}]},{listTitle:"選取刷",listSubtitle:null,listComponent:null,listCode:{htmlCode:null,jsCode:null,vueCode:null},listDetails:[{detailTitle:`<code>d3.brush()</code> 選取刷
<ul style="list-style-type: circle; margin-top: 16px; line-height: 1.6;">
  <li><code>d3.brush()</code>、<code>d3.brushX()</code>、<code>d3.brushY()</code>：分別是建立二維 brush、水平方向 brush、垂直方向 brush。</li>
  <li><code>brush.on(<i>"typenames"[, listener]</i>)</code>：用來監聽 brush 事件，兩個參數分別是事件 <code>typenames</code> 與函式 <code>listener</code>，其中 <code>typenames</code> 有 <code>"start"</code>、<code>"brush"</code>、<code>"end"</code> 三個階段。</li>
  <li><code>brush.extent(<i>[[x0, y0], [x1, y1]]</i>)</code>：設定允許刷取的範圍，<code>[x0, y0]</code>為範圍左上角，<code>[x1, y1]</code> 為範圍右下角。</li>
</ul>`,detailSubtitle:null,detailComponent:t(()=>e(()=>import("./D3jsBrushDemo-CY0o2GKn.js"),__vite__mapDeps([104,72,1,24,4,73,74,28,2,3]))),detailCode:{htmlCode:`<div id="brush"></div>

<script>
  const width = 540;
  const height = 360;
  const data = [
    {r: 20, x: 200, y: 120},
    {r: 35, x: 350, y: 280},
    {r: 25, x: 120, y: 240},
  ];

  // 建立SVG
  const svg = d3.select("#brush")
                .append("svg")
                .attr("width", width)
                .attr("height", height)
                .style("border", "1px solid gray");

  // 加上圓點
  const dots = svg.selectAll("circle")
                  .data(data)
                  .join("circle")
                  .attr("cx", (d) => d.x)
                  .attr("cy", (d) => d.y)
                  .attr("r", (d) => d.r)
                  .style("fill", "#69b3a2");

  // 設定brush的功能
  // 使用e.selection取得目前的selection
  // selection會產出一個二維陣列
  // 分別代表'x0', 'x1', 'y0', 'y1'，左上到右下的位置
  // 讓開發者有辦法重新計算目前位置的extent，進而進行其他操作。
  const brushed = (e) => {
    const brushExtent = e.selection;
    dots.style("fill", (d) => 
      isBrushed(brushExtent, d.x, d.y) ? "blue" : "#69b3a2"
    );

    // 判斷圓點是否在brush選到的區域內
    function isBrushed (brush_coors, cx, cy) {  // 'brush_coors', 'cx', 'cy'三者皆僅為函數變數名
      let x0 = brush_coors[0][0],
          x1 = brush_coors[1][0],
          y0 = brush_coors[0][1],
          y1 = brush_coors[1][1];
      return x0 <= cx && cx <= x1 && y0 <= cy && cy <= y1;  // 如果圓點在brush的範圍內，就會傳true：反之，則回傳false
    };
  };

  // 建立brush事件
  const brushEvent = d3.brush()
                       .extent([
                         [0, 0],
                         [600, 600]
                       ])  // extent限制刷子的活動區塊，理想是比SVG畫布稍大
                       .on("start brush", brushed);  // 綁定brush事件

  // 呼叫brush事件
  svg.call(brushEvent);
<\/script>`,jsCode:null,vueCode:`<template>
  <svg
    ref="brushSvgRef"
    :width="width"
    :height="height"
    style="border: 1px solid lightgray;"
  ></svg>
</template>

<script setup>
import { ref, onMounted } from "vue";
import * as d3 from "d3";

const data = [
  {r: 20, x: 200, y: 120},
  {r: 35, x: 350, y: 280},
  {r: 25, x: 120, y: 240},
];

// 圖表尺寸與內邊距設定
const width = d3.max(data, (d) => d.x + 60);
const height = d3.max(data, (d) => d.y + 60);

const brushSvgRef = ref(null);

onMounted(() => {
  const svg = d3.select(brushSvgRef.value);

  // 加上圓點
  const dots = svg.selectAll("circle")
                  .data(data)
                  .join("circle")
                  .attr("cx", (d) => d.x)
                  .attr("cy", (d) => d.y)
                  .attr("r", (d) => d.r)
                  .style("fill", "#69b3a2");

  // 設定brush的功能
  // 使用e.selection取得目前的selection
  // selection會產出一個二維陣列
  // 分別代表'x0', 'x1', 'y0', 'y1'，左上到右下的位置
  // 讓開發者有辦法重新計算目前位置的extent，進而進行其他操作。
  const brushed = (e) => {
    const brushExtent = e.selection;
    dots.style("fill", (d) => 
      isBrushed(brushExtent, d.x, d.y) ? "blue" : "#69b3a2"
    );

    // 判斷圓點是否在brush選到的區域內
    function isBrushed (brush_coors, cx, cy) {  // 'brush_coors', 'cx', 'cy'三者皆僅為函數變數名
      let x0 = brush_coors[0][0],
          x1 = brush_coors[1][0],
          y0 = brush_coors[0][1],
          y1 = brush_coors[1][1];
      return x0 <= cx && cx <= x1 && y0 <= cy && cy <= y1;  // 如果圓點在brush的範圍內，就會傳true：反之，則回傳false
    };
  };

  // 建立brush事件
  const brushEvent = d3.brush()
                       .extent([
                         [0, 0], [600, 600]
                       ])  // extent限制刷子的活動區塊，理想是比SVG畫布稍大
                       .on("start brush", brushed);  // 綁定brush事件

  // 呼叫brush事件
  svg.call(brushEvent);
});
<\/script>

<style scoped></style>`}}]}]},{id:"d3jsPieChartNote",title:"圓餅圖",description:null,descriptionComponent:null,descriptionComponentStyle:null,lists:[{listTitle:"圓餅圖（Pie Chart）",listSubtitle:null,listComponent:null,listCode:{htmlCode:null,jsCode:null,vueCode:null},listDetails:[{detailTitle:"一般的圓餅圖",detailSubtitle:"此處使用簡單格式的 data。",detailComponent:t(()=>e(()=>import("./D3jsPieChartDemo-DSo8z5Va.js"),__vite__mapDeps([105,1,31,26,81,12,13,20,14,2,3,4,87,78]))),detailCode:{htmlCode:`<div id="pieChartExample"></div>

<script>
  const pieChartExampleWidth = 600;
  const pieChartExampleHeight = 400;
  const pieChartExampleMargin = 40;
  const pieChartExampleData = [
    { item: "交通", data: 3000 },
    { item: "房租", data: 12000 },
    { item: "日常用品", data: 1400 },
    { item: "吃飯", data: 4000 },
    { item: "交際應酬", data: 2400 }
  ];

  const pieChartExampleSVG = d3.select("#pieChartExample")
                               .append("svg")
                               .attr("width", pieChartExampleWidth)
                               .attr("height", pieChartExampleHeight);

  // 建立圓餅圖的群組元素'g'，用來容納圓餅圖的切片
  pieChartExampleSVG.append("g")
                    .attr("id", "pieChartExampleSlices")
                    .attr("transform", \`translate(\${pieChartExampleWidth / 2}, \${pieChartExampleHeight / 2})\`);

  // 設定顏色比例尺，從'd3.schemeSet2'配色方案中選取顏色
  const pieChartExampleColor = d3.scaleOrdinal().range(d3.schemeSet2);

  // 設定圓餅圖的半徑
  const pieChartExampleRadius = Math.min(pieChartExampleWidth, pieChartExampleHeight) / 2 - pieChartExampleMargin;

  // 設定圓餅圖的生成器，指定根據'data'屬性來生成圖表
  const pieChartExamplePieChartGenerator = d3.pie().value((d) => d.data);

  // 設定每個圓餅圖切片的弧度生成器，定義內半徑和外半徑
  const pieChartExampleArc = d3.arc()
                               .innerRadius(0)  // 設定內半徑為0（實心圓）
                               .outerRadius(pieChartExampleRadius)  // 設定外半徑為計算出的半徑值
                               .padAngle(0);  // 設定每個切片之間的間隔角度為0

  // 設定外弧，用於放置標籤或其他用途
  const pieChartExampleOuterArc = d3.arc()
                                    .outerRadius(pieChartExampleRadius)
                                    .innerRadius(pieChartExampleRadius - 10);

  // 使用圓餅圖生成器將資料轉換為可以繪製的形式
  const pieChartExamplePieChartData = pieChartExamplePieChartGenerator(pieChartExampleData);

  // 在群組元素中綁定資料並生成'path'元素，代表圓餅圖的每一塊
  const pieChartExampleExpensesChart = pieChartExampleSVG.select("#pieChartExampleSlices")
                                                         .selectAll("path")
                                                         .data(pieChartExamplePieChartData)
                                                         .join("path")
                                                         .attr("d", pieChartExampleArc)  // 根據生成的弧形路徑繪製圓餅圖
                                                         .attr("class", "pieChartExampleArc")  // 設定弧形們的class
                                                         .attr("fill", pieChartExampleColor)  // 根據資料設定填充顏色
                                                         .attr("stroke", "#ffffff")  // 設定弧形的邊框顏色為白色
                                                         .attr("stroke-width", "3px")  // 設定邊框寬度為3像素
                                                         .style("opacity", 1);  // 設定每個切片的透明度為1（不透明）

  
  // 加上每個區塊的數字標示，計算百分比並設定標籤文字
  const pieChartExampleTotal = d3.sum(pieChartExampleData, (d) => d.data);  // 計算總支出金額
  pieChartExampleData.forEach((i) => {  // 透過一個forEach迴圈，計算每項支出佔總額的百分比
    i.percentage = Math.round((i.data / pieChartExampleTotal) * 100);  // 在原始data新增一個名為'percentage'的新屬性，儲存百分比
  });

  // 綁定標籤資料，生成'text'元素並設定位置、文字內容、樣式
  const pieChartExampleLabels = d3.select("#pieChartExampleSlices")
                                  .selectAll("text")
                                  .data(pieChartExamplePieChartData)  // 需使用d3.pie()處理後的資料，因為原始資料沒有角度資訊
                                  .join("text")
                                  .attr("class", "pieChartExampleLabels")
                                  .attr("transform", (d) => \`translate(\${pieChartExampleOuterArc.centroid(d)})\`)  // ".centroid()"是取得圓弧線段中心的座標
                                  .text((d) => d.data.item + " " + d.data.percentage + "%")  // 'd.data'是d3.pie()處理後的資料裡所包含的原始資料部分
                                  .style("text-anchor", "middle")
                                  .style("font-size", 16)
                                  .style("fill", "black");

  
  // 設定滑鼠互動事件，當滑鼠移到圓餅圖的切片上時，切片會放大並產生陰影
  d3.selectAll(".pieChartExampleArc")
    .style("cursor", "pointer")
    .on("mouseover", (e, d) => {  // 當滑鼠移到切片上時觸發
      d3.select(e.target)
        .transition()
        .duration(500)
        .style("transform", "scale(1.1)");  // 將切片放大至1.1倍

      d3.selectAll(".pieChartExampleLabels")
        .filter((labelData) => labelData.index === d.index)  // 選取對應的標籤
        .transition()
        .duration(500)
        .style("font-size", "24px");
    })
    .on("mousemove", (d) => {
      d3.select(d.target)
        .style("filter", "drop-shadow(2px 4px 6px #000000)");  // 加上陰影效果
    })
    .on("mouseleave", (e, d) => {  // 當滑鼠離開切片時觸發
      d3.select(e.target)
        .transition()
        .duration(500)
        .style("filter", "drop-shadow(0 0 0 black)")  // 移除陰影效果
        .style("transform", "scale(1)");  // 將切片還原到原始大小

      d3.selectAll(".pieChartExampleLabels")
        .filter((labelData) => labelData.index === d.index)  // 選取對應的標籤
        .transition()
        .duration(500)
        .style("font-size", "16px");
    });
<\/script>`,jsCode:null,vueCode:`<template>
  <svg
    ref="pieChartSvgRef"
    :width="width"
    :height="height"
  ></svg>
</template>

<script setup>
import { ref, onMounted } from "vue";
import * as d3 from "d3";

// 圖表尺寸與內邊距設定
const width = 420;
const height = 280;
const margin = 15;

const pieChartSvgRef = ref(null);

const rawData = [
  { item: "交通", cost: 3000 },
  { item: "房租", cost: 12000 },
  { item: "日常用品", cost: 1400 },
  { item: "吃飯", cost: 4000 },
  { item: "交際應酬", cost: 2400 }
];

onMounted(() => {
  const svg = d3.select(pieChartSvgRef.value);

  // 建立圓餅圖的群組元素"g"，用來容納圓餅圖的切片
  const g = svg.append("g")
               .attr("transform", \`translate(\${width / 2}, \${height / 2})\`);

  // 設定顏色比例尺，從"d3.schemeSet2"配色方案中選取顏色
  const color = d3.scaleOrdinal().range(d3.schemeSet2);

  // 設定圓餅圖的半徑
  const radius = Math.min(width, height) / 2 - margin;

  // 設定圓餅圖的生成器，指定根據"cost"屬性來生成圖表
  const pieGenerator = d3.pie().value((d) => d.cost);

  // 使用圓餅圖生成器將資料轉換為可以繪製的形式
  const arcData = pieGenerator(rawData);

  // 設定每個圓餅圖切片的弧度生成器，定義內半徑和外半徑
  const arc = d3.arc()
                .innerRadius(0)  // 設定內半徑為0（實心圓）
                .outerRadius(radius)  // 設定外半徑為計算出的半徑值
                .padAngle(0);  // 設定每個切片之間的間隔角度為0

  // 設定外弧，用於放置標籤或其他用途
  const outerArc = d3.arc()
                     .innerRadius(radius - 10)
                     .outerRadius(radius);

  // 在群組元素中綁定資料並生成"path"元素，代表圓餅圖的每一塊
  const slices = g.selectAll("path")
                  .data(arcData)
                  .join("path")
                  .attr("d", arc)  // 根據生成的弧形路徑繪製圓餅圖
                  .attr("fill", color)  // 根據資料設定填充顏色
                  .attr("stroke", "#ffffff")  // 設定弧形的邊框顏色為白色
                  .attr("stroke-width", "3px")  // 設定邊框寬度為3像素
                  .style("opacity", 1);  // 設定每個切片的透明度為1（不透明）

  // 加上每個區塊的數字標示，計算百分比並設定標籤文字
  const total = d3.sum(rawData, (d) => d.cost);  // 計算總支出金額
  rawData.forEach((i) => {  // 透過一個forEach迴圈，計算每項支出佔總額的百分比
    i.percentage = Math.round((i.cost / total) * 100);  // 在原始data新增一個名為"percentage"的新屬性，儲存百分比
  });

  // 綁定標籤資料，生成"text"元素並設定位置、文字內容、樣式
  const labels = g.selectAll("text")
                  .data(arcData)  // 需使用d3.pie()處理後的資料，因為原始資料沒有角度資訊
                  .join("text")
                  .attr("transform", (d) => \`translate(\${outerArc.centroid(d)})\`)  // ".centroid()"是取得圓弧線段中心的座標
                  .text((d) => \`\${d.data.item} \${d.data.percentage}%\`)  // "d.data"是d3.pie()處理後的資料裡所包含的原始資料部分
                  .style("text-anchor", "middle")
                  .style("font-size", 16)
                  .style("fill", "black");

  // 設定滑鼠互動事件，當滑鼠移到圓餅圖的切片上時，切片會放大並產生陰影
  slices.style("cursor", "pointer")
        .on("mouseover", (e, d) => {  // 當滑鼠移到切片上時觸發
          d3.select(e.target)
            .transition()
            .duration(500)
            .style("transform", "scale(1.1)");  // 將切片放大至1.1倍

          labels.filter((labelData) => labelData.index === d.index)  // 選取對應的標籤
                .transition()
                .duration(500)
                .style("font-size", "24px");
        })
        .on("mousemove", (e) => {
          d3.select(e.target)
            .style("filter", "drop-shadow(2px 4px 6px #000000)");  // 加上陰影效果
        })
        .on("mouseleave", (e, d) => {  // 當滑鼠離開切片時觸發
          d3.select(e.target)
            .transition()
            .duration(500)
            .style("filter", "drop-shadow(0 0 0 black)")  // 移除陰影效果
            .style("transform", "scale(1)");  // 將切片還原到原始大小

          labels.filter((labelData) => labelData.index === d.index)  // 選取對應的標籤
                .transition()
                .duration(500)
                .style("font-size", "16px");
        });
});
<\/script>

<style scoped></style>`}},{detailTitle:"可以切換不同資料的圓餅圖",detailSubtitle:"此處使用個人 fatsecret 於 2023 年的飲食紀錄，資料引用外部 csv 檔案。",detailComponent:t(()=>e(()=>import("./D3jsSwitchPieChartsDemo-D5pVh93O.js"),__vite__mapDeps([106,1,2,3,31,26,81,12,13,20,14,4,88,78,73,27,24,25,107]))),detailCode:{htmlCode:`<!-- 這邊的 -->
<!-- 純 HTML/CSS/JavaScript 原始碼 -->
<!-- 與 -->
<!-- 下方的 Vue SFC 程式碼（有大改） -->
<!-- 結果不太一樣 -->


<div id="d3jsEnergyGainPieChart"></div>
<div class="d-flex justify-content-center">
  <button type="button" id="d3jsEnergyGainPieChart2023MayBtn" class="btn btn-warning mx-1">2023/05</button>
  <button type="button" id="d3jsEnergyGainPieChart2023JuneBtn" class="btn btn-warning mx-1">2023/06</button>
  <button type="button" id="d3jsEnergyGainPieChart2023JulyBtn" class="btn btn-warning mx-1">2023/07</button>
</div>

<script>
  const d3jsEnergyGainChart = async() => {
    const width = 600;
    const height = 400;
    const margin = 40;

    // 切換月份的按鈕
    const May2023Btn = d3.select("#d3jsEnergyGainPieChart2023MayBtn")
                         .on("click", (e, d) => {
                           May2023Btn.style("background-color", "#e09500")
                           June2023Btn.style("background-color", "#ffc107")
                           July2023Btn.style("background-color", "#ffc107")
                           upDatePieData(data202305)
                         });
    const June2023Btn = d3.select("#d3jsEnergyGainPieChart2023JuneBtn")
                          .on("click", (e, d) => {
                            May2023Btn.style("background-color", "#ffc107")
                            June2023Btn.style("background-color", "#e09500")
                            July2023Btn.style("background-color", "#ffc107")
                            upDatePieData(data202306)
                          });
    const July2023Btn = d3.select("#d3jsEnergyGainPieChart2023JulyBtn")
                          .on("click", (e, d) => {
                            May2023Btn.style("background-color", "#ffc107")
                            June2023Btn.style("background-color", "#ffc107")
                            July2023Btn.style("background-color", "#e09500")
                            upDatePieData(data202307)
                          });

    // 獲取數據
    let data202305 = await d3.csv("data/energyGain/202305.csv");
    data202305 = data202305.filter((d, i) => i >= 1 && i <= 4);
    let data202306 = await d3.csv("data/energyGain/202306.csv");
    data202306 = data202306.filter((d, i) => i >= 1 && i <= 4);
    let data202307 = await d3.csv("data/energyGain/202307.csv");
    data202307 = data202307.filter((d, i) => i >= 1 && i <= 4);
    
    // 建立svg
    const svg = d3.select("#d3jsEnergyGainPieChart")
                  .append("svg")
                  .attr("width", width)
                  .attr("height", height);

    // 建立圓餅圖的群組元素'g'，用來容納圓餅圖的切片
    svg.append("g")
       .attr("id", "d3jsEnergyGainPieChartSlices")
       .attr("transform", \`translate(\${width / 2}, \${height / 2})\`);

    // 設定顏色比例尺，從'd3.schemeSet2'配色方案中選取顏色
    const color = d3.scaleOrdinal()
                    .domain(['breakfast', 'lunch', 'dinner', 'snack'])
                    .range(d3.schemeTableau10);

    // 設定圓餅圖的半徑
    const radius = Math.min(width, height) / 2 - margin;

    // 設定更新資料的方法，把要繪圖的函式放進去，以讓它們能夠重新繪圖
    const upDatePieData = (data) => {

      // 設定圓餅圖的生成器，指定根據'data'屬性來生成圖表
      const pieChartGenerator = d3.pie().value((d) => d.total).sort((a, b) => d3.ascending(a.key, b.key));

      // 設定每個圓餅圖切片的弧度生成器，定義內半徑和外半徑
      const arc = d3.arc()
                    .innerRadius(0)  // 設定內半徑為0（實心圓）
                    .outerRadius(radius)  // 設定外半徑為計算出的半徑值
                    .padAngle(0);

      // 設定外弧，用於放置標籤或其他用途
      const outerArc = d3.arc()
                         .outerRadius(radius)
                         .innerRadius(radius - 10);

      // 使用圓餅圖生成器將資料轉換為可以繪製的形式
      const pieChartData = pieChartGenerator(data);

      // 在群組元素中綁定資料並生成'path'元素，代表圓餅圖的每一塊
      const energyGainChart = svg.select("#d3jsEnergyGainPieChartSlices")
                                 .selectAll("path")
                                 .data(pieChartData)
                                 .join("path")
                                 .attr("class", "d3jsEnergyGainPieChartArc")  // 設定弧形們的class
                                 .transition()
                                 .duration(800)
                                 .attr("d", arc)  // 根據生成的弧形路徑繪製圓餅圖
                                 .attr("fill", (d) => color(d.data.date))  // 根據資料設定填充顏色（此處壓'date'乃僅因剛好資料中餐別的行首是'date'）
                                 .attr("stroke", "#f2f2f2")  // 設定弧形的邊框顏色為類白色
                                 .attr("stroke-width", "3px")  // 設定邊框寬度為3像素
                                 .style("opacity", 1);  // 設定每個切片的透明度為1（不透明）

      // 加上每個區塊的數字標示，計算百分比並設定標籤文字
      const dataTotal = d3.sum(data, (d) => d.total);  // 計算總支出金額
      data.forEach((i) => {  // 透過一個forEach迴圈，計算每項支出佔總額的百分比
        i.percentage = Math.round((i.total / dataTotal) * 100);  // 在原始data新增一個名為'percentage'的新屬性，儲存百分比
      });

      // 定義餐別名，製作文字標籤用
      const mealType = d3.scaleOrdinal()
                         .domain(['breakfast', 'lunch', 'dinner', 'snack'])
                         .range(['早餐', '午餐', '晚餐', '點心']);

      // 綁定標籤資料，生成'text'元素並設定位置、文字內容、樣式
      const labels = d3.select("#d3jsEnergyGainPieChartSlices")
                       .selectAll("text")
                       .data(pieChartData)  // 需使用d3.pie()處理後的資料，因為原始資料沒有角度資訊
                       .join("text")
                       .attr("class", "d3jsEnergyGainPieChartLabels")
                       .transition()
                       .duration(800)
                       .attr("transform", (d) => \`translate(\${outerArc.centroid(d)})\`)
                       .text((d) => mealType(d.data.date) + " " + d.data.percentage + "%")  // 'd.data'是d3.pie()處理後的資料裡所包含的原始資料部分
                       .style("text-anchor", "middle")
                       .style("font-size", 16)
                       .style("fill", "black");
    };
    upDatePieData(data202305);

    // 設定滑鼠互動事件，當滑鼠移到圓餅圖的切片上時，切片會放大並產生陰影
    d3.selectAll(".d3jsEnergyGainPieChartArc")
      .style("cursor", "pointer")
      .on("mouseover", (e, d) => {  // 當滑鼠移到切片上時觸發
        d3.select(e.target)
          .transition()
          .duration(500)
          .style("transform", "scale(1.1)");  // 將切片放大至1.1倍
      
        d3.selectAll(".d3jsEnergyGainPieChartLabels")
          .filter((labelData) => labelData.index === d.index)  // 選取對應的標籤
          .transition()
          .duration(500)
          .style("font-size", "24px");

        // 加Tooltip
        const pt = d3.pointer(e, e.target);
        d3.select("#d3jsEnergyGainPieChart")
          .style("position", "relative")
          .append("div")
          .style("position", "absolute")
          .attr("class", "d3jsEnergyGainPieChartToolpix")
          .style("left", \`\${pt[0] + 320}px\`)  // "320"為偏移修正量
          .style("top", \`\${pt[1] + 140}px\`)  // "140"為偏移修正量
          .style("background-color", "#f2f2f2")
          .style("color", "#121212")
          .style("border", "2px solid #121212")
          .style("border-radius", "5px")
          .style("padding", "10px")
          .html(\`共 \${d.data.total} 大卡\`)
      })
      .on("mousemove", (e, d) => {
        d3.select(e.target)
          .style("filter", "drop-shadow(2px 4px 6px #000000)");  // 加上陰影效果

        // 移動Tooltip
        const pt = d3.pointer(e, e.target);
        d3.select(".d3jsEnergyGainPieChartToolpix")
          .style("left", \`\${pt[0] + 320}px\`)  // "320"為偏移修正量
          .style("top", \`\${pt[1] + 140}px\`);  // "140"為偏移修正量
      })
      .on("mouseleave", (e, d) => {  // 當滑鼠離開切片時觸發
        d3.select(e.target)
          .transition()
          .duration(500)
          .style("filter", "drop-shadow(0 0 0 black)")  // 移除陰影效果
          .style("transform", "scale(1)");  // 將切片還原到原始大小
      
        d3.selectAll(".d3jsEnergyGainPieChartLabels")
          .filter((labelData) => labelData.index === d.index)  // 選取對應的標籤
          .transition()
          .duration(500)
          .style("font-size", "16px");

        // 移出圓餅圖後刪除tooltip
        d3.select(".d3jsEnergyGainPieChartToolpix").remove();
      });
  };
  d3jsEnergyGainChart();
<\/script>`,jsCode:null,vueCode:`<template>
  <div
    ref="containerRef"
    :style="{ width: width + 'px' }"
    style="position: relative;"
  >
    <svg ref="svgRef" :width="width" :height="height"></svg>
    <div class="btn-container">
      <button
        v-for="m in months"
        :key="m.key"
        class="month-btn"
        :class="{ 'active-month-btn': selectedMonth === m.key }"
        @click="loadAndUpdate(m.key)"
      >
        {{ m.label }}
      </button>
    </div>
  </div>
</template>

<script setup>
import { ref, onMounted, onBeforeUnmount } from "vue";
import * as d3 from "d3";

// 你的 JSON 檔
import energyGain202305 from "../../../../assets/web-note-view/d3js-note-view/energy-gain/202305.json";
import energyGain202306 from "../../../../assets/web-note-view/d3js-note-view/energy-gain/202306.json";
import energyGain202307 from "../../../../assets/web-note-view/d3js-note-view/energy-gain/202307.json";

const width = 420;
const height = 280;
const margin = 15;
const MEALS = ["breakfast", "lunch", "dinner", "snack"];

const containerRef = ref(null);
const svgRef = ref(null);
const selectedMonth = ref("202305");

const months = [
  { key: "202305", label: "2023/05", data: energyGain202305 },
  { key: "202306", label: "2023/06", data: energyGain202306 },
  { key: "202307", label: "2023/07", data: energyGain202307 }
];

// D3狀態（提升到外層，方便共用與清理）
let svg, g, arcsGroup, labelsGroup, color, pie, arc, outerArc, tooltipEl;

function aggregateByMeal(dailyRows) {
  // dailyRows是json檔裡每日物件陣列
  return MEALS.map(meal => {
    const total = d3.sum(dailyRows, r => +r[meal] || 0);
    return { date: meal, total };
  });
}

function createTooltip(container) {
  const t = d3.select(container)
              .append("div")
              .attr("class", "d3-tooltip")
              .style("position", "absolute")
              .style("pointer-events", "none")
              .style("display", "none")
              .style("background", "#f2f2f2")
              .style("color", "#121212")
              .style("border", "1px solid #121212")
              .style("border-radius", "6px")
              .style("padding", "8px")
              .style("font-size", "13px")
              .style("z-index", 1000);
  return t;
}

function updateChartFromDaily(rawDailyRows) {
  // 1) 聚合成各餐別的資料
  const agg = aggregateByMeal(rawDailyRows);
  const totalAll = d3.sum(agg, d => d.total) || 1;
  agg.forEach(d => (d.percentage = Math.round((d.total / totalAll) * 100)));

  // 2) 產生pieData
  const pieData = pie(agg);

  // 3) 每一片slices，以餐別名稱作為key
  const slices = arcsGroup.selectAll("path.slice").data(pieData, d => d.data.date);

  // 新增部分
  const enterSlices = slices.enter()
                            .append("path")
                            .attr("class", "slice")
                            .attr("fill", d => color(d.data.date))
                            .attr("stroke", "#f2f2f2")
                            .attr("stroke-width", 3)
                            .each(function(d) { this._current = d; }) // 保存初始 state
                            .style("opacity", 0)
                            .style("transform-box", "fill-box")
                            .style("transform-origin", "center");

  // 合併新增與更新部分
  const mergedSlices = enterSlices.merge(slices);

  // 在合併後的selection上綁定事件
  mergedSlices.style("cursor", "pointer")
              .on("mouseover", function(event, d) {
                const el = d3.select(this);
                el.raise();
                el.transition().duration(500).style("transform", "scale(1.08)");
              
                // 放大標籤文字
                labelsGroup.selectAll("text.label")
                           .filter(ld => ld.data.date === d.data.date)
                           .transition()
                           .duration(500)
                           .style("font-size", "20px");
              
                // 在相對容器位置顯示tooltip
                const [mx, my] = d3.pointer(event, containerRef.value);
                tooltipEl.html(\`共 \${d3.format(",")(d.data.total)} 大卡\`)  // 每三位一個逗號
                         .style("left", \`\${mx + 12}px\`)
                         .style("top", \`\${my + 12}px\`)
                         .style("display", "block");
              })
              .on("mousemove", function(e) {
                const [mx, my] = d3.pointer(e, containerRef.value);
                tooltipEl.style("left", \`\${mx + 12}px\`)
                         .style("top", \`\${my + 12}px\`);
                d3.select(this)
                  .style("filter", "drop-shadow(2px 4px 6px rgba(0, 0, 0, 0.45))");
              })
              .on("mouseleave", function(event, d) {
                d3.select(this)
                  .transition()
                  .duration(500)
                  .style("transform", "scale(1)")
                  .style("filter", null);

                labelsGroup.selectAll("text.label")
                           .filter(ld => ld.data.date === d.data.date)
                           .transition().duration(500)
                           .style("font-size", "14px");

                tooltipEl.style("display", "none");
              });

  // 4) 使用d3.interpolate()來動畫改變弧形的d屬性
  mergedSlices.transition()
              .duration(500)
              .style("opacity", 1)
              .attrTween("d", function(d) {
                const prev = this._current || d;
                const i = d3.interpolate(prev, d);
                this._current = i(1);
                return t => arc(i(t));
              });

  // 刪除部分
  slices.exit()
        .transition()
        .duration(500)
        .style("opacity", 0)
        .remove();

  const mealType = d3.scaleOrdinal()
                     .domain(MEALS)
                     .range(["早餐", "午餐", "晚餐", "點心"]);

  const texts = labelsGroup.selectAll("text.label")
                           .data(pieData, d => d.data.date);

  const enterTexts = texts.enter()
                          .append("text")
                          .attr("class", "label")
                          .attr("text-anchor", "middle")
                          .style("font-size", "14px")
                          .each(function(d){ this._current = d; })
                          .style("opacity", 0);

  const mergedTexts = enterTexts.merge(texts);

  mergedTexts.transition()
             .duration(500)
             .attrTween("transform", function(d) {
               const prev = this._current || d;
               const i = d3.interpolate(prev, d);
               this._current = i(1);
               return t => \`translate(\${outerArc.centroid(i(t))})\`;
             })
             .tween("text", function(d) {
               const raw = this.textContent.replace(/[^d]/g, "");
               const start = raw !== "" ? +raw : d.data.percentage;
               const interp = d3.interpolateRound(start, d.data.percentage);
               return t => d3.select(this).text(\`\${mealType(d.data.date)} \${interp(t)}%\`);
             })
             .style("opacity", 1);

  texts.exit()
       .transition()
       .duration(500)
       .style("opacity", 0)
       .remove();
}

function loadAndUpdate(monthKey) {
  selectedMonth.value = monthKey;
  const row = months.find(m => m.key === monthKey);
  if (!row) return;
  updateChartFromDaily(row.data);
}

onMounted(() => {
  svg = d3.select(svgRef.value);
  svg.selectAll("*").remove();  // 防呆清空

  g = svg.append("g")
         .attr("transform", \`translate(\${width/2}, \${height/2})\`);

  arcsGroup = g.append("g")
               .attr("class","arcs-group");
  labelsGroup = g.append("g")
                 .attr("class","labels-group");

  color = d3.scaleOrdinal()
            .domain(MEALS)
            .range(d3.schemeTableau10);

  const radius = Math.min(width, height)/2 - margin;

  pie = d3.pie().value(d => d.total).sort(null);

  arc = d3.arc()
          .innerRadius(0)
          .outerRadius(radius);
  outerArc = d3.arc()
               .innerRadius(radius - 10)
               .outerRadius(radius);

  // 建立可重複使用的tooltip
  tooltipEl = createTooltip(containerRef.value);

  // 初始繪製
  loadAndUpdate(selectedMonth.value);
});

onBeforeUnmount(() => {
  // 中斷過度動畫並移除tooltip
  d3.select(svgRef.value).selectAll("*").interrupt();
  d3.select(containerRef.value).selectAll(".d3-tooltip").remove();
});
<\/script>

<style scoped>
.btn-container {
  display: flex;
  gap: 6px;
  justify-content: center;
  margin-top: 8px;
}

.month-btn {
  padding: 6px 12px;
  font-size: 14px;
  border: 1px solid #dc3545;
  background: #fff;
  color: #dc3545;
  border-radius: 6px;
  cursor: pointer;
}

.month-btn:hover {
  background:#dc3545;
  color:#fff;
}

.active-month-btn {
  background:#e09500;
  color:#fff;
  border-color: #e09500;
}

.slice {
  transition: transform 0.12s ease;
  transform-origin: center;
  transform-box: fill-box;
}

.d3-tooltip {
  box-shadow: 0 6px 18px rgba(0, 0, 0, 0.12);
}
</style>`}}]}]},{id:"d3jsScatterChartNote",title:"散點圖",description:null,descriptionComponent:null,descriptionComponentStyle:null,lists:[{listTitle:"散佈圖／散點圖（Scatter Chart）",listSubtitle:null,listComponent:null,listCode:{htmlCode:null,jsCode:null,vueCode:null},listDetails:[{detailTitle:"一般的散點圖",detailSubtitle:"此為書本上的範例",detailComponent:t(()=>e(()=>import("./D3jsScatterChartDemo-kz9gApzt.js"),__vite__mapDeps([108,1,22,23,24,25,26,27,2,3,4,82,83,29,73,89]))),detailCode:{htmlCode:`<div id="basicScatterExample"></div>

<script>
  const basicScatterExample = async() => {
    const svgWidth = 600;
    const svgHeight = 400;
    const margin = 50;
    const dotRadius = 2;
    const svg = d3.select("#basicScatterExample")
                  .append("svg")
                  .attr("width", svgWidth)
                  .attr("height", svgHeight);

    // 取資料
    const url = "https://raw.githubusercontent.com/holtzy/data_to_viz/master/Example_dataset/2_TwoNum.csv";
    const data = await d3.csv(\`\${url}\`);

    // 建立X軸線
    const xScale = d3.scaleLinear()
                     .domain([0, 4000])
                     .range([ margin, svgWidth - margin ]);
    const xAxisGenerator = d3.axisBottom(xScale);

    svg.append("g")
       .attr("transform", \`translate(0, \${svgHeight - margin})\`)
       .call(xAxisGenerator);
      
    // 建立Y軸線
    const yScale = d3.scaleLinear()
                     .domain([0, 550000])
                     .range([svgHeight - margin, margin]);
    const yAxisGenerator = d3.axisLeft(yScale)
                             .tickFormat((d) => "$" + d);

    svg.append("g")
       .attr("transform", \`translate(\${margin}, 0)\`)
       .call(yAxisGenerator);

    // 加上點點
    svg.append("g")
       .selectAll("circle")
       .data(data)
       .join("circle")
       .attr("cx", (d) => xScale(d.GrLivArea))
       .attr("cy", (d) => yScale(d.SalePrice))
       .attr("r", dotRadius)
       .style("cursor", "pointer")
       .style("fill", (d) => d.SalePrice > 129000 ? "pink" : "#69b3a2")
       .on("mouseover", handleMouseOver)
       .on("mouseout", handleMouseOut);
    
    // mouseover時點點變色+tooltip
    function handleMouseOver(e) {
      d3.select(this)  // 選定this元素，改變hover時的顏色和形狀
        .style("fill", "orange")
        .attr("r", dotRadius * 2);

      const pt = d3.pointer(e, e.target);
      svg.append("text")
         .attr("class", "hoverTextInfo")
         .attr("x", pt[0] + 10)
         .attr("y", pt[1] - 10)
         .style("fill", "red")
         .text([\`GrLivArea: \${e.target.__data__.GrLivArea}, SalePrice: $\${e.target.__data__.SalePrice}\`]);
    };

    function handleMouseOut(e, d) {
      d3.selectAll(".hoverTextInfo").remove();
      d3.select(this)
        .style("fill", (d) => d.SalePrice > 129000 ? "pink" : "#69b3a2")
        .attr("r", dotRadius);
    };
  };
  basicScatterExample();
<\/script>`,jsCode:null,vueCode:`<template>
  <svg
    ref="basicScatterSvgRef"
    :width="width"
    :height="height"
  ></svg>
</template>

<script setup>
import { ref, onMounted } from "vue";
import * as d3 from "d3";

const basicScatterSvgRef = ref(null);

// 圖表尺寸與內邊距設定
const width = 600;
const height = width * 2/3;
const margin = 50;

const dotRadius = 2;

onMounted(async () => {
  const svg = d3.select(basicScatterSvgRef.value);
  
  // 取資料
  const url = "https://raw.githubusercontent.com/holtzy/data_to_viz/master/Example_dataset/2_TwoNum.csv";
  const data = await d3.csv(url);

  // 建立X軸線
  const xScale = d3.scaleLinear()
                   .domain([0, 4000])
                   .range([ margin, width - margin ]);
  const xAxisGenerator = d3.axisBottom(xScale);

  svg.append("g")
     .attr("transform", \`translate(0, \${height - margin})\`)
     .call(xAxisGenerator);
    
  // 建立Y軸線
  const yScale = d3.scaleLinear()
                   .domain([0, 550000])
                   .range([height - margin, margin]);
  const yAxisGenerator = d3.axisLeft(yScale)
                           .tickFormat((d) => "$" + d);

  svg.append("g")
     .attr("transform", \`translate(\${margin}, 0)\`)
     .call(yAxisGenerator);

  // 加上點點
  svg.append("g")
     .selectAll("circle")
     .data(data)
     .join("circle")
     .attr("cx", (d) => xScale(d.GrLivArea))
     .attr("cy", (d) => yScale(d.SalePrice))
     .attr("r", dotRadius)
     .style("cursor", "pointer")
     .style("fill", (d) => d.SalePrice > 129000 ? "pink" : "#69b3a2")
     .on("mouseover", handleMouseOver)
     .on("mouseout", handleMouseOut);
  
  // mouseover時點點變色+tooltip
  function handleMouseOver(e) {
    d3.select(this)  // 選定this元素，改變hover時的顏色和形狀
      .style("fill", "orange")
      .attr("r", dotRadius * 2);

    const pt = d3.pointer(e, e.target);
    svg.append("text")
       .attr("class", "hoverTextInfo")
       .attr("x", pt[0] + 10)
       .attr("y", pt[1] - 10)
       .style("fill", "red")
       .text([\`GrLivArea: \${e.target.__data__.GrLivArea}, SalePrice: $\${d3.format(",")(e.target.__data__.SalePrice)}\`]);
  };

  function handleMouseOut(e, d) {
    d3.selectAll(".hoverTextInfo").remove();
    d3.select(this)
      .style("fill", (d) => d.SalePrice > 129000 ? "pink" : "#69b3a2")
      .attr("r", dotRadius);
  };
});
<\/script>

<style scoped></style>`}},{detailTitle:"三張散點圖",detailSubtitle:"此為散佈圖練習，內容為「北北基桃區 112 年底人口數對三大黨的得票率」的散佈圖。",detailComponent:t(()=>e(()=>import("./D3jsThreeScatterChartsDemo-BwozaJHi.js"),__vite__mapDeps([109,1,110,22,23,24,25,26,27,28,2,3,4,82,83,29,73]))),detailCode:{htmlCode:`<div id="basicScatterPractice1" class="mt-1"></div>
<div id="basicScatterPractice2" class="mt-1"></div>
<div id="basicScatterPractice3" class="mt-1"></div>

<script>
  const basicScatterPractice = async (svgID, voteShareKey, colorKey) => {
    const width = 600;
    const height = 400;
    const margin = {top: 20, right: 20, bottom: 50, left: 63};
    const svg = d3.select(\`#\${svgID}\`)
                  .append("svg")
                  .attr("width", width)
                  .attr("height", height);
    const dotRadius = 3;
    const rawData = await d3.csv("data/PartyVoteShare2024/第11屆全國不分區及僑居國外國民立法委員選舉各政黨在北北基桃各投開票所得票數一覽表.csv");

    // 整理數據
    const voteShare = rawData.map((i) => d3.format(".4f")(i[voteShareKey]));  // 'd3.format(".4f")'這樣寫才會對array裡面每個元素做處理
    const population = rawData.filter((_, index) => index !== 61)  // 過濾掉第62橫列的數據
                              .map((i) => +i["人口數"]);

    // X軸
    const xScale = d3.scaleLinear()
                     .domain([0, d3.max(population) * 1.15])  // 乘1.15是怕tooltip超出svg範圍
                     .range([margin.left, width - margin.right])
                     .nice();
    const xScaleGenerator = d3.axisBottom(xScale);
    svg.append("g")
       .attr("transform", \`translate(0, \${height - margin.bottom})\`)
       .call(xScaleGenerator);

    // X軸標題
    svg.append("text")
       .attr("fill", "#000000")
       .attr("x", \`\${width - margin.right * 6}\`)
       .attr("y", \`\${height - margin.bottom / 6}\`)
       .text("人口數")
       .style("font-family", "sans-serif")
       .style("font-size", "14px");                                  

    // Y軸
    const yScale = d3.scaleLinear()
                     .domain([0, d3.max(voteShare)])
                     .range([height - margin.bottom, margin.top])
                     .nice();
                     
    const yScaleGenerator = d3.axisLeft(yScale);
    svg.append("g")
       .attr("transform", \`translate(\${margin.left}, 0)\`)
       .call(yScaleGenerator);

    // Y軸標題
    svg.append("text")
       .attr("fill", "#000000")
       .attr("x", \`\${margin.left / 4}\`)
       .attr("y", \`\${margin.top * 4}\`)
       .style("font-family", "sans-serif")
       .style("font-size", "14px")
       .selectAll("tspan")
       .data(voteShareKey.split(""))  // 將文字轉換成一個個字
       .join("tspan")
       .attr("x", \`\${margin.left / 6}\`)  // 確保每行的x座標都相同
       .attr("dy", "1.1em")  // 控制每行的間距
       .text(d => d)

    // 加上點點
    svg.append("g")
       .selectAll("circle")
       .data(rawData)
       .join("circle")
       .attr("cx", (d) => xScale(d["人口數"]))
       .attr("cy", (d) => yScale(d[voteShareKey]))
       .attr("r", dotRadius)
       .attr("fill", colorKey)
       .style("cursor", "pointer")
       .on("mouseover", handleMouseOver)
       .on("mouseout", handleMouseOut);

    let tooltip = d3.select("#basicScatterPractice1")
                    .style("position", "relative")
                    .append("div")
                    .attr("class", "basicScatterPractice1Tooltip")
                    .style("position", "absolute")
    
    function handleMouseOver(e) {
      // 移除現有的 tooltip，確保只有一個 tooltip 存在
      d3.select(".basicScatterPracticeTooltip").remove();

      // 點點變色
      d3.select(this)
        .attr("r", dotRadius * 2)
        .attr("fill", "black");

      let pt = d3.pointer(e, e.target);
      let tooltip = d3.select(\`#\${svgID}\`)
                      .style("position", "relative")
                      .append("div")
                      .attr("class", "basicScatterPracticeTooltip")
                      .style("position", "absolute")
                      .html(\`<p style="margin: 0;">
                        <strong>\${e.target.__data__["縣市"] + e.target.__data__["行政區"]}</strong><br>
                        2024一月人口數：\${e.target.__data__["人口數"]}<br>
                        \${voteShareKey}：\${d3.format(".4f")(e.target.__data__[voteShareKey]) * 100}%
                      </p>\`)
                      .style("left", \`\${((pt[0] + 10) < width) ? (pt[0] + 10) : (pt[0] - margin)}px\`)
                      .style("top", \`\${pt[1]}px\`)
                      .style("background-color", "#121212")
                      .style("color", "#f2f2f2")
                      .style("border", "#f2f2f2")
                      .style("border-radius", "8px")
                      .style("padding", "6px")
                      .style("font-family", "sans-serif")
                      .style("font-size", "12px")
                      .style("white-space", "nowrap")
                      .style("opacity", "0.85");
    };
    function handleMouseOut() {
      d3.select(this)
        .attr("r", dotRadius)
        .attr("fill", colorKey)
      d3.select(".basicScatterPracticeTooltip").remove();
    };
  };
  basicScatterPractice("basicScatterPractice1", "該行政區國民黨得票率", "#000095");
  basicScatterPractice("basicScatterPractice2", "該行政區民進黨得票率", "#1B9431");
  basicScatterPractice("basicScatterPractice3", "該行政區民眾黨得票率", "#28C8C8");
<\/script>`,jsCode:null,vueCode:`<template>
  <div ref="svgContainer1"></div>
  <div ref="svgContainer2"></div>
  <div ref="svgContainer3"></div>
</template>

<script setup>
import { ref, onMounted } from "vue";
import * as d3 from "d3";

// 使用Vite的"?url"，讓Vite回傳檔案URL字串，使後面d3.csv()可以使用來載入
import csvUrl from "../../../../assets/web-note-view/d3js-note-view/vote-share/第11屆全國不分區及僑居國外國民立法委員選舉各政黨在北北基桃各投開票所得票數一覽表.csv?url";

const svgContainer1 = ref(null);
const svgContainer2 = ref(null);
const svgContainer3 = ref(null);

// 圖表尺寸與內邊距設定
const width = 600;
const height = 400;
const margin = {top: 20, right: 20, bottom: 50, left: 63};
const dotRadius = 3;

async function voteShareScatter(container, voteShareKey, colorKey) {
  const svg = d3.select(container)
                .append("svg")
                .attr("width", width)
                .attr("height", height);
  const dotRadius = 3;
  const rawData = await d3.csv(csvUrl);

  // 整理數據
  const voteShare = rawData.map((i) => d3.format(".4f")(i[voteShareKey]));  // 'd3.format(".4f")'這樣寫才會對array裡面每個元素做處理
  const population = rawData.filter((d, index) => index !== 61)  // 過濾掉第62橫列的數據
                            .map((i) => +i["人口數"]);

  // X軸
  const xScale = d3.scaleLinear()
                   .domain([0, d3.max(population) * 1.15])  // 乘1.15是怕tooltip超出svg範圍
                   .range([margin.left, width - margin.right])
                   .nice();
  const xScaleGenerator = d3.axisBottom(xScale);
  svg.append("g")
     .attr("transform", \`translate(0, \${height - margin.bottom})\`)
     .call(xScaleGenerator);

  // X軸標題
  svg.append("text")
     .attr("fill", "#000000")
     .attr("x", \`\${width - margin.right * 6}\`)
     .attr("y", \`\${height - margin.bottom / 6}\`)
     .text("人口數")
     .style("font-family", "sans-serif")
     .style("font-size", "14px");                                  

  // Y軸
  const yScale = d3.scaleLinear()
                   .domain([0, d3.max(voteShare)])
                   .range([height - margin.bottom, margin.top])
                   .nice();
                   
  const yScaleGenerator = d3.axisLeft(yScale);
  svg.append("g")
     .attr("transform", \`translate(\${margin.left}, 0)\`)
     .call(yScaleGenerator);

  // Y軸標題
  svg.append("text")
     .attr("fill", "#000000")
     .attr("x", \`\${margin.left / 4}\`)
     .attr("y", \`\${margin.top * 4}\`)
     .style("font-family", "sans-serif")
     .style("font-size", "14px")
     .selectAll("tspan")
     .data(voteShareKey.split(""))  // 將文字轉換成一個個字
     .join("tspan")
     .attr("x", \`\${margin.left / 6}\`)  // 確保每行的x座標都相同
     .attr("dy", "1.1em")  // 控制每行的間距
     .text(d => d)

  // 加上點點
  svg.append("g")
     .selectAll("circle")
     .data(rawData)
     .join("circle")
     .attr("cx", (d) => xScale(d["人口數"]))
     .attr("cy", (d) => yScale(d[voteShareKey]))
     .attr("r", dotRadius)
     .attr("fill", colorKey)
     .style("cursor", "pointer")
     .on("mouseover", handleMouseOver)
     .on("mouseout", handleMouseOut);

  let tooltip = d3.select("#basicScatterPractice1")
                  .style("position", "relative")
                  .append("div")
                  .attr("class", "basicScatterPractice1Tooltip")
                  .style("position", "absolute")
  
  function handleMouseOver(e) {
    // 移除現有的 tooltip，確保只有一個 tooltip 存在
    d3.select(".basicScatterPracticeTooltip").remove();

    // 點點變色
    d3.select(this)
      .attr("r", dotRadius * 2)
      .attr("fill", "black");

    let pt = d3.pointer(e, e.target);
    let tooltip = d3.select(container)
                    .style("position", "relative")
                    .append("div")
                    .attr("class", "basicScatterPracticeTooltip")
                    .style("position", "absolute")
                    .html(\`<p style="margin: 0;">
                      <strong>\${e.target.__data__["縣市"] + e.target.__data__["行政區"]}</strong><br>
                      2024一月人口數：\${d3.format(",")(e.target.__data__["人口數"])}<br>
                      \${voteShareKey}：\${d3.format(".2f")(e.target.__data__[voteShareKey] * 100)}%
                    </p>\`)
                    .style("left", \`\${((pt[0] + 10) < width) ? (pt[0] + 10) : (pt[0] - margin)}px\`)
                    .style("top", \`\${pt[1]}px\`)
                    .style("background-color", "#121212")
                    .style("color", "#f2f2f2")
                    .style("border", "#f2f2f2")
                    .style("border-radius", "8px")
                    .style("padding", "6px")
                    .style("font-family", "sans-serif")
                    .style("font-size", "12px")
                    .style("white-space", "nowrap")
                    .style("opacity", "0.85");
  };
  function handleMouseOut() {
    d3.select(this)
      .attr("r", dotRadius)
      .attr("fill", colorKey)
    d3.select(".basicScatterPracticeTooltip").remove();
  };
};

onMounted(() => {
  voteShareScatter(svgContainer1.value, "該行政區國民黨得票率", "#000095");
  voteShareScatter(svgContainer2.value, "該行政區民進黨得票率", "#1B9431");
  voteShareScatter(svgContainer3.value, "該行政區民眾黨得票率", "#28C8C8");
});
<\/script>

<style scoped></style>`}},{detailTitle:"點擊後會新增點點的散佈圖",detailSubtitle:"透過點擊可以新增新的點。",detailComponent:t(()=>e(()=>import("./D3jsAddPointScatterChartDemo-CRzroDll.js"),__vite__mapDeps([111,1,22,23,24,25,26,27,28,2,3,4,29,73,89]))),detailCode:{htmlCode:`<div id="addPointScatter"></div>

<script>
  const width = 600;
  const height = 400;
  const margin = 50;
  const dotRadius = 2;
  const data = [
    { x: 100, y: 110 }, { x: 83, y: 43 }, { x: 92, y: 28 },
    { x: 49, y: 74 }, { x: 51, y: 10 }, { x: 25, y: 98 },
    { x: 77, y: 30}, { x: 20, y: 83 }, { x: 11, y: 63 },
    { x: 4, y: 55 }, { x: 0, y: 0 }, { x: 85, y: 100 },
    { x: 60, y: 40 }, { x: 70, y: 80 }, { x: 10,  y: 20 },
    { x: 40, y: 50 }, { x: 25, y: 31 }
  ];
  const svg = d3.select("#addPointScatter")
                .append("svg")
                .attr("width", width)
                .attr("height", height);

  // 建立X軸線
  const xScale = d3.scaleLinear()
                   .domain([0, d3.max(data, d => d.x)])
                   .range([margin, width - margin])
                   .nice();
  const xAxisGenerator = d3.axisBottom(xScale);
  svg.append("g")
     .attr("transform", \`translate(0, \${height - margin})\`)
     .call(xAxisGenerator);

  // 建立Y軸線
  const yScale = d3.scaleLinear()
                   .domain([0, (d3.max(data, d => d.y))])
                   .range([height - margin, margin])
                   .nice();
  const yAxisGenerator = d3.axisLeft(yScale);
  svg.append("g")
     .attr("transform", \`translate(\${margin}, 0)\`)
     .call(yAxisGenerator);

  // 加上點點
  svg.append("g")
     .selectAll("circle")
     .data(data)
     .join("circle")
     .attr("cx", (d) => xScale(d.x))
     .attr("cy", (d) => yScale(d.y))
     .attr("r", dotRadius)
     .attr("fill", "#121212")
     .on("mouseover", handleMouseOver)
     .on("mouseout", handleMouseOut);

  // mouseover時點點變色+tooltip
  function handleMouseOver(e) {
    d3.select(this)  // 選定this元素，改變hover時的顏色和形狀
      .style("fill", "orange")
      .attr("r", dotRadius * 2)
      .style("cursor", "pointer");

    let pt = d3.pointer(e, e.target);
    svg.append("text")
       .attr("class", "addPointScatterHoverTextInfo")
       .attr("x", pt[0] + 10)
       .attr("y", pt[1] - 10)
       .style("fill", "red")
       .text(\`x:\${e.target.__data__.x}, y:\${e.target.__data__.y}\`);
  };

  function handleMouseOut() {
    d3.selectAll(".addPointScatterHoverTextInfo").remove();
    d3.select(this)
      .style("fill", "#121212")
      .attr("r", dotRadius);
  };

  // 滑鼠click的時候增加一個點
  svg.on("click", (e) => {
    const coords = d3.pointer(e, e.target);
    const newData = {
      x: Math.round(xScale.invert(coords[0])),
      y: Math.round(yScale.invert(coords[1]))
    };  // 透過scale.invert()把XY像素位置轉換回座標資料值

    // 將增加的資料座標推入原本的data
    data.push(newData);

    // 將新的資料綁定上circle
    svg.selectAll("circle")
       .data(data)
       .join("circle")
       .attr("cx", (d) => xScale(d.x))
       .attr("cy", (d) => yScale(d.y))
       .attr("r", dotRadius)
       .attr("fill", "#121212")
       .on("mouseover", handleMouseOver)
       .on("mouseout", handleMouseOut);
  });
<\/script>`,jsCode:null,vueCode:`<template>
  <svg
    ref="addPointScatterSvgRef"
    :width="width"
    :height="height"
  ></svg>
</template>

<script setup>
import { ref, onMounted } from "vue";
import * as d3 from "d3";

const addPointScatterSvgRef = ref(null);

// 圖表尺寸與內邊距設定
const width = 600;
const height = 400;
const margin = 50;

const dotRadius = 2;

const data = [
  { x: 100, y: 110 }, { x: 83, y: 43 }, { x: 92, y: 28 },
  { x: 49, y: 74 }, { x: 51, y: 10 }, { x: 25, y: 98 },
  { x: 77, y: 30}, { x: 20, y: 83 }, { x: 11, y: 63 },
  { x: 4, y: 55 }, { x: 0, y: 0 }, { x: 85, y: 100 },
  { x: 60, y: 40 }, { x: 70, y: 80 }, { x: 10,  y: 20 },
  { x: 40, y: 50 }, { x: 25, y: 31 }
];

onMounted(() => {
  const svg = d3.select(addPointScatterSvgRef.value);

  // 建立X軸線
  const xScale = d3.scaleLinear()
                   .domain([0, d3.max(data, d => d.x)])
                   .range([margin, width - margin])
                   .nice();
  const xAxisGenerator = d3.axisBottom(xScale);
  svg.append("g")
     .attr("transform", \`translate(0, \${height - margin})\`)
     .call(xAxisGenerator);

  // 建立Y軸線
  const yScale = d3.scaleLinear()
                   .domain([0, (d3.max(data, d => d.y))])
                   .range([height - margin, margin])
                   .nice();
  const yAxisGenerator = d3.axisLeft(yScale);
  svg.append("g")
     .attr("transform", \`translate(\${margin}, 0)\`)
     .call(yAxisGenerator);

  // 加上點點
  svg.append("g")
     .selectAll("circle")
     .data(data)
     .join("circle")
     .attr("cx", (d) => xScale(d.x))
     .attr("cy", (d) => yScale(d.y))
     .attr("r", dotRadius)
     .attr("fill", "#121212")
     .on("mouseover", handleMouseOver)
     .on("mouseout", handleMouseOut);

  // mouseover時點點變色+tooltip
  function handleMouseOver(e) {
    d3.select(this)  // 選定this元素，改變hover時的顏色和形狀
      .style("fill", "orange")
      .attr("r", dotRadius * 2)
      .style("cursor", "pointer");

    let pt = d3.pointer(e, e.target);
    svg.append("text")
       .attr("class", "addPointScatterHoverTextInfo")
       .attr("x", pt[0] + 10)
       .attr("y", pt[1] - 10)
       .style("fill", "red")
       .text(\`x:\${e.target.__data__.x}, y:\${e.target.__data__.y}\`);
  };

  function handleMouseOut() {
    d3.selectAll(".addPointScatterHoverTextInfo").remove();
    d3.select(this)
      .style("fill", "#121212")
      .attr("r", dotRadius);
  };

  // 滑鼠click的時候增加一個點
  svg.on("click", (e) => {
    const coords = d3.pointer(e, e.target);
    const newData = {
      x: Math.round(xScale.invert(coords[0])),
      y: Math.round(yScale.invert(coords[1]))
    };  // 透過scale.invert()把XY像素位置轉換回座標資料值

    // 將增加的資料座標推入原本的data
    data.push(newData);

    // 將新的資料綁定上circle
    svg.selectAll("circle")
       .data(data)
       .join("circle")
       .attr("cx", (d) => xScale(d.x))
       .attr("cy", (d) => yScale(d.y))
       .attr("r", dotRadius)
       .attr("fill", "#121212")
       .on("mouseover", handleMouseOver)
       .on("mouseout", handleMouseOut);
  });
});
<\/script>

<style scoped></style>`}}]}]},{id:"d3jsBubbleChartNote",title:"氣泡圖",description:null,descriptionComponent:null,descriptionComponentStyle:null,lists:[{listTitle:"氣泡圖（Bubble Chart）",listSubtitle:null,listComponent:null,listCode:{htmlCode:null,jsCode:null,vueCode:null},listDetails:[{detailTitle:"氣泡圖（Bubble Chart）",detailSubtitle:"書本範例。橫軸為人均 GDP，縱軸為平均壽命，氣泡大小為人口數。",detailComponent:t(()=>e(()=>import("./D3jsBubbleChartDemo-CcMbqQMg.js"),__vite__mapDeps([112,1,22,23,24,25,26,27,28,79,31,2,3,4,82,83,29,87,78,73]))),detailCode:{htmlCode:`<div id="bubbleChartExample"></div>

<script>
  const drawBubbleChart = async () => {
    // 設定圖表大小
    const svgWidth = 600;
    const svgHeight = 400;
    const margin = {top: 20, right: 20, bottom: 30, left: 20};
    const chartWidth = svgWidth - margin.left - margin.right;
    const chartHeight = svgHeight - margin.top - margin.bottom;
    
    // 建立svg
    const svg = d3.select("#bubbleChartExample")
                  .append("svg")
                  .attr("width", svgWidth)
                  .attr("height", svgHeight);

    // 匯入資料
    const url = "https://raw.githubusercontent.com/holtzy/data_to_viz/master/Example_dataset/4_ThreeNum.csv";
    const data = await d3.csv(\`\${url}\`);

    // 整理X軸資料、Y軸資料、Z的人口數量資料
    const xData = data.map((d) => +d.gdpPercap);
    const yData = data.map((d) => +d.lifeExp);
    const zData = data.map((d) => +d.pop);

    // 建立X軸
    const xScale = d3.scaleLinear()
                     .domain([0, d3.max(xData)])
                     .range([margin.left, chartWidth])
                     .nice();
    const xAxisGenerator = d3.axisBottom(xScale);

    svg.append("g")
       .attr("transform", \`translate(0, \${margin.top + chartHeight})\`)
       .call(xAxisGenerator);

    // 建立Y軸
    const yScale = d3.scaleLinear()
                     .domain([0, d3.max(yData)])
                     .range([margin.top + chartHeight, margin.top])
                     .nice();
    const yAxisGenerator = d3.axisLeft(yScale);

    svg.append("g")
       .attr("transform", \`translate(\${margin.left}, 0)\`)
       .call(yAxisGenerator);

    // 氣泡(Z)的部分
    // 按照人口去設定氣泡大小的比例尺
    const radiusScale = d3.scaleLinear()
                          .domain([d3.min(zData), d3.max(zData)])
                          .range([4, 30]);

    // 設定氣泡顏色，本例根據不同洲來設定
    const bubbleColor = d3.scaleOrdinal()
                          .domain(["Asia", "Europe", "Americas", "Africa", "Oceania"])
                          .range(d3.schemeSet2);

    // 建立tooltip
    const tooltip = d3.select("#bubbleChartExample")
                      .style("position", "relative")
                      .append("div")
                      .style("position", "absolute")
                      .style("display", "none")
                      .attr("class", "dotsTooltip")
                      .style("background-color", "#121212")
                      .style("border-radius", "5px")
                      .style("padding", "10px")
                      .style("color", "#f2f2f2");

    // 綁定氣泡
    const bubble = svg.append("g")
                      .selectAll("circle")
                      .data(data)
                      .join("circle")
                      .attr("cx", (d) => xScale(d.gdpPercap))
                      .attr("cy", (d) => yScale(d.lifeExp))
                      .attr("r", (d) => radiusScale(d.pop))
                      .attr("fill", (d) => bubbleColor(d.continent))
                      .attr("opacity", 0.85)
                      .style("cursor", "pointer")
                      .on("mouseover", showTooltip)
                      .on("mousemove", moveTooltip)
                      .on("mouseleave", hideTooltip);

    // 設定顯示、移動、隱藏tooltips
    function showTooltip(e, d) {
      const pt = d3.pointer(e, e.target);

      // 設定tooltip樣式與呈現文字
      tooltip.style("display", "block")
             .html(\`<p>國家：\${d.country}</p>
                    <p>所屬洲：\${d.continent}</p>
                    <p>人口數：\${(+d.pop).toLocaleString()}</p>
                    <p>平均壽命：\${d.lifeExp}</p>
                    <p>人均GDP：\${d.gdpPercap}</p>\`)
             .style("left", \`\${pt[0] + 10}px\`)
             .style("top", \`\${pt[1] + 10}px\`);

      // 圓點強調
      d3.select(e.target)
        .attr("r", radiusScale(d.pop) + 5)
        .style("opacity", 0.7);
    };

    function moveTooltip(e) {
      const pt = d3.pointer(e, e.target);
      tooltip.style("display", "block")
             .style("left", \`\${pt[0] + 10}px\`)
             .style("top", \`\${pt[1] + 10}px\`);
    };

    function hideTooltip(e, d) {
      tooltip.style("display", "none");

      // 圓點復原
      d3.select(e.target)
        .attr("r", radiusScale(d.pop))
        .style("opacity", 0.85);
    };
  };
  drawBubbleChart();
<\/script>`,jsCode:null,vueCode:`<template>
  <div ref="bubbleChartRef"></div>
</template>

<script setup>
import { ref, onMounted } from "vue";
import * as d3 from "d3";

const bubbleChartRef = ref(null);

// 圖表尺寸與內邊距設定
const width = 600;
const height = 400;
const margin = {top: 20, right: 20, bottom: 30, left: 25};
const chartWidth = width - margin.left - margin.right;
const chartHeight = height - margin.top - margin.bottom;

onMounted(async () => {
  // 建立svg
  const svg = d3.select(bubbleChartRef.value)
                .style("position", "relative")
                .append("svg")
                .attr("width", width)
                .attr("height", height);

  // 匯入資料
  const url = "https://raw.githubusercontent.com/holtzy/data_to_viz/master/Example_dataset/4_ThreeNum.csv";
  const data = await d3.csv(\`\${url}\`);

  // 整理X軸資料、Y軸資料、Z的人口數量資料
  const xData = data.map((d) => +d.gdpPercap);
  const yData = data.map((d) => +d.lifeExp);
  const zData = data.map((d) => +d.pop);

  // 建立X軸
  const xScale = d3.scaleLinear()
                   .domain([0, d3.max(xData)])
                   .range([margin.left, chartWidth])
                   .nice();
  const xAxisGenerator = d3.axisBottom(xScale);

  svg.append("g")
     .attr("transform", \`translate(0, \${margin.top + chartHeight})\`)
     .call(xAxisGenerator);

  // 建立Y軸
  const yScale = d3.scaleLinear()
                   .domain([0, d3.max(yData)])
                   .range([margin.top + chartHeight, margin.top])
                   .nice();
  const yAxisGenerator = d3.axisLeft(yScale);

  svg.append("g")
     .attr("transform", \`translate(\${margin.left}, 0)\`)
     .call(yAxisGenerator);

  // 氣泡(Z)的部分
  // 按照人口去設定氣泡大小的比例尺
  const radiusScale = d3.scaleLinear()
                        .domain([d3.min(zData), d3.max(zData)])
                        .range([4, 30]);

  // 設定氣泡顏色，本例根據不同洲來設定
  const bubbleColor = d3.scaleOrdinal()
                        .domain(["Asia", "Europe", "Americas", "Africa", "Oceania"])
                        .range(d3.schemeSet2);

  // 建立tooltip
  const tooltip = d3.select(bubbleChartRef.value)
                    .append("div")
                    .style("position", "absolute")
                    .style("display", "none")
                    .attr("class", "dotsTooltip")
                    .style("background-color", "#121212")
                    .style("border-radius", "5px")
                    .style("padding", "10px")
                    .style("color", "#f2f2f2");

  // 綁定氣泡
  const bubble = svg.append("g")
                    .selectAll("circle")
                    .data(data)
                    .join("circle")
                    .attr("cx", (d) => xScale(d.gdpPercap))
                    .attr("cy", (d) => yScale(d.lifeExp))
                    .attr("r", (d) => radiusScale(d.pop))
                    .attr("fill", (d) => bubbleColor(d.continent))
                    .attr("opacity", 0.85)
                    .style("cursor", "pointer")
                    .on("mouseover", showTooltip)
                    .on("mousemove", moveTooltip)
                    .on("mouseleave", hideTooltip);

  // 設定顯示、移動、隱藏tooltips
  function showTooltip(e, d) {
    const pt = d3.pointer(e, e.target);

    // 設定tooltip樣式與呈現文字
    tooltip.style("display", "block")
           .html(\`<p>國家：\${d.country}</p>
                  <p>所屬洲：\${d.continent}</p>
                  <p>人口數：\${(+d.pop).toLocaleString()}</p>
                  <p>平均壽命：\${d.lifeExp}</p>
                  <p>人均GDP：\${d.gdpPercap}</p>\`)
           .style("left", \`\${pt[0] + 10}px\`)
           .style("top", \`\${pt[1] + 10}px\`);

    // 圓點強調
    d3.select(e.target)
      .attr("r", radiusScale(d.pop) + 5)
      .style("opacity", 0.7);
  };

  function moveTooltip(e) {
    const pt = d3.pointer(e, e.target);
    tooltip.style("display", "block")
           .style("left", \`\${pt[0] + 10}px\`)
           .style("top", \`\${pt[1] + 10}px\`);
  };

  function hideTooltip(e, d) {
    tooltip.style("display", "none");

    // 圓點復原
    d3.select(e.target)
      .attr("r", radiusScale(d.pop))
      .style("opacity", 0.85);
  };
});
<\/script>

<style scoped></style>`}},{detailTitle:"有按鈕可以切換的氣泡圖",detailSubtitle:"此為散佈圖練習，內容為「北北基桃區 112 年底人口數、三大黨的得票率、111 年底老年人口比例」的散佈圖。<br />- 註：基隆老年人口使用 110 年底資料、桃園老年人口使用 113 七月資料。",detailComponent:t(()=>e(()=>import("./D3jsSwitchBubbleChartsDemo-DUBzxzVu.js"),__vite__mapDeps([113,1,110,2,3,22,23,24,25,26,27,34,4,29,82,83,73,114]))),detailCode:{htmlCode:`<div id="bubbleChartPractice" class="mt-1"></div>
<button type="button" onclick="bubbleChartPractice('該行政區國民黨得票率', '#000095')" class="btn btn-primary">國民黨</button>
<button type="button" onclick="bubbleChartPractice('該行政區民進黨得票率', '#1B9431')" class="btn btn-success">民進黨</button>
<button type="button" onclick="bubbleChartPractice('該行政區民眾黨得票率', '#28C8C8')" class="btn btn-info" style="color: #ffffff;">民眾黨</button>
<button type="button" onclick="bubbleChartPracticeAll()" class="btn btn-outline-danger">一起看</button>

<script>
  const width = 600;
  const height = 400;
  const margin = {top: 20, right: 20, bottom: 50, left: 63};
  const svg = d3.select("#bubbleChartPractice")
                .append("svg")
                .attr("width", width)
                .attr("height", height);

  // X軸
  const xScale = d3.scaleLinear()
                   .domain([0, 600000])
                   .range([margin.left, width - margin.right])
                   .nice();
  const xAxisGenerator = d3.axisBottom(xScale);
  svg.append("g")
     .attr("transform", \`translate(0, \${height - margin.bottom})\`)
     .call(xAxisGenerator);

  // Y軸
  const yScale = d3.scaleLinear()
                   .domain([0, 0.5])
                   .range([height - margin.bottom, margin.top])
                   .nice();

  const yAxisGenerator = d3.axisLeft(yScale);
  svg.append("g")
     .attr("transform", \`translate(\${margin.left}, 0)\`)
     .call(yAxisGenerator);

  // X軸標題（由於X軸標題與政黨無關，不需重繪，所以放在'bubbleChartPractice()'外）
  svg.append("text")
     .attr("id", "bubbleChartXTitle")
     .attr("fill", "#000000")
     .attr("x", \`\${width - margin.right * 6}\`)
     .attr("y", \`\${height - margin.bottom / 6}\`)
     .text("人口數")
     .style("font-family", "sans-serif")
     .style("font-size", "14px");  

  const bubbleChartPractice = async (voteShareKey, colorKey) => {
    // 先移除舊的圖形內容
    svg.selectAll("#bubbleChartYTitle").transition().duration(300).style("opacity", "0").remove();
    svg.selectAll("circle").transition().duration(1000).attr("r", 0).remove();
  
    // 整理數據
    const res = await d3.csv("data/PartyVoteShare2024/第11屆全國不分區及僑居國外國民立法委員選舉各政黨在北北基桃各投開票所得票數一覽表.csv");
    const data = res.filter((_, index) => index !== 61)  // 過濾掉第62橫列的數據;
    const xData = res.map((d) => +d["人口數"]);
    const yData = res.map((d) => d3.format(".4f")(+d[voteShareKey]));
    const zData = res.map((d) => (+d["一一一年底老年人口數"])/(+d["人口數"]));
  
    // z比例尺
    const zScale = d3.scaleLinear()
                     .domain(d3.extent(zData))
                     .range([0.5, 15]);
  
    // Y軸標題
    svg.append("text")
       .attr("id", "bubbleChartYTitle")
       .attr("fill", "#000000")
       .attr("x", \`\${margin.left / 4}\`)
       .attr("y", \`\${margin.top * 4}\`)
       .style("font-family", "sans-serif")
       .style("font-size", "14px")
       .selectAll("tspan")
       .data(("該行政區" + voteShareKey.substring(4, 7) + "得票率").split(""))  // 將文字轉換成一個個字
       .join("tspan")
       .attr("x", \`\${margin.left / 6}\`)  // 確保每行的x座標都相同
       .attr("dy", "1.1em")  // 控制每行的間距
       .text(d => d)
       .style("opacity", 0)
       .transition()
       .duration(200)
       .style("opacity", 1);
  
    // 加上點點
    const dots = svg.append("g")
                    .selectAll("circle")
                    .data(data)
                    .join("circle")
                    .attr("cx", (d) => xScale(d["人口數"]))
                    .attr("cy", (d) => yScale(d[voteShareKey]))
                    .attr("fill", colorKey)
                    .style("cursor", "pointer")
                    .style("opacity", 0.8)
                    .on("mouseover", handleMouseOver)
                    .on("mouseout", handleMouseOut)
                    .transition()
                    .duration(1000)
                    .attr("r", (d) => parseFloat(zScale(+d["一一一年底老年人口數"])/(+d["人口數"])));
  
    const tooltip = d3.select("#bubbleChartPractice")
                      .style("position", "relative")
                      .append("div")
                      .style("position", "absolute")
                      .style("display", "none")
                      .style("background-color", "#121212")
                      .style("color", "#f2f2f2")
                      .style("border", "#f2f2f2")
                      .style("border-radius", "8px")
                      .style("padding", "6px")
                      .style("font-family", "sans-serif")
                      .style("font-size", "12px")
                      .style("white-space", "nowrap")
                      .style("opacity", "0.85");

    function handleMouseOver(e) {
      // 點點變色
      d3.select(this)
        .attr("r", (d) => parseFloat(zScale(+d["一一一年底老年人口數"])/(+d["人口數"])) + 8)
        .attr("fill", "black")
        .style("opacity", 0.8);
    
      let pt = d3.pointer(e, e.target);
      tooltip.style("display", "block")
             .html(\`<p style="margin: 0;">
               <strong>\${e.target.__data__["縣市"] + e.target.__data__["行政區"]}</strong><br>
               2024一月人口數：\${(e.target.__data__["人口數"]).toLocaleString()}<br>
               \${voteShareKey}：\${d3.format(".4f")(e.target.__data__[voteShareKey]) * 100}%
             </p>\`)
             .style("left", \`\${((pt[0] + 10) < width) ? (pt[0] + 10) : (pt[0] - margin.right * 40)}px\`)
             .style("top", \`\${pt[1]}px\`);
    };

    function handleMouseOut() {
      d3.select(this)
        .attr("r", (d) => parseFloat(zScale(+d["一一一年底老年人口數"])/(+d["人口數"])))
        .attr("fill", colorKey)
      tooltip.style("display", "none");
    };
  };
  bubbleChartPractice("該行政區國民黨得票率", "#000095");

  const bubbleChartPracticeAll = async () => {
    // 移除舊的圖形內容
    svg.selectAll("#bubbleChartYTitle").transition().duration(300).style("opacity", "0").remove();
    svg.selectAll("circle").transition().duration(1000).attr("r", 0).remove();
  
    // 讀取並整理數據
    const res = await d3.csv("data/PartyVoteShare2024/第11屆全國不分區及僑居國外國民立法委員選舉各政黨在北北基桃各投開票所得票數一覽表.csv");
    const data = res.filter((_, index) => index !== 61);  // 過濾掉第62橫列的數據;
    const zData = res.map((d) => (+d["一一一年底老年人口數"])/(+d["人口數"]));
    const zScale = d3.scaleLinear()
                     .domain(d3.extent(zData))
                     .range([0.5, 15]);
  
    // 定義顏色
    const colors = {
      "該行政區國民黨得票率": "#000095",
      "該行政區民進黨得票率": "#1B9431",
      "該行政區民眾黨得票率": "#28C8C8"
    };
  
    // Y軸標題
    svg.append("text")
       .attr("id", "bubbleChartYTitle")
       .attr("fill", "#000000")
       .attr("x", \`\${margin.left / 4}\`)
       .attr("y", \`\${margin.top * 4}\`)
       .style("font-family", "sans-serif")
       .style("font-size", "14px")
       .selectAll("tspan")
       .data(("該行政區三大黨得票率").split(""))  // 將文字轉換成一個個字
       .join("tspan")
       .attr("x", \`\${margin.left / 6}\`)  // 確保每行的x座標都相同
       .attr("dy", "1.1em")  // 控制每行的間距
       .text(d => d)
       .style("opacity", 0)
       .transition()
       .duration(200)
       .style("opacity", 1);
  
    // 加上點點
    Object.keys(colors).forEach((voteShareKey) => {
      svg.append("g")
         .selectAll("circle")
         .data(data)
         .join("circle")
         .attr("cx", (d) => xScale(d["人口數"]))
         .attr("cy", (d) => yScale(d[voteShareKey]))
         .attr("fill", colors[voteShareKey])
         .attr("data-vote-key", voteShareKey)  // 存儲與該圓圈相關的投票率鍵
         .style("cursor", "pointer")
         .style("opacity", 0.8)
         .on("mouseover", handleMouseOver)
         .on("mouseout", handleMouseOut)
         .transition()
         .duration(1000)
         .attr("r", (d) => parseFloat(zScale(+d["一一一年底老年人口數"])/(+d["人口數"])));
    });
  
    const tooltip = d3.select("#bubbleChartPractice")
                      .style("position", "relative")
                      .append("div")
                      .style("position", "absolute")
                      .style("display", "none")
                      .style("background-color", "#121212")
                      .style("color", "#f2f2f2")
                      .style("border", "#f2f2f2")
                      .style("border-radius", "8px")
                      .style("padding", "6px")
                      .style("font-family", "sans-serif")
                      .style("font-size", "12px")
                      .style("white-space", "nowrap")
                      .style("opacity", "0.85");
  
    function handleMouseOver(e) {
      const voteShareKey = d3.select(this).attr("data-vote-key");  // 從data-*屬性中取出voteShareKey
    
      d3.select(this)
        .attr("r", (d) => parseFloat(zScale(+d["一一一年底老年人口數"])/(+d["人口數"])) + 8)
        .attr("fill", "black")
        .style("opacity", 0.8);

      let pt = d3.pointer(e, e.target);
      tooltip.style("display", "block")
             .html(\`<p style="margin: 0;">
                <strong>\${e.target.__data__["縣市"] + e.target.__data__["行政區"]}</strong><br>
                2024一月人口數：\${(e.target.__data__["人口數"]).toLocaleString()}<br>
                \${voteShareKey}：\${d3.format(".4f")(e.target.__data__[voteShareKey]) * 100}%
              </p>\`)
             .style("left", \`\${((pt[0] + 10) < width) ? (pt[0] + 10) : (pt[0] - margin.right * 40)}px\`)
             .style("top", \`\${pt[1]}px\`);
    };
  
    function handleMouseOut() {
      const voteShareKey = d3.select(this).attr("data-vote-key");  // 從data-*屬性中取出voteShareKey
    
      d3.select(this)
        .attr("r", (d) => parseFloat(zScale(+d["一一一年底老年人口數"])/(+d["人口數"])))
        .attr("fill", colors[voteShareKey]);
      tooltip.style("display", "none");
    };
  };
<\/script>`,jsCode:null,vueCode:`<template>
  <div ref="svgContainerRef"></div>
  <div class="btn-container" :style="{ 'width': width + 'px'}">
    <button type="button" @click="bubbleChartPractice('該行政區國民黨得票率', '#000095')" class="kmt-btn">國民黨</button>
    <button type="button" @click="bubbleChartPractice('該行政區民進黨得票率', '#1b9431')" class="dpp-btn">民進黨</button>
    <button type="button" @click="bubbleChartPractice('該行政區民眾黨得票率', '#28c8c8')" class="tpp-btn">民眾黨</button>
    <button type="button" @click="bubbleChartPracticeAll" class="all-btn">一起看</button>
  </div>
</template>

<script setup>
import { ref, onMounted } from "vue";
import * as d3 from "d3";

import csvData from "../../../../assets/web-note-view/d3js-note-view/vote-share/第11屆全國不分區及僑居國外國民立法委員選舉各政黨在北北基桃各投開票所得票數一覽表.csv?url";

const svgContainerRef = ref(null);

// 圖表尺寸與內邊距設定
const width = 600;
const height = 400;
const margin = {top: 20, right: 20, bottom: 50, left: 63};

let svg, xScale, yScale;

onMounted(() => {
  svg = d3.select(svgContainerRef.value)
          .append("svg")
          .attr("width", width)
          .attr("height", height);

  // X軸
  xScale = d3.scaleLinear()
             .domain([0, 600000])
             .range([margin.left, width - margin.right])
             .nice();
  const xAxisGenerator = d3.axisBottom(xScale);
  svg.append("g")
     .attr("transform", \`translate(0, \${height - margin.bottom})\`)
     .call(xAxisGenerator);

  // Y軸
  yScale = d3.scaleLinear()
             .domain([0, 0.5])
             .range([height - margin.bottom, margin.top])
             .nice();
  const yAxisGenerator = d3.axisLeft(yScale);
  svg.append("g")
     .attr("transform", \`translate(\${margin.left}, 0)\`)
     .call(yAxisGenerator);

  // X軸標題（由於X軸標題與政黨無關，不需重繪，所以放在'bubbleChartPractice()'外）
  svg.append("text")
     .attr("class", "bubbleChartXTitle")
     .attr("fill", "#000000")
     .attr("x", \`\${width - margin.right * 6}\`)
     .attr("y", \`\${height - margin.bottom / 6}\`)
     .text("人口數")
     .style("font-family", "sans-serif")
     .style("font-size", "14px");

  // 預設顯示國民黨
  bubbleChartPractice("該行政區國民黨得票率", "#000095");
});

// 畫單一政黨圖
const bubbleChartPractice = async (voteShareKey, colorKey) => {
  // 先移除舊的圖形內容
  svg.selectAll(".bubbleChartYTitle").transition().duration(300).style("opacity", "0").remove();
  svg.selectAll("circle").transition().duration(1000).attr("r", 0).remove();

  // 整理數據
  const res = await d3.csv(csvData);
  const data = res.filter((_, index) => index !== 61)  // 過濾掉第62橫列的數據;
  const xData = res.map((d) => +d["人口數"]);
  const yData = res.map((d) => d3.format(".4f")(+d[voteShareKey]));
  const zData = res.map((d) => ( +d["一一一年底老年人口數"] / +d["人口數"] ));

  // z比例尺
  const zScale = d3.scaleLinear()
                   .domain(d3.extent(zData))
                   .range([1, 25]);

  // Y軸標題
  svg.append("text")
     .attr("class", "bubbleChartYTitle")
     .attr("fill", "#000000")
     .attr("x", \`\${margin.left / 4}\`)
     .attr("y", \`\${margin.top * 4}\`)
     .style("font-family", "sans-serif")
     .style("font-size", "14px")
     .selectAll("tspan")
     .data(("該行政區" + voteShareKey.substring(4, 7) + "得票率").split(""))  // 將文字轉換成一個個字
     .join("tspan")
     .attr("x", \`\${margin.left / 6}\`)  // 確保每行的x座標都相同
     .attr("dy", "1.1em")  // 控制每行的間距
     .text(d => d)
     .style("opacity", 0)
     .transition()
     .duration(200)
     .style("opacity", 1);

  // 加上點點
  const dots = svg.append("g")
                  .selectAll("circle")
                  .data(data)
                  .join("circle")
                  .attr("cx", (d) => xScale(d["人口數"]))
                  .attr("cy", (d) => yScale(d[voteShareKey]))
                  .attr("fill", colorKey)
                  .style("cursor", "pointer")
                  .style("opacity", 0.8)
                  .on("mouseover", handleMouseOver)
                  .on("mouseout", handleMouseOut)
                  .transition()
                  .duration(1000)
                  .attr("r", (d) => parseFloat(zScale( +d["一一一年底老年人口數"] / +d["人口數"] )));

  const tooltip = d3.select(svgContainerRef.value)
                    .style("position", "relative")
                    .append("div")
                    .style("position", "absolute")
                    .style("display", "none")
                    .style("background-color", "#121212")
                    .style("color", "#f2f2f2")
                    .style("border", "#f2f2f2")
                    .style("border-radius", "8px")
                    .style("padding", "6px")
                    .style("font-family", "sans-serif")
                    .style("font-size", "12px")
                    .style("white-space", "nowrap")
                    .style("opacity", "0.85");

  function handleMouseOver(e) {
    // 點點變色
    d3.select(this)
      .attr("r", (d) => parseFloat(zScale( +d["一一一年底老年人口數"] / +d["人口數"] )) + 8)
      .attr("fill", "black")
      .style("opacity", 0.8);
  
    let pt = d3.pointer(e, e.target);
    tooltip.style("display", "block")
           .html(\`<p style="margin: 0;">
             <strong>\${e.target.__data__["縣市"] + e.target.__data__["行政區"]}</strong><br>
             2024一月人口數：\${d3.format(",")(e.target.__data__["人口數"])} 人<br>
             老年人口比例：\${d3.format(".4f")(+e.target.__data__["一一一年底老年人口數"] / +e.target.__data__["人口數"] * 100)}%<br>
             \${voteShareKey}：\${d3.format(".2f")(e.target.__data__[voteShareKey] * 100)}%
           </p>\`)
           .style("left", \`\${((pt[0] + 10) < width) ? (pt[0] + 10) : (pt[0] - margin.right * 40)}px\`)
           .style("top", \`\${pt[1]}px\`);
  };

  function handleMouseOut() {
    d3.select(this)
      .attr("r", (d) => parseFloat(zScale( +d["一一一年底老年人口數"] / +d["人口數"] )))
      .attr("fill", colorKey)
    tooltip.style("display", "none");
  };
};

const bubbleChartPracticeAll = async () => {
  // 移除舊的圖形內容
  svg.selectAll(".bubbleChartYTitle").transition().duration(300).style("opacity", "0").remove();
  svg.selectAll("circle").transition().duration(1000).attr("r", 0).remove();

  // 讀取並整理數據
  const res = await d3.csv(csvData);
  const data = res.filter((d, index) => index !== 61);  // 過濾掉第62橫列的數據;
  const zData = res.map((d) => ( +d["一一一年底老年人口數"] / +d["人口數"] ));
  const zScale = d3.scaleLinear()
                   .domain(d3.extent(zData))
                   .range([1, 25]);

  // 定義顏色
  const colors = {
    "該行政區國民黨得票率": "#000095",
    "該行政區民進黨得票率": "#1B9431",
    "該行政區民眾黨得票率": "#28C8C8"
  };

  // Y軸標題
  svg.append("text")
     .attr("class", "bubbleChartYTitle")
     .attr("fill", "#000000")
     .attr("x", \`\${margin.left / 4}\`)
     .attr("y", \`\${margin.top * 4}\`)
     .style("font-family", "sans-serif")
     .style("font-size", "14px")
     .selectAll("tspan")
     .data(("該行政區三大黨得票率").split(""))  // 將文字轉換成一個個字
     .join("tspan")
     .attr("x", \`\${margin.left / 6}\`)  // 確保每行的x座標都相同
     .attr("dy", "1.1em")  // 控制每行的間距
     .text(d => d)
     .style("opacity", 0)
     .transition()
     .duration(200)
     .style("opacity", 1);

  // 加上點點
  Object.keys(colors).forEach((voteShareKey) => {
    svg.append("g")
       .selectAll("circle")
       .data(data)
       .join("circle")
       .attr("cx", (d) => xScale(d["人口數"]))
       .attr("cy", (d) => yScale(d[voteShareKey]))
       .attr("fill", colors[voteShareKey])
       .attr("data-vote-key", voteShareKey)  // 存儲與該圓圈相關的投票率鍵
       .style("cursor", "pointer")
       .style("opacity", 0.8)
       .on("mouseover", handleMouseOver)
       .on("mouseout", handleMouseOut)
       .transition()
       .duration(1000)
       .attr("r", (d) => parseFloat(zScale( +d["一一一年底老年人口數"] / +d["人口數"] )));
  });

  const tooltip = d3.select(svgContainerRef.value)
                    .style("position", "relative")
                    .append("div")
                    .style("position", "absolute")
                    .style("display", "none")
                    .style("background-color", "#121212")
                    .style("color", "#f2f2f2")
                    .style("border", "#f2f2f2")
                    .style("border-radius", "8px")
                    .style("padding", "6px")
                    .style("font-family", "sans-serif")
                    .style("font-size", "12px")
                    .style("white-space", "nowrap")
                    .style("opacity", "0.85");

  function handleMouseOver(e) {
    const voteShareKey = d3.select(this).attr("data-vote-key");  // 從data-*屬性中取出voteShareKey
  
    d3.select(this)
      .attr("r", (d) => parseFloat(zScale(+d["一一一年底老年人口數"] / +d["人口數"])) + 8)
      .attr("fill", "black")
      .style("opacity", 0.8);

    let pt = d3.pointer(e, e.target);
    tooltip.style("display", "block")
           .html(\`<p style="margin: 0;">
              <strong>\${e.target.__data__["縣市"] + e.target.__data__["行政區"]}</strong><br>
              2024一月人口數：\${d3.format(",")(e.target.__data__["人口數"])}<br>
              老年人口比例：\${d3.format(".4f")(+e.target.__data__["一一一年底老年人口數"] / +e.target.__data__["人口數"] * 100)}%<br>
              \${voteShareKey}：\${d3.format(".2f")(e.target.__data__[voteShareKey] * 100)}%
            </p>\`)
           .style("left", \`\${((pt[0] + 10) < width) ? (pt[0] + 10) : (pt[0] - margin.right * 40)}px\`)
           .style("top", \`\${pt[1]}px\`);
  };

  function handleMouseOut() {
    const voteShareKey = d3.select(this).attr("data-vote-key");  // 從data-*屬性中取出voteShareKey
  
    d3.select(this)
      .attr("r", (d) => parseFloat(zScale( +d["一一一年底老年人口數"] / +d["人口數"] )))
      .attr("fill", colors[voteShareKey]);
    tooltip.style("display", "none");
  };
};
<\/script>

<style scoped>
.btn-container {
  display: flex;
  gap: 5px;
  justify-content: center;
}

.kmt-btn {
  padding: 6px 12px 6px 12px;
  font-size: 16px;
  font-weight: 400;
  font-family: inherit;
  line-height: 1.5;
  color: #000095;
  background-color: #ffffff;
  border: 1px solid #000095;
  border-radius: 6px;
  cursor: pointer;
  transition:
    color 0.15s ease-in-out,
    background-color 0.15s ease-in-out,
    border-color 0.15s ease-in-out;
}

.kmt-btn:hover {
  color: #ffffff;
  background-color: #000095;
  border-color: #000095;
}

.dpp-btn {
  padding: 6px 12px 6px 12px;
  font-size: 16px;
  font-weight: 400;
  font-family: inherit;
  line-height: 1.5;
  color: #1b9431;
  background-color: #ffffff;
  border: 1px solid #1b9431;
  border-radius: 6px;
  cursor: pointer;
  transition:
    color 0.15s ease-in-out,
    background-color 0.15s ease-in-out,
    border-color 0.15s ease-in-out;
}

.dpp-btn:hover {
  color: #ffffff;
  background-color: #1b9431;
  border-color: #1b9431;
}

.tpp-btn {
  padding: 6px 12px 6px 12px;
  font-size: 16px;
  font-weight: 400;
  font-family: inherit;
  line-height: 1.5;
  color: #28c8c8;
  background-color: #ffffff;
  border: 1px solid #28c8c8;
  border-radius: 6px;
  cursor: pointer;
  transition:
    color 0.15s ease-in-out,
    background-color 0.15s ease-in-out,
    border-color 0.15s ease-in-out;
}

.tpp-btn:hover {
  color: #ffffff;
  background-color: #28c8c8;
  border-color: #28c8c8;
}

.all-btn {
  padding: 6px 12px 6px 12px;
  font-size: 16px;
  font-weight: 400;
  font-family: inherit;
  line-height: 1.5;
  color: #dc3535;
  background-color: #ffffff;
  border: 1px solid #dc3535;
  border-radius: 6px;
  cursor: pointer;
  transition:
    color 0.15s ease-in-out,
    background-color 0.15s ease-in-out,
    border-color 0.15s ease-in-out;
}

.all-btn:hover {
  color: #ffffff;
  background-color: #dc3535;
  border-color: #dc3535;
}
</style>`}}]}]},{id:"d3jsBarChartNote",title:"長條圖",description:null,descriptionComponent:null,descriptionComponentStyle:null,lists:[{listTitle:"長條圖（Bar Chart）",listSubtitle:"（一般長條圖、複數長條圖、堆疊長條圖）",listComponent:null,listCode:{htmlCode:null,jsCode:null,vueCode:null},listDetails:[{detailTitle:"基礎長條圖",detailSubtitle:"書本範例。橫軸為縣市，縱軸為各縣市合計售電量（單位：度）。",detailComponent:t(()=>e(()=>import("./D3jsBarChartDemo-DLx_3KKX.js"),__vite__mapDeps([115,1,2,3,44,26,31,45,22,23,24,25,27,28,4,29,82,83,116]))),detailCode:{htmlCode:`<div id="barChartExample"></div>
<div id="barChartExampleBtnWrap">
  <button id="barChartExampleApril2024Btn" class="btn btn-outline-warning" onclick="updataElectricChart('../data/taipowerData/202404.csv')">2024 4月</button>
  <button id="barChartExampleMay2024Btn" class="btn btn-outline-warning" onclick="updataElectricChart('../data/taipowerData/202405.csv')">2024 5月</button>
  <button id="barChartExampleJune2024Btn" class="btn btn-outline-warning" onclick="updataElectricChart('../data/taipowerData/202406.csv')">2024 6月</button>
</div>

<script>
  // 建立svg
  const width = 750;
  const height = 500;
  const margin = {top: 40, right: 40, bottom: 40, left: 80};
  const svg = d3.select("#barChartExample")
                .append("svg")
                .attr("width", width)
                .attr("height", height);

  // 建立初始X軸
  const xScale = d3.scaleBand()
                   .range([margin.left, width - margin.right])
                   .padding(0.2);
  const xAxisGenerator = d3.axisBottom(xScale);
  const xAxis = svg.append("g")
                   .attr("transform", \`translate(0, \${height - margin.bottom})\`);

  // 建立初始Y軸
  const yScale = d3.scaleLinear()
                   .range([height - margin.bottom, margin.top]);
  const yAxisGenerator = d3.axisLeft(yScale)
                           .ticks(5)
                           .tickSize(3);
  const yAxis = svg.append("g")
                   .attr("transform", \`translate(\${margin.left}, 0)\`);

  // 取得資料
  const updataElectricChart = async (url) => {
    const data = await d3.csv(url);
    // map資料集
    const xData = data.map((i) => i["縣市"]);
    const yData = data.map((i) => parseInt(i["合計售電量_度"].split(",").join("")));  // 用'parseInt(目標.split(",").join(""))'消去數字裡三位的逗號，並轉成數值

    // 設定X軸Domain、建立X軸
    xScale.domain(xData);
    xAxis.transition().duration(1000).call(xAxisGenerator);

    // 調整X軸刻度文字標籤傾斜
    xAxis.selectAll("text")
         .attr("transform", "translate(-10, 0) rotate(-45)")
         .style("text-anchor", "end");

    // 設定Y軸Domain、建立Y軸
    yScale.domain([0, d3.max(yData)]).nice();
    yAxis.transition().duration(1000).call(yAxisGenerator);

    // 開始建立長條圖
    const bar = svg.selectAll("rect")
                   .data(data)
                   .join("rect")
                   .attr("x", d => xScale(d["縣市"]))
                   .attr("width", xScale.bandwidth())
                   .attr("fill", "#69b3a2");

    // 加上漸增動畫
    // 注意：如果要加動畫，事件要分開寫
    bar.transition()
       .duration(1000)
       .attr("y", d => yScale(parseInt(d["合計售電量_度"].split(",").join(""))))
       .attr("height", d => ( height - margin.bottom) - yScale(parseInt(d["合計售電量_度"].split(",").join(""))));

    // 加上滑鼠事件
    bar.style("cursor", "pointer")
       .on("mouseover", handleMouseOver)
       .on("mouseleave", handleMouseLeave);

    function handleMouseOver(e) {
      d3.select(this).attr("fill", "#f68b47");

      // 加上文字標籤
      svg.append("text")
         .attr("class", "d3jsBarChartInfoText")
         .attr("x", xScale(e.target.__data__["縣市"]))
         .attr("y", yScale(parseInt(e.target.__data__["合計售電量_度"].split(",").join(""))))
         .style("fill", "#121212")
         .style("font-size", "18px")
         .style("font-weight", "bold")
         .style("text-anchor", "middle")
         .text(e.target.__data__["合計售電量_度"] + "度");
    };

    function handleMouseLeave() {
      d3.select(this).attr("fill", "#69b3a2");
      svg.select(".d3jsBarChartInfoText").remove();
    };
  };
  updataElectricChart("../data/taipowerData/202404.csv");
<\/script>`,jsCode:null,vueCode:`<template>
  <div ref="barChartContainerRef"></div>
  <div class="btn-container">
    <button
      type="button"
      v-for="(btn, index) in buttons"
      :key="index"
      @click="updateElectricChart(btn.file)"
      class="month-button"
    >
      {{ btn.label }}
    </button>
  </div>
</template>

<script setup>
import { ref, onMounted } from "vue";
import * as d3 from "d3";

import file202404 from "../../../../assets/web-note-view/d3js-note-view/taipower-data/202404.csv?url";
import file202405 from "../../../../assets/web-note-view/d3js-note-view/taipower-data/202405.csv?url";
import file202406 from "../../../../assets/web-note-view/d3js-note-view/taipower-data/202406.csv?url";

const barChartContainerRef = ref(null);

// 圖表尺寸與內邊距設定
const width = 600;
const height = 400;
const margin = {top: 40, right: 40, bottom: 40, left: 80};

const buttons = [
  { label: "2024 4月", file: file202404 },
  { label: "2024 5月", file: file202405 },
  { label: "2024 6月", file: file202406 },
];

let svg, xScale, yScale, xAxisGenerator, yAxisGenerator, xAxis, yAxis;

const initChart = () => {
  svg = d3.select(barChartContainerRef.value)
          .append("svg")
          .attr("width", width)
          .attr("height", height);

  // 建立初始X軸
  xScale = d3.scaleBand()
             .range([margin.left, width - margin.right])
             .padding(0.2);
  xAxisGenerator = d3.axisBottom(xScale)
                     .tickSizeOuter(0);
  xAxis = svg.append("g")
             .attr("transform", \`translate(0, \${height - margin.bottom})\`);

  // 建立初始Y軸
  yScale = d3.scaleLinear()
             .range([height - margin.bottom, margin.top]);
  yAxisGenerator = d3.axisLeft(yScale)
                     .ticks(5)
                     .tickSize(3)
                     .tickSizeOuter(0);
  yAxis = svg.append("g")
             .attr("transform", \`translate(\${margin.left}, 0)\`);
};

const updateElectricChart = async (csvData) => {
  const data = await d3.csv(csvData);
  // map資料集
  const xData = data.map((i) => i["縣市"]);
  const yData = data.map((i) => parseInt(i["合計售電量_度"].split(",").join("")));  // 用'parseInt(目標.split(",").join(""))'消去數字裡三位的逗號，並轉成數值

  // 設定X軸Domain、建立X軸
  xScale.domain(xData);
  xAxis.transition().duration(1000).call(xAxisGenerator);

  // 調整X軸刻度文字標籤傾斜
  xAxis.selectAll("text")
       .attr("transform", "translate(-10, 0) rotate(-45)")
       .style("text-anchor", "end");

  // 設定Y軸Domain、建立Y軸
  yScale.domain([0, d3.max(yData)]).nice();
  yAxis.transition().duration(1000).call(yAxisGenerator);

  // 開始建立長條圖
  const bar = svg.selectAll("rect")
                 .data(data)
                 .join("rect")
                 .attr("x", d => xScale(d["縣市"]))
                 .attr("width", xScale.bandwidth())
                 .attr("fill", "#69b3a2");

  // 加上漸增動畫
  // 注意：如果要加動畫，事件要分開寫
  bar.transition()
     .duration(1000)
     .attr("y", d => yScale(parseInt(d["合計售電量_度"].split(",").join(""))))
     .attr("height", d => ( height - margin.bottom) - yScale(parseInt(d["合計售電量_度"].split(",").join(""))));

  // 加上滑鼠事件
  bar.style("cursor", "pointer")
     .on("mouseover", handleMouseOver)
     .on("mouseleave", handleMouseLeave);
};

function handleMouseOver(e) {
  d3.select(this).attr("fill", "#f68b47");

  // 加上文字標籤
  svg.append("text")
     .attr("class", "d3jsBarChartInfoText")
     .attr("x", xScale(e.target.__data__["縣市"]))
     .attr("y", yScale(parseInt(e.target.__data__["合計售電量_度"].split(",").join(""))))
     .style("fill", "#121212")
     .style("font-size", "18px")
     .style("font-weight", "bold")
     .style("text-anchor", "middle")
     .text(e.target.__data__["合計售電量_度"] + "度");
};

function handleMouseLeave() {
  d3.select(this).attr("fill", "#69b3a2");
  svg.select(".d3jsBarChartInfoText").remove();
};

onMounted(() => {
  initChart();
  updateElectricChart(buttons[0].file);
});
<\/script>

<style scoped>
.btn-container {
  display: flex;
  gap: 5px;
}

.month-button {
  padding: 6px 12px 6px 12px;
  font-size: 16px;
  font-weight: 400;
  font-family: inherit;
  line-height: 1.5;
  color: #ffc107;
  background-color: #ffffff;
  border: 1px solid #ffc107;
  border-radius: 6px;
  cursor: pointer;
  transition:
    color 0.15s ease-in-out,
    background-color 0.15s ease-in-out,
    border-color 0.15s ease-in-out;
}

.month-button:hover {
  color: #ffffff;
  background-color: #ffc107;
  border-color: #ffc107;
}
</style>`}},{detailTitle:"複數長條圖",detailSubtitle:"書本範例。橫軸為年份，縱軸為勞動人口。",detailComponent:t(()=>e(()=>import("./D3jsMultiBarChartDemo-Domvuh7o.js"),__vite__mapDeps([117,1,44,26,31,45,22,23,24,25,27,2,3,4,29,73]))),detailCode:{htmlCode:`<div id="multiBarChartExample"></div>

<script>
  const width = 750;
  const height = 500;
  const margin = {top: 20, right: 20, bottom: 100, left: 40};
  const data = [
    {"年度": 2017, "15~24歲(千人)": 80, "25~44歲(千人)": 506, "45~64歲(千人)": 381, "65歲及以上(千人)": 35},
    {"年度": 2018, "15~24歲(千人)": 80, "25~44歲(千人)": 508, "45~64歲(千人)": 392, "65歲及以上(千人)": 38},
    {"年度": 2019, "15~24歲(千人)": 82, "25~44歲(千人)": 511, "45~64歲(千人)": 398, "65歲及以上(千人)": 39},
    {"年度": 2020, "15~24歲(千人)": 79, "25~44歲(千人)": 504, "45~64歲(千人)": 387, "65歲及以上(千人)": 42}
  ];
  const svg = d3.select("#multiBarChartExample")
                .append("svg")
                .attr("width", width)
                .attr("height", height);

  // 設定要給X軸用的scale和axis（年份xScale）
  const xData = data.map((d) => d["年度"]);
  const xScale = d3.scaleBand()
                   .domain(xData)  // '.scaleBand()'的'.domain()'需要一組data，而不是數對[,]
                   .range([margin.left, width - margin.right])
                   .padding(0.2);
  const xAxisGenerator = d3.axisBottom(xScale);

  // 呼叫繪製X軸、調整X軸位置
  const xAxisGroup = svg.append("g")
                        .attr("transform", \`translate(0, \${height - margin.bottom})\`)
                        .call(xAxisGenerator);
                                                                      
  // 設定要給Y軸用的scale和axis
  const yScale = d3.scaleLinear()
                   .domain([0, 600])
                   .range([height - margin.bottom, margin.top])
                   .nice();

  const yAxisGenerator = d3.axisLeft(yScale).ticks(5).tickSize(3);

  // 呼叫繪製Y軸、調整Y軸位置
  const yAxisGroup = svg.append("g")
                        .attr("transform", \`translate(\${margin.left}, 0)\`)
                        .call(yAxisGenerator);

  // 設定第2條X軸資料、比例尺（本例為不同年齡層的xScale）
  // 用來設定「多條長條圖」的位置
  const xSubGroups = Object.keys(data[0]).slice(1);  // 取出data中，非年份的key，並返回一個新的陣列
  const xSubGroupsScale = d3.scaleBand()
                            .domain(xSubGroups)
                            .range([0, xScale.bandwidth()])
                            .padding(0.05);

  // 設定不同subgroup bar的顏色
  const color = d3.scaleOrdinal()
                  .domain(xSubGroups)
                  .range(["#d4be92", "#c2cccd", "#b2c2e3", "#ead0d1"]);

  // 開始建立長條圖
  const bar = svg.append("g")
                 .selectAll("g")
                 .data(data)
                 .join("g")
                 .attr("transform", d => \`translate(\${xScale(d["年度"])}, 0)\`)
                 .selectAll("rect")
                 .data((d) => xSubGroups.map(key => {return {key: key, value: d[key]}}))
                 .join("rect")
                 .attr("x", (d) => xSubGroupsScale(d.key))
                 .attr("y", (d) => yScale(d.value))
                 .attr("width", xSubGroupsScale.bandwidth())
                 .attr("height", (d) => ( height - margin.bottom ) - yScale(d.value))
                 .attr("fill", (d) => color(d.key))
                 .style("cursor", "pointer")
                 .on("mouseover", multiBarChartMouseover)
                 .on("mousemove", multiBarChartMousemove)
                 .on("mouseleave", multiBarChartMouseleave);

  function multiBarChartMouseover(e) {
    const pt = d3.pointer(e, svg.node());

    // 加上文字標籤
    svg.append("text")
       .attr("class", "multiBarChartExampleInfoText")
       .attr("x", margin.left)
       .attr("y", yScale(e.target.__data__["value"]))
       .attr("fill", "#121212")
       .style("font-size", "18px")
       .style("font-weight", "bold")
       .style("text-anchor", "middle")
       .text(e.target.__data__["value"] + "千人");

    // 加上標示用輔助虛線
    svg.append("line")
       .attr("class", "multiBarChartExampleDashedY")
       .attr("x1", margin.left)
       .attr("y1", yScale(e.target.__data__["value"]))
       .attr("x2", pt[0])
       .attr("y2", yScale(e.target.__data__["value"]))
       .style("stroke", "black")
       .style("stroke-dasharray", 3);
  };

  function multiBarChartMousemove(e) {
    const pt = d3.pointer(e, svg.node());
    svg.selectAll(".multiBarChartExampleDashedY")
                               .attr("x2", pt[0]);
  };

  function multiBarChartMouseleave() {
    svg.select(".multiBarChartExampleInfoText").remove();
    svg.select(".multiBarChartExampleDashedY").remove();
  }

  // 加上辨識標籤
  const tagsWrap = svg.append("g")
                      .selectAll("g")
                      .data(xSubGroups)
                      .join("g")
                      .attr("class", "multiBarChartExampleTags");

  tagsWrap.append("rect")
          .attr("x", (d, i) => (i + 1) * margin.bottom * 1.3)
          .attr("y", height - margin.bottom / 2)
          .attr("width", 20)
          .attr("height", 20)
          .attr("fill", (d) => color(d));

  tagsWrap.append("text")
          .attr("x", (d, i) => (i + 1) * margin.bottom * 1.3)
          .attr("y", height - margin.bottom / 2 + 40)
          .style("fill", "#121212")
          .style("font-size", "12px")
          .style("font-weight", "bold")
          .style("text-anchor", "middle")
          .text(d => d);
<\/script>`,jsCode:null,vueCode:`<template>
  <div ref="multiBarChartContainerRef"></div>
</template>

<script setup>
import { ref, onMounted } from "vue";
import * as d3 from "d3";

const multiBarChartContainerRef = ref(null);

// 圖表尺寸與內邊距設定
const width = 600;
const height = 400;
const margin = {top: 20, right: 20, bottom: 100, left: 40};

const data = [
  {"年度": 2017, "15~24歲(千人)": 80, "25~44歲(千人)": 506, "45~64歲(千人)": 381, "65歲及以上(千人)": 35},
  {"年度": 2018, "15~24歲(千人)": 80, "25~44歲(千人)": 508, "45~64歲(千人)": 392, "65歲及以上(千人)": 38},
  {"年度": 2019, "15~24歲(千人)": 82, "25~44歲(千人)": 511, "45~64歲(千人)": 398, "65歲及以上(千人)": 39},
  {"年度": 2020, "15~24歲(千人)": 79, "25~44歲(千人)": 504, "45~64歲(千人)": 387, "65歲及以上(千人)": 42}
];

onMounted(() => {
  const svg = d3.select(multiBarChartContainerRef.value)
                .append("svg")
                .attr("width", width)
                .attr("height", height);

  // 設定要給X軸用的scale和axis（年份xScale）
  const xData = data.map((d) => d["年度"]);
  const xScale = d3.scaleBand()
                   .domain(xData)  // '.scaleBand()'的'.domain()'需要一組data，而不是數對[,]
                   .range([margin.left, width - margin.right])
                   .padding(0.2);
  const xAxisGenerator = d3.axisBottom(xScale);

  // 呼叫繪製X軸、調整X軸位置
  const xAxisGroup = svg.append("g")
                        .attr("transform", \`translate(0, \${height - margin.bottom})\`)
                        .call(xAxisGenerator);
                                                                      
  // 設定要給Y軸用的scale和axis
  const yScale = d3.scaleLinear()
                   .domain([0, 600])
                   .range([height - margin.bottom, margin.top])
                   .nice();

  const yAxisGenerator = d3.axisLeft(yScale).ticks(5).tickSize(3);

  // 呼叫繪製Y軸、調整Y軸位置
  const yAxisGroup = svg.append("g")
                        .attr("transform", \`translate(\${margin.left}, 0)\`)
                        .call(yAxisGenerator);

  // 設定第2條X軸資料、比例尺（本例為不同年齡層的xScale）
  // 用來設定「多條長條圖」的位置
  const xSubGroups = Object.keys(data[0]).slice(1);  // 取出data中，非年份的key，並返回一個新的陣列
  const xSubGroupsScale = d3.scaleBand()
                            .domain(xSubGroups)
                            .range([0, xScale.bandwidth()])
                            .padding(0.05);

  // 設定不同subgroup bar的顏色
  const color = d3.scaleOrdinal()
                  .domain(xSubGroups)
                  .range(["#d4be92", "#c2cccd", "#b2c2e3", "#ead0d1"]);

  // 開始建立長條圖
  const bar = svg.append("g")
                 .selectAll("g")
                 .data(data)
                 .join("g")
                 .attr("transform", d => \`translate(\${xScale(d["年度"])}, 0)\`)
                 .selectAll("rect")
                 .data((d) => xSubGroups.map(key => {return {key: key, value: d[key]}}))
                 .join("rect")
                 .attr("x", (d) => xSubGroupsScale(d.key))
                 .attr("y", (d) => yScale(d.value))
                 .attr("width", xSubGroupsScale.bandwidth())
                 .attr("height", (d) => ( height - margin.bottom ) - yScale(d.value))
                 .attr("fill", (d) => color(d.key))
                 .style("cursor", "pointer")
                 .on("mouseover", multiBarChartMouseover)
                 .on("mousemove", multiBarChartMousemove)
                 .on("mouseleave", multiBarChartMouseleave);

  function multiBarChartMouseover(e) {
    const pt = d3.pointer(e, svg.node());

    // 加上文字標籤
    svg.append("text")
       .attr("class", "multiBarChartExampleInfoText")
       .attr("x", margin.left)
       .attr("y", yScale(e.target.__data__["value"]))
       .attr("fill", "#121212")
       .style("font-size", "18px")
       .style("font-weight", "bold")
       .style("text-anchor", "middle")
       .text(e.target.__data__["value"] + "千人");

    // 加上標示用輔助虛線
    svg.append("line")
       .attr("class", "multiBarChartExampleDashedY")
       .attr("x1", margin.left)
       .attr("y1", yScale(e.target.__data__["value"]))
       .attr("x2", pt[0])
       .attr("y2", yScale(e.target.__data__["value"]))
       .style("stroke", "black")
       .style("stroke-dasharray", 3);
  };

  function multiBarChartMousemove(e) {
    const pt = d3.pointer(e, svg.node());
    svg.selectAll(".multiBarChartExampleDashedY")
                               .attr("x2", pt[0]);
  };

  function multiBarChartMouseleave() {
    svg.select(".multiBarChartExampleInfoText").remove();
    svg.select(".multiBarChartExampleDashedY").remove();
  }

  // 加上辨識標籤
  const tagsWrap = svg.append("g")
                      .selectAll("g")
                      .data(xSubGroups)
                      .join("g")
                      .attr("class", "multiBarChartExampleTags");

  tagsWrap.append("rect")
          .attr("x", (d, i) => (i + 1) * margin.bottom * 1.3)
          .attr("y", height - margin.bottom / 2)
          .attr("width", 20)
          .attr("height", 20)
          .attr("fill", (d) => color(d));

  tagsWrap.append("text")
          .attr("x", (d, i) => (i + 1) * margin.bottom * 1.3)
          .attr("y", height - margin.bottom / 2 + 40)
          .style("fill", "#121212")
          .style("font-size", "12px")
          .style("font-weight", "bold")
          .style("text-anchor", "middle")
          .text(d => d);
});
<\/script>

<style scoped></style>`}},{detailTitle:`堆疊長條圖
<ol type="A" style="margin-top: 16px;">
  <li style="line-height: 1.6;">
    堆疊長條圖使用 <code>d3.stack()</code>，會生成一個新的陣列結構，每個堆疊部分（即每個子群組）的資料會被轉換成一個陣列，這個陣列中的每個元素都包含以下幾個部分：
    <ul>
      <li><code>d[0]</code>：該堆疊部分的起始值（即堆疊長條的底部）。</li>
      <li><code>d[1]</code>：該堆疊部分的結束值（即堆疊長條的頂部）。</li>
      <li><code>d.data</code>：這部分對應的原始資料。</li>
    </ul>
  </li>
  <li style="margin-top: 16px;">
    以下為堆疊長條圖的例子：
    <p style="color: rgba(33, 37, 41, 0.75); font-size: 12px; font-style: italic; margin-bottom: 8px;">
      - 書本範例。橫軸為年份，縱軸為勞動人口。
    </p>
  </li>
</ol>`,detailSubtitle:null,detailComponent:t(()=>e(()=>import("./D3jsStackedBarChartDemo-C6PjaQZ-.js"),__vite__mapDeps([118,1,44,26,31,45,22,23,24,25,27,2,3,4,29,32,12,13,73]))),detailCode:{htmlCode:`<div id="stackedBarChart"></div>

<script>
  const width = 750;
  const height = 500;
  const margin = {top: 20, right: 20, bottom: 100, left: 40};
  const data = [
    {"年度": 2017, "15~24歲(千人)": 80, "25~44歲(千人)": 506, "45~64歲(千人)": 381, "65歲及以上(千人)": 35},
    {"年度": 2018, "15~24歲(千人)": 80, "25~44歲(千人)": 508, "45~64歲(千人)": 392, "65歲及以上(千人)": 38},
    {"年度": 2019, "15~24歲(千人)": 82, "25~44歲(千人)": 511, "45~64歲(千人)": 398, "65歲及以上(千人)": 39},
    {"年度": 2020, "15~24歲(千人)": 79, "25~44歲(千人)": 504, "45~64歲(千人)": 387, "65歲及以上(千人)": 42}
  ];
  const svg = d3.select("#stackedBarChart")
                .append("svg")
                .attr("width", width)
                .attr("height", height);

  // 設定要給X軸用的scale和axis
  const xData = data.map((d) => d["年度"])
  const xScale = d3.scaleBand()
                   .domain(xData)
                   .range([margin.left, width - margin.right])
                   .padding(0.2);
  const xAxisGenerator = d3.axisBottom(xScale);

  // 呼叫繪製X軸、調整X軸位置
  const xAxisGroup = svg.append("g")
                        .attr("transform", \`translate(0, \${height - margin.bottom})\`)
                        .call(xAxisGenerator);

  // 設定要給Y軸用的scale和axis
  const yScale = d3.scaleLinear()
                   .domain([0, 1200])
                   .range([height - margin.bottom, margin.top])
                   .nice();
  const yAxisGenerator = d3.axisLeft(yScale).ticks(5).tickSize(3);

  // 呼叫繪製Y軸、調整Y軸位置
  const yAxisGroup = svg.append("g")
                        .attr("transform", \`translate(\${margin.left}, 0)\`)
                        .call(yAxisGenerator);

  // 設定分組，用d3.stack()把資料堆疊起來
  const xSubGroups = Object.keys(data[0]).slice(1);
  const stackedData = d3.stack().keys(xSubGroups)(data);

  // 設定不同subgroup bar的顏色
  const color = d3.scaleOrdinal()
                  .domain(xSubGroups)
                  .range(["#97a9bf", "#d6dbbb", "#d4e6e8", "#dcd2d0"]);

  // 開始建立長條圖
  const bar = svg.append("g")
                 .selectAll("g")
                 .data(stackedData)
                 .join("g")
                 .attr("fill", (d) => color(d.key))  // 顏色放在<g>的屬性中，所以這行要放在這裡
                 .selectAll("rect")
                 .data(d => d)
                 .join("rect")
                 .attr("x", (d) => xScale(d.data["年度"]))  // 此處的'd.data'是'd3.stack()'生成之新陣列中，對應原始資料的部分，非我們自己設的'data'變數
                 .attr("y", (d) => yScale(d[1]))
                 .attr("height", (d) => yScale(d[0]) - yScale(d[1]))
                 .attr("width", xScale.bandwidth())
                 .style("cursor", "pointer")  // 未完成
                 .on("mouseover", stackedBarChartHandleMouseover)
                 .on("mousemove", stackedBarChartHandleMousemove)
                 .on("mouseleave", stackedBarChartHandleMouseleave);

  function stackedBarChartHandleMouseover(e) {
    const pt = d3.pointer(e, svg.node());
    d3.select(this).style("opacity", 0.5);

    // 加上文字標籤
    svg.append("text")
       .attr("class", "stackedBarChartInfoText")
       .attr("fill", "#121212")
       .style("font-size", "18px")
       .style("font-weight", "bold")
       .style("text-anchor", "start")
       .attr("x", pt[0])
       .attr("y", pt[1] - 20)
       .text((e.target.__data__[1] - e.target.__data__[0]) + " 千人");
  };

  function stackedBarChartHandleMousemove(e) {
    const pt = d3.pointer(e, svg.node());
    svg.select(".stackedBarChartInfoText")
       .attr("x", pt[0] + 10)
       .attr("y", pt[1] - 15);
  };

  function stackedBarChartHandleMouseleave() {
    d3.select(this).style("opacity", "1");
    svg.select(".stackedBarChartInfoText").remove();
  };

  // 加上辨識標籤
  const tagsWrap = svg.append("g")
                      .selectAll("g")
                      .data(xSubGroups)
                      .join("g")
                      .attr("class", "stackedBarChartTags");

  tagsWrap.append("rect")
          .attr("x", (d, i) => ( i + 1 ) * margin.bottom * 1.3)
          .attr("y", height - margin.bottom / 2)
          .attr("width", 20)
          .attr("height", 20)
          .attr("fill", (d) => color(d));

  tagsWrap.append("text")
          .attr("x", (d, i) => ( i + 1 ) * margin.bottom * 1.3)
          .attr("y", height - margin.bottom / 2 + 40)
          .style("fill", "#121212")
          .style("font-size", "12px")
          .style("font-weight", "bold")
          .style("text-anchor", "middle")
          .text(d => d);
<\/script>`,jsCode:null,vueCode:`<template>
  <div ref="stackedBarChartContainerRef"></div>
</template>

<script setup>
import { ref, onMounted } from "vue";
import * as d3 from "d3";

const stackedBarChartContainerRef = ref(null);

// 圖表尺寸與內邊距設定
const width = 600;
const height = 400;
const margin = {top: 20, right: 20, bottom: 100, left: 40};

const data = [
  {"年度": 2017, "15~24歲(千人)": 80, "25~44歲(千人)": 506, "45~64歲(千人)": 381, "65歲及以上(千人)": 35},
  {"年度": 2018, "15~24歲(千人)": 80, "25~44歲(千人)": 508, "45~64歲(千人)": 392, "65歲及以上(千人)": 38},
  {"年度": 2019, "15~24歲(千人)": 82, "25~44歲(千人)": 511, "45~64歲(千人)": 398, "65歲及以上(千人)": 39},
  {"年度": 2020, "15~24歲(千人)": 79, "25~44歲(千人)": 504, "45~64歲(千人)": 387, "65歲及以上(千人)": 42}
];

onMounted(() => {
  const svg = d3.select(stackedBarChartContainerRef.value)
                .append("svg")
                .attr("width", width)
                .attr("height", height);

  // 設定要給X軸用的scale和axis
  const xData = data.map((d) => d["年度"])
  const xScale = d3.scaleBand()
                   .domain(xData)
                   .range([margin.left, width - margin.right])
                   .padding(0.2);
  const xAxisGenerator = d3.axisBottom(xScale);

  // 呼叫繪製X軸、調整X軸位置
  const xAxisGroup = svg.append("g")
                        .attr("transform", \`translate(0, \${height - margin.bottom})\`)
                        .call(xAxisGenerator);

  // 設定要給Y軸用的scale和axis
  const yScale = d3.scaleLinear()
                   .domain([0, 1200])
                   .range([height - margin.bottom, margin.top])
                   .nice();
  const yAxisGenerator = d3.axisLeft(yScale).ticks(5).tickSize(3);

  // 呼叫繪製Y軸、調整Y軸位置
  const yAxisGroup = svg.append("g")
                        .attr("transform", \`translate(\${margin.left}, 0)\`)
                        .call(yAxisGenerator);

  // 設定分組，用d3.stack()把資料堆疊起來
  const xSubGroups = Object.keys(data[0]).slice(1);
  const stackedData = d3.stack().keys(xSubGroups)(data);

  // 設定不同subgroup bar的顏色
  const color = d3.scaleOrdinal()
                  .domain(xSubGroups)
                  .range(["#97a9bf", "#d6dbbb", "#d4e6e8", "#dcd2d0"]);

  // 開始建立長條圖
  const bar = svg.append("g")
                 .selectAll("g")
                 .data(stackedData)
                 .join("g")
                 .attr("fill", (d) => color(d.key))  // 顏色放在<g>的屬性中，所以這行要放在這裡
                 .selectAll("rect")
                 .data(d => d)
                 .join("rect")
                 .attr("x", (d) => xScale(d.data["年度"]))  // 此處的'd.data'是'd3.stack()'生成之新陣列中，對應原始資料的部分，非我們自己設的'data'變數
                 .attr("y", (d) => yScale(d[1]))
                 .attr("height", (d) => yScale(d[0]) - yScale(d[1]))
                 .attr("width", xScale.bandwidth())
                 .style("cursor", "pointer")  // 未完成
                 .on("mouseover", handleMouseover)
                 .on("mousemove", handleMousemove)
                 .on("mouseleave", handleMouseleave);

  function handleMouseover(e) {
    const pt = d3.pointer(e, svg.node());
    d3.select(this).style("opacity", 0.5);

    // 加上文字標籤
    svg.append("text")
       .attr("class", "stackedBarChartInfoText")
       .attr("fill", "#121212")
       .style("font-size", "18px")
       .style("font-weight", "bold")
       .style("text-anchor", "start")
       .attr("x", pt[0])
       .attr("y", pt[1] - 20)
       .text((e.target.__data__[1] - e.target.__data__[0]) + " 千人");
  };

  function handleMousemove(e) {
    const pt = d3.pointer(e, svg.node());
    svg.select(".stackedBarChartInfoText")
       .attr("x", pt[0] + 10)
       .attr("y", pt[1] - 15);
  };

  function handleMouseleave() {
    d3.select(this).style("opacity", "1");
    svg.select(".stackedBarChartInfoText").remove();
  };

  // 加上辨識標籤
  const tagsWrap = svg.append("g")
                      .selectAll("g")
                      .data(xSubGroups)
                      .join("g")
                      .attr("class", "stackedBarChartTags");

  tagsWrap.append("rect")
          .attr("x", (d, i) => ( i + 1 ) * margin.bottom * 1.3)
          .attr("y", height - margin.bottom / 2)
          .attr("width", 20)
          .attr("height", 20)
          .attr("fill", (d) => color(d));

  tagsWrap.append("text")
          .attr("x", (d, i) => ( i + 1 ) * margin.bottom * 1.3)
          .attr("y", height - margin.bottom / 2 + 40)
          .style("fill", "#121212")
          .style("font-size", "12px")
          .style("font-weight", "bold")
          .style("text-anchor", "middle")
          .text(d => d);
});
<\/script>

<style scoped></style>`}}]}]},{id:"d3jsLineChartNote",title:"折線圖",description:null,descriptionComponent:null,descriptionComponentStyle:null,lists:[{listTitle:"折線圖（Line Chart）",listSubtitle:"（一般折線圖、缺少資料的折線圖、多線折線圖）",listComponent:null,listCode:{htmlCode:null,jsCode:null,vueCode:null},listDetails:[{detailTitle:null,detailSubtitle:null,detailComponent:null,detailCode:{htmlCode:null,jsCode:null,vueCode:null}}]},{listTitle:"一般折線圖",listSubtitle:null,listComponent:null,listCode:{htmlCode:null,jsCode:null,vueCode:null},listDetails:[{detailTitle:"基礎折線圖",detailSubtitle:"書本範例改編。橫軸為年份，縱軸為南港買賣契約價格平均總價。",detailComponent:t(()=>e(()=>import("./D3jsLineChartDemo-C6n4wHkD.js"),__vite__mapDeps([119,1,120,121,41,23,24,25,26,34,22,27,2,3,4,82,83,29,11,12,13,14]))),detailCode:{htmlCode:`<div id="d3jsLineChartExample" class="mt-1"></div>

<!-- 引用Day.js函式庫 -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/dayjs/1.11.7/dayjs.min.js"><\/script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/dayjs/1.11.7/locale/zh-tw.min.js"><\/script>

<script>
  // 先設一個函式轉換日期格式
  // 中華民國年份改成西元
  const ROCDateToADDate = (date) => {
    // 年份轉換
    date = date.replace(/\\d{3}/, ((match) => String(+match + 1911)));

    // 季度換成每季第一天
    // 定義一個對應表，用於將季度表示（如Q1, Q2）轉換成對應的日期
    const seasonDates = {
      Q1: "-01-01",
      Q2: "-04-01",
      Q3: "-07-01",
      Q4: "-10-01"
    };

    const season = date.match(/Q\\d/)[0];  // 找到季度表示（如Q1, Q2），因為'.match()'會返回一個陣列（此處為單元素陣列），所以需要用[0]取出該元素
    date = date.replace(season, seasonDates[season]);  // 用對應的日期替換季度表示
    return new Date(date);  // 將處理後的字串轉換成Date物件，並回傳
  };

  // 折線圖繪圖函式
  const housePriceLineChart = async () => {
    // 設定svg
    const width = 600;
    const height = 400;
    const margin = {top: 20, bottom: 60, right: 20, left: 60};
    const svg = d3.select("#d3jsLineChartExample")
                  .append("svg")
                  .attr("width", width)
                  .attr("height", height);

    // 取資料
    const res = await d3.csv("data/housePrice/南港96Q3至113Q1買賣契約價格平均總價.csv");
    const data = res.map((i) => {
      i["date"] = ROCDateToADDate(i["date"]);
      return i;
    });  // 日期格式轉換

    // map資料集
    const xData = data.map((i) => i["date"]);
    const yData = data.map((i) => +i["price"]);

    // Time Axis
    const xScale = d3.scaleTime()
                     .domain(d3.extent(xData))
                     .range([margin.left, width - margin.right])
                     .nice();
    let tickNumber = window.innerWidth > 900 ? (xData.length / 3) : 10 ;  // 根據視窗不同寬來調整tick數量
    const xAxisGenerator = d3.axisBottom(xScale)
                             .ticks(tickNumber)
                             .tickFormat((d) => dayjs(d).format("YYYY/MM/DD"));
    const xAxis = svg.append("g")
                     .attr("transform", \`translate(0, \${height - margin.bottom})\`)
                     .call(xAxisGenerator)
                     .style("font-size", "12px");
    xAxis.selectAll(".tick text")
         .attr("transform", "rotate(-45)")
         .attr("x", "-35")
         .attr("y", "6");

    // Price Axis
    const yScale = d3.scaleLinear()
                     .domain(d3.extent(yData))
                     .range([height - margin.bottom, margin.top])
                     .nice();
    const yAxisGenerator = d3.axisLeft(yScale).tickFormat((d) => d + "萬");
    // 上行也可以寫成"const yAxisGenerator = d3.axisLeft(yScale).tickFormat((d) => \`\${d}萬\`);"
    const yAxis = svg.append("g")
                     .attr("transform", \`translate(\${margin.left}, 0)\`)
                     .call(yAxisGenerator);

    // 設定path的d
    const lineChart = d3.line()
                        .x((d) => xScale(d["date"]))
                        .y((d) => yScale(+d["price"]));
    
    // 建立折線圖
    svg.append("path")
       .data(data)
       .attr("d", lineChart(data))
       .attr("fill", "none")
       .attr("stroke", "#f68b47")
       .attr("stroke-width", 1.5);
  };
  housePriceLineChart();
<\/script>`,jsCode:null,vueCode:`<template>
  <svg
    ref="lineChartSvgRef"
    :width="width"
    :height="height"
  ></svg>
</template>

<script setup>
import { ref, onMounted } from "vue";
import * as d3 from "d3";
import dayjs from "dayjs";
import "dayjs/locale/zh-tw";

import nangangHousePriceData from "../../../../assets/web-note-view/d3js-note-view/nangang-house-price/南港96Q3至113Q1買賣契約價格平均總價.csv?url";

// 圖表尺寸與內邊距設定
const width = 600;
const height = 400;
const margin = {top: 20, bottom: 60, right: 20, left: 60};

const lineChartSvgRef = ref(null);

// 先設一個函式轉換日期格式
// 中華民國年份改成西元
const ROCDateToADDate = (date) => {
  // 年份轉換
  date = date.replace(/\\d{3}/, (match) => String(+match + 1911));

  // 季度換成每季第一天
  // 定義一個對應表，用於將季度表示（如Q1, Q2）轉換成對應的日期
  const seasonDates = {
    Q1: "-01-01",
    Q2: "-04-01",
    Q3: "-07-01",
    Q4: "-10-01"
  };

  const season = date.match(/Q\\d/)[0];  // 找到季度表示（如Q1, Q2），因為'.match()'會返回一個陣列（此處為單元素陣列），所以需要用[0]取出該元素
  date = date.replace(season, seasonDates[season]);  // 用對應的日期替換季度表示
  return new Date(date);  // 將處理後的字串轉換成Date物件，並回傳
};

onMounted(async () => {
  const svg = d3.select(lineChartSvgRef.value)

  // 取資料
  const res = await d3.csv(nangangHousePriceData);
  const data = res.map((i) => {
    i["date"] = ROCDateToADDate(i["date"]);
    return i;
  });  // 日期格式轉換

  // map資料集
  const xData = data.map((i) => i["date"]);
  const yData = data.map((i) => +i["price"]);

  // Time Axis
  const xScale = d3.scaleTime()
                   .domain(d3.extent(xData))
                   .range([margin.left, width - margin.right])
                   .nice();
  let tickNumber = window.innerWidth > 900 ? (xData.length / 3) : 10 ;  // 根據視窗不同寬來調整tick數量
  const xAxisGenerator = d3.axisBottom(xScale)
                           .ticks(tickNumber)
                           .tickFormat((d) => dayjs(d).format("YYYY/MM/DD"));  // 此行亦可改用'.tickFormat(d3.timeFormat("%Y/%m/%d"))'
  const xAxis = svg.append("g")
                   .attr("transform", \`translate(0, \${height - margin.bottom})\`)
                   .call(xAxisGenerator)
                   .style("font-size", "12px");
  xAxis.selectAll(".tick text")
       .attr("transform", "rotate(-45)")
       .attr("x", "-35")
       .attr("y", "6");

  // Price Axis
  const yScale = d3.scaleLinear()
                   .domain(d3.extent(yData))
                   .range([height - margin.bottom, margin.top])
                   .nice();
  const yAxisGenerator = d3.axisLeft(yScale).tickFormat((d) => d + "萬");
  // 上行也可以寫成"const yAxisGenerator = d3.axisLeft(yScale).tickFormat((d) => \`\${d}萬\`);"
  const yAxis = svg.append("g")
                   .attr("transform", \`translate(\${margin.left}, 0)\`)
                   .call(yAxisGenerator);

  // 設定path的d
  const lineChart = d3.line()
                      .x((d) => xScale(d["date"]))
                      .y((d) => yScale(+d["price"]));
    
  // 建立折線圖
  svg.append("path")
     .datum(data)  // ".datum()"是直接綁定「一整份資料」到單一DOM元素（path就是一條線）；".data()"則是做data join，會嘗試為每個資料元素綁定一個DOM元素
     .attr("d", lineChart(data))
     .attr("fill", "none")
     .attr("stroke", "#f68b47")
     .attr("stroke-width", 1.5);
});
<\/script>

<style scoped></style>`}},{detailTitle:`有滑鼠互動效果的折線圖
<ol type="A" style="margin-top: 16px; margin-bottom: 40px;">
  <li style="line-height: 1.6;">
    使用 CSS 中的 <code>pointer-event</code> 來觸發滑鼠事件，常見有以下三種：
    <ul>
      <li><code>auto</code>：預設值。</li>
      <li><code>none</code>：穿越該元素，可以點擊到下方的元素。</li>
      <li><code>all</code>：能讓滑鼠在元素內部或邊界時才會觸發。</li>
    </ul>
  </li>
  <li style="line-height: 1.6; margin-top: 16px;">
    <code>d3.bisect(array, value, [start, end])</code>：可用來尋找某數值對應一個資料陣列中的正確位置／最接近的位置。
    <ul>
      <li><code>data</code>：要對應的資料陣列。</li>
      <li><code>value</code>：要尋找位置的數值。</li>
      <li><code>start</code>：尋找的起始範圍，可以不設定。</li>
      <li><code>end</code>：尋找的終點範圍，可以不設定。</li>
    </ul>
<pre style="padding: 16px;"><code class="javascript">const data = [0, 1, 2, 3, 4];
d3.bisect(data, 1.25);  // return 2</code></pre>
  </li>
  <li style="line-height: 1.6; margin-top: 16px;">
    <code>d3.bisector()</code>：與 <code>d3.bisect()</code> 功能類似，但 <code>d3.bisect()</code> 是帶入一個方法作為參數，能用來搜尋整個物件資料。有 <code>bisector.left</code>、<code>bisector.right</code>、<code>bisector.center</code> 三種方法，來設定要插入的資料是從左邊或右邊尋找。
<pre style="padding: 16px;"><code class="javascript">const data = [
  {date: new Date(2023, 1, 1), value: 0.5},
  {date: new Date(2023, 2, 1), value: 0.6},
  {date: new Date(2023, 3, 1), value: 0.7},
  {date: new Date(2023, 4, 1), value: 0.8}
];
const bisectDate = d3.bisector(d => d.date).right;</code></pre>
  </li>
</ol>`,detailSubtitle:"書本範例改編。橫軸為 2023 的週份，縱軸為每週後天免疫缺乏症候群確診數。",detailComponent:t(()=>e(()=>import("./D3jsInteractLineChartDemo-BjQCqKa4.js"),__vite__mapDeps([122,1,22,23,24,25,26,27,34,28,2,3,4,82,83,29,11,12,13,14,73]))),detailCode:{htmlCode:`<div id="interactLineChartExample" class="mt-1"></div>

<script>
  const interactLineChart = async () => {
    const width = 600;
    const height = 400;
    const margin = 50;
    const svg = d3.select("#interactLineChartExample")
                  .append("svg")
                  .attr("width", width)
                  .attr("height", height)

    const res = await d3.csv("data/disease/後天免疫缺乏症候群趨勢.csv");
    const data = res.filter(i => i["診斷年週"] < "202401");
    // map資料集
    const xData = data.map((i) => +i["診斷年週"].substring(4, 6));
    const yData = data.map((i) => +i["確定病例數"]);

    // Time Axis
    const xScale = d3.scaleLinear()
                     .domain(d3.extent(xData))
                     .range([margin, width - margin])
                     .nice();
    const xAxisGenerator = d3.axisBottom(xScale)
                             .tickFormat(d => "第" + d + "週");
    const xAxis = svg.append("g")
                     .attr("transform", \`translate(0, \${height - margin})\`)
                     .call(xAxisGenerator);

    // Number_of_cases Axis
    const yScale = d3.scaleLinear()
                     .domain([0, d3.max(yData)])
                     .range([height - margin, margin])
                     .nice();
    const yAxisGenerator = d3.axisLeft(yScale).ticks(5);
    const yAxis = svg.append("g")
                     .attr("transform", \`translate(\${margin}, 0)\`)
                     .call(yAxisGenerator);

    // 開始建立折線圖，設定折線圖相關資料
    const lineChart = d3.line()
                        .x((d) => xScale(+d["診斷年週"].substring(4, 6)))
                        .y((d) => yScale(+d["確定病例數"]));
    svg.append("path")
       .data(data)
       .attr("d", lineChart(data))
       .attr("fill", "none")
       .attr("stroke", "#f68b47")
       .attr("stroke-width", 1.5);

    // 建立一個覆蓋SVG的方形
    svg.append("rect")
       .style("fill", "transparent")
       .style("pointer-events", "all")
       .style("cursor", "pointer")
       .attr("width", width - margin)
       .attr("height", height - margin)
       .on("mouseover", mouseover)
       .on("mousemove", mousemove)
       .on("mouseout", mouseout);

    // 建立沿著折線移動的圓點點
    const focusDot = svg.append("g")
                        .append("circle")
                        .style("fill", "black")
                        .attr("stroke", "black")
                        .attr("r", 3)
                        .style("opacity", 0);

    // 建立移動的資料標籤
    const focusText = svg.append("text")
                         .style("opacity", 0)
                         .attr("text-anchor", "start")
                         .attr("alignment-baseline", "middle");

    // 使用d3.bisector()找到根據資料的"診斷年週"對應的資料點
    const bisect = d3.bisector((d) => d["診斷年週"]).left;

    // 設定滑鼠事件
    function mouseover() {
      focusDot.style("opacity", 1);
      focusText.style("opacity", 1);
    };

    function mousemove(e) {
      // 把目前X的位置用xScale去換算
      const x0 = xScale.invert(d3.pointer(e, this)[0]);
      // 由於X軸資料是擷取過的，這裡要整理並補零（整數部分先轉換為字串，並補足兩位數（如 01, 02, ...））
      const fixedX0 = parseInt(x0).toString().padStart(2, "0");
      // 接者把擷取掉的2023補回來，因為data是帶入原本的資料
      let i = bisect(data, "2023" + fixedX0);
      let selectedData = data[i];

      // 圓點
      focusDot.attr("cx", xScale(selectedData["診斷年週"].substring(4, 6)))
              .attr("cy", yScale(selectedData["確定病例數"]));

      focusText.html("確定病例數：" + selectedData["確定病例數"])
               .attr("x", xScale(selectedData["診斷年週"].substring(4, 6)) + 15)
               .attr("y", yScale(selectedData["確定病例數"]));
    };

    function mouseout() {
      focusDot.style("opacity", 0);
      focusText.style("opacity", 0);
    }
  };
  interactLineChart();
<\/script>`,jsCode:null,vueCode:`<template>
  <div ref="interactLineChartContainerRef"></div>
</template>

<script setup>
import { ref, onMounted } from "vue";
import * as d3 from "d3";

import hivDiseaseTrend from "../../../../assets/web-note-view/d3js-note-view/hiv-disease/後天免疫缺乏症候群趨勢.csv?url";

const interactLineChartContainerRef = ref(null);

// 圖表尺寸與內邊距設定
const width = 600;
const height = 400;
const margin = 50;

onMounted(async () => {
  const svg = d3.select(interactLineChartContainerRef.value)
                .append("svg")
                .attr("width", width)
                .attr("height", height);

  const res = await d3.csv(hivDiseaseTrend);
  const data = res.filter(i => i["診斷年週"] < "202401");
  // map資料集
  const xData = data.map((i) => +i["診斷年週"].substring(4, 6));
  const yData = data.map((i) => +i["確定病例數"]);

  // Time Axis（x軸）
  const xScale = d3.scaleLinear()
                   .domain(d3.extent(xData))
                   .range([margin, width - margin])
                   .nice();
  const xAxisGenerator = d3.axisBottom(xScale)
                           .tickFormat(d => "第" + d + "週");
  const xAxis = svg.append("g")
                   .attr("transform", \`translate(0, \${height - margin})\`)
                   .call(xAxisGenerator);

  // Number_of_cases Axis（y軸）
  const yScale = d3.scaleLinear()
                   .domain([0, d3.max(yData)])
                   .range([height - margin, margin])
                   .nice();
  const yAxisGenerator = d3.axisLeft(yScale)
                           .ticks(5)
                           .tickSizeOuter(0);
  const yAxis = svg.append("g")
                   .attr("transform", \`translate(\${margin}, 0)\`)
                   .call(yAxisGenerator);

  // 開始建立折線圖，設定折線圖相關資料
  const lineChart = d3.line()
                      .x((d) => xScale(+d["診斷年週"].substring(4, 6)))
                      .y((d) => yScale(+d["確定病例數"]));
  svg.append("path")
     .datum(data)
     .attr("d", lineChart(data))
     .attr("fill", "none")
     .attr("stroke", "#f68b47")
     .attr("stroke-width", 1.5);

  // 建立一個覆蓋SVG的方形
  svg.append("rect")
     .style("fill", "transparent")
     .style("pointer-events", "all")
     .style("cursor", "pointer")
     .attr("width", width - margin)
     .attr("height", height - margin)
     .on("mouseover", mouseover)
     .on("mousemove", mousemove)
     .on("mouseout", mouseout);

  // 建立沿著折線移動的圓點點
  const focusDot = svg.append("g")
                      .append("circle")
                      .style("fill", "black")
                      .attr("stroke", "black")
                      .attr("r", 3)
                      .style("opacity", 0);

  // 建立移動的資料標籤
  const focusText = svg.append("text")
                       .style("opacity", 0)
                       .attr("text-anchor", "start")
                       .attr("alignment-baseline", "middle");

  // 使用d3.bisector()找到根據資料的"診斷年週"對應的資料點
  const bisect = d3.bisector((d) => d["診斷年週"]).left;

  // 設定滑鼠事件
  function mouseover() {
    focusDot.style("opacity", 1);
    focusText.style("opacity", 1);
  };

  function mousemove(e) {
    // 把目前X的位置用xScale去換算
    const x0 = xScale.invert(d3.pointer(e, this)[0]);
    // 由於X軸資料是擷取過的，這裡要整理並補零（整數部分先轉換為字串，並補足兩位數（如 01, 02, ...））
    const fixedX0 = parseInt(x0).toString().padStart(2, "0");
    // 接者把擷取掉的2023補回來，因為data是帶入原本的資料
    let i = bisect(data, "2023" + fixedX0);
    let selectedData = data[i];

    // 圓點
    focusDot.attr("cx", xScale(selectedData["診斷年週"].substring(4, 6)))
            .attr("cy", yScale(selectedData["確定病例數"]));

    focusText.html("確定病例數：" + selectedData["確定病例數"])
             .attr("x", xScale(selectedData["診斷年週"].substring(4, 6)) + 15)
             .attr("y", yScale(selectedData["確定病例數"]));
  };

  function mouseout() {
    focusDot.style("opacity", 0);
    focusText.style("opacity", 0);
  }
});
<\/script>

<style scoped></style>`}}]},{listTitle:"缺少資料的折線圖",listSubtitle:`<ol type="A" style="margin-top: 16px;">
  <li style="line-height: 1.6;">
    此類折線圖是透過組合「實線折線圖」與「虛線折線圖」而成的。
  </li>
  <li style="line-height: 1.6; margin-top: 16px;">
    <code>line.defined()</code>：<code>d3.line()</code> 旗下的方法，只有 <code>d3.line()</code> 可以使用，會回傳 <code>true</code> 或 <code>false</code> 來決定資料是否存在。
<pre style="padding: 16px;"><code class="javascript">const data = [
  {x: 1, y: 120},
  {x: 2, y: 355},
  {x: 3, y: 0},
  {x: 4, y: 470},
  {x: 5, y: 19},
  {x: 6, y: 90},
  {x: 7, y: 0},
  {x: 8, y: 220},
];

// 用line.defined過濾掉是零的數值，設定只回傳y大於0的數值
// 用來繪製原始資料含有部分缺失數據（可能是0、NaN、undifined）的折線圖
const lineChart = d3.line()
                    .x((d) => xScale(d.x))
                    .y((d) => yScale(d.y))
                    .defined((d) => d.y > 0);</code></pre>
  </li>
  <li style="line-height: 1.6; margin-top: 28px;">
    用實線折線圖與虛線折線圖重疊組合，將兩者折線路徑重疊，繪製出缺少部分的折線圖。
  </li>
</ol>`,listComponent:t(()=>e(()=>import("./D3jsDefinedLineChartGraphExplanation-DwSMY8uQ.js"),__vite__mapDeps([123,1,22,23,24,25,26,27,28,2,3,4,29,11,12,13,14]))),listCode:{htmlCode:null,jsCode:null,vueCode:null},listDetails:[{detailTitle:"缺少資料的折線圖",detailSubtitle:"書本範例改編。資料為無意義測試用數據。",detailComponent:t(()=>e(()=>import("./D3jsDefinedLineChartDemo-DdQDvm38.js"),__vite__mapDeps([124,1,22,23,24,25,26,27,28,2,3,4,29,11,12,13,14,73]))),detailCode:{htmlCode:`<div id="definedLineChartExample" class="mt-1"></div>

<script>
  const definedLineChart = () => {
    const width = 600;
    const height = 400;
    const margin = 50;
    const data = [
      {x: 1, y: 120},
      {x: 2, y: 355},
      {x: 3, y: 0},
      {x: 4, y: 470},
      {x: 5, y: 19},
      {x: 6, y: 90},
      {x: 7, y: 0},
      {x: 8, y: 220},
    ];
    const svg = d3.select("#definedLineChartExample")
                  .append("svg")
                  .attr("width", width)
                  .attr("height", height);
    const xData = data.map((d) => d.x);
    const yData = data.map((d) => d.y);

    const xScale = d3.scaleLinear()
                     .domain([0, d3.max(xData)])
                     .range([margin, width - margin])
                     .nice();
    const xAxisGenerator = d3.axisBottom(xScale)
    const xAxis = svg.append("g")
                     .attr("transform", \`translate(0, \${height - margin})\`)
                     .call(xAxisGenerator);

    const yScale = d3.scaleLinear()
                     .domain([0, d3.max(yData)])
                     .range([height - margin, margin])
                     .nice();
    const yAxisGenerator = d3.axisLeft(yScale)
    const yAxis = svg.append("g")
                     .attr("transform", \`translate(\${margin}, 0)\`)
                     .call(yAxisGenerator);

    // 用用line.defined過濾掉是零的數值，設定只回傳y大於0的數值
    const lineChart = d3.line()
                        .x((d) => xScale(d.x))
                        .y((d) => yScale(d.y))
                        .defined((d) => d.y > 0);

    svg.append("path")
       .data(data)
       .attr("d", lineChart(data))
       .attr("fill", "none")
       .attr("stroke", "#f68b47")
       .attr("stroke-width", 2.5);

    // 保留d.y大於零的資料（不要d.y等於0的資料），用這些資料去建立連線（虛線）
    let filteredData = data.filter(d => d.y > 0);  // 也可以用lineChart.defined()

    // 建立dashed折線
    svg.append("path")
       .data(data)
       .attr("d", lineChart(filteredData))
       .attr("fill", "none")
       .attr("stroke", "#f68b47")
       .attr("stroke-width", "2.5")
       .attr("stroke-dasharray", "4, 4");

    // 加上tooltip
    const tooltip = d3.select("#definedLineChartExample")
                      .style("position", "relative")
                      .append("div")
                      .style("position", "absolute")
                      .style("opacity", "0")
                      .style("background-color", "white")
                      .style("border", "1px solid black")
                      .style("border-radius", "5px")
                      .style("padding", "5px");

    // 加上圓點點
    svg.append("g")
       .selectAll("circle")
       .data(filteredData)
       .join("circle")
       .attr("cx", (d) => xScale(d.x))
       .attr("cy", (d) => yScale(d.y))
       .attr("r", "5")
       .attr("fill", "white")
       .attr("stroke", "#f68b47")
       .attr("stroke-width", "2")
       .style("cursor", "pointer")
       .on("mouseover", dotsMouseover)
       .on("mouseleave", dotsMouseleave);

    function dotsMouseover(e) {
      let pt = d3.pointer(e, e.target);
      tooltip.style("opacity", "1")
             .style("left", pt[0] + 20 + "px")
             .style("top", pt[1] + "px")
             .html(\`x值：\${e.target.__data__.x}<br>\` + 
                   \`y值：\${e.target.__data__.y}\`
             );

      // 加上X-dashed線
      svg.append("line")
         .attr("class", "definedLineChartDashedX")
         .attr("x1", xScale(e.target.__data__.x))
         .attr("y1", height - margin)
         .attr("x2", xScale(e.target.__data__.x))
         .attr("y2", margin)
         .attr("stroke", "#f68b46")
         .attr("stroke-dasharray", "4");

      // 加上Y-dashed線
      svg.append("line")
         .attr("class", "definedLineChartDashedY")
         .attr("x1", margin)
         .attr("y1", yScale(e.target.__data__.y))
         .attr("x2", width - margin)
         .attr("y2", yScale(e.target.__data__.y))
         .style("stroke", "#f68b47")
         .style("stroke-dasharray", "4");
    };

    function dotsMouseleave(d) {
      tooltip.style("opacity", 0)
      svg.selectAll(".definedLineChartDashedX").remove();
      svg.selectAll(".definedLineChartDashedY").remove();
    };
  };
  definedLineChart();
<\/script>`,jsCode:null,vueCode:`<template>
  <div ref="definedLineChartContainerRef"></div>
</template>

<script setup>
import { ref, onMounted } from "vue";
import * as d3 from "d3";

// 圖表尺寸與內邊距設定
const width = 600;
const height = 400;
const margin = 50;

const definedLineChartContainerRef = ref(null);

const data = [
  {x: 1, y: 120},
  {x: 2, y: 355},
  {x: 3, y: 0},
  {x: 4, y: 470},
  {x: 5, y: 19},
  {x: 6, y: 90},
  {x: 7, y: 0},
  {x: 8, y: 220},
];

onMounted(() => {
  const svg = d3.select(definedLineChartContainerRef.value)
                .append("svg")
                .attr("width", width)
                .attr("height", height);
  const xData = data.map((d) => d.x);
  const yData = data.map((d) => d.y);

  const xScale = d3.scaleLinear()
                   .domain([0, d3.max(xData)])
                   .range([margin, width - margin])
                   .nice();
  const xAxisGenerator = d3.axisBottom(xScale)
  const xAxis = svg.append("g")
                   .attr("transform", \`translate(0, \${height - margin})\`)
                   .call(xAxisGenerator);

  const yScale = d3.scaleLinear()
                   .domain([0, d3.max(yData)])
                   .range([height - margin, margin])
                   .nice();
  const yAxisGenerator = d3.axisLeft(yScale)
  const yAxis = svg.append("g")
                   .attr("transform", \`translate(\${margin}, 0)\`)
                   .call(yAxisGenerator);

  // 用用line.defined過濾掉是零的數值，設定只回傳y大於0的數值
  const lineChart = d3.line()
                      .x((d) => xScale(d.x))
                      .y((d) => yScale(d.y))
                      .defined((d) => d.y > 0);
                      
  // 保留d.y大於零的資料（不要d.y等於0的資料），用這些資料去建立連線（虛線）
  let filteredData = data.filter(d => d.y > 0);  // 也可以用lineChart.defined()
                      
  // 先建立虛線（dashed折線）
  svg.append("path")
     .datum(data)
     .attr("d", lineChart(filteredData))  // 因為已經沒有d.y等於0的資料，所以不會有斷點
     .attr("fill", "none")
     .attr("stroke", "#f68b47")
     .attr("stroke-width", "2.5")
     .attr("stroke-dasharray", "4, 4");

  // 再畫實線
  svg.append("path")
     .datum(data)
     .attr("d", lineChart(data))  // 原始資料含有d.y等於0的資料，所以會有斷點
     .attr("fill", "none")
     .attr("stroke", "#f68b47")
     .attr("stroke-width", 2.5);

  // 加上tooltip
  const tooltip = d3.select(definedLineChartContainerRef.value)
                    .style("position", "relative")
                    .append("div")
                    .style("position", "absolute")
                    .style("opacity", "0")
                    .style("background-color", "white")
                    .style("border", "1px solid black")
                    .style("border-radius", "5px")
                    .style("padding", "5px");

  // 加上圓點點
  svg.append("g")
     .selectAll("circle")
     .data(filteredData)
     .join("circle")
     .attr("cx", (d) => xScale(d.x))
     .attr("cy", (d) => yScale(d.y))
     .attr("r", "5")
     .attr("fill", "white")
     .attr("stroke", "#f68b47")
     .attr("stroke-width", "2")
     .style("cursor", "pointer")
     .on("mouseover", dotsMouseover)
     .on("mouseleave", dotsMouseleave);

  function dotsMouseover(e) {
    let pt = d3.pointer(e, e.target);
    tooltip.style("opacity", "1")
           .style("left", pt[0] + 20 + "px")
           .style("top", pt[1] + "px")
           .html(\`x值：\${e.target.__data__.x}<br>\` + 
                 \`y值：\${e.target.__data__.y}\`
           );

    // 加上X-dashed線
    svg.append("line")
       .attr("class", "definedLineChartDashedX")
       .attr("x1", xScale(e.target.__data__.x))
       .attr("y1", height - margin)
       .attr("x2", xScale(e.target.__data__.x))
       .attr("y2", margin)
       .attr("stroke", "#f68b46")
       .attr("stroke-dasharray", "4");

    // 加上Y-dashed線
    svg.append("line")
       .attr("class", "definedLineChartDashedY")
       .attr("x1", margin)
       .attr("y1", yScale(e.target.__data__.y))
       .attr("x2", width - margin)
       .attr("y2", yScale(e.target.__data__.y))
       .style("stroke", "#f68b47")
       .style("stroke-dasharray", "4");
  };

  function dotsMouseleave(d) {
    tooltip.style("opacity", 0)
    svg.selectAll(".definedLineChartDashedX").remove();
    svg.selectAll(".definedLineChartDashedY").remove();
  };
});
<\/script>

<style scoped></style>`}}]},{listTitle:"多線折線圖",listSubtitle:null,listComponent:null,listCode:{htmlCode:null,jsCode:null,vueCode:null},listDetails:[{detailTitle:"基礎多線折線圖",detailSubtitle:"書本範例改編。資料為 2023 年各觀測站降雨量。",detailComponent:t(()=>e(()=>import("./D3jsMultiLineChartDemo-D_muSQXb.js"),__vite__mapDeps([125,1,22,23,24,25,26,27,34,77,31,78,2,3,4,29,11,12,13,14,73]))),detailCode:{htmlCode:`<div id="multiLineChartExample"></div>

<script>
  const multiLineChart = async () => {
    // svg
    const width = 600;
    const height = 400;
    const margin = 50;
    const svg = d3.select("#multiLineChartExample")
                  .append("svg")
                  .attr("width", width)
                  .attr("height", height);

    // 取資料集
    const res = await d3.json("https://data.moa.gov.tw/Service/OpenData/TransService.aspx?UnitId=5n9c3AlEJ2DH&IsTransData=1");
    const data = res.filter(d => d.observeDate.substring(0, 4) === "2023");  // 只取2023年的資料
    const xData = data.map((i) => i.observeDate.substring(4, 6));
    const yData = data.map((i) => {
      let rainfall = parseFloat(i.rainfall);
      return rainfall = rainfall || 0;  // 如果rainfall的值是NaN、null、undefined、0或""（空字串），那麼rainfall會被設定為0，否則保持原來的值
    });

    // X軸
    const xScale = d3.scaleLinear()
                     .domain(d3.extent(xData))
                     .range([margin, width - margin])
                     .nice();
    const xAxisGenerator = d3.axisBottom(xScale)
                             .ticks(8)
                             .tickFormat(d => d + "月");
    const xAxis = svg.append("g")
                     .attr("transform", \`translate(0, \${height - margin})\`)
                     .call(xAxisGenerator);

    // Y軸
    const yScale = d3.scaleLinear()
                     .domain(d3.extent(yData))
                     .range([height - margin, margin])
                     .nice();
    const yAxisGenerator = d3.axisLeft(yScale).tickFormat(d => d + "mm");
    const yAxis = svg.append("g")
                     .attr("transform", \`translate(\${margin}, 0)\`)
                     .call(yAxisGenerator);

    // 把資料按照name分組
    const sumName = d3.group(data, d => d.observatory);
    const color = d3.scaleOrdinal()
                    .domain(data.map(d => d.item))  // 此資料沒有item項，因此此同'.domain()'，即domain是空的
                    .range(d3.schemeCategory10);

    // 建立tooltip
    const nameTag = d3.select("#multiLineChartExample")
                      .style("position", "relative")
                      .append("div")
                      .attr("class", "multiLineChartNameTag")
                      .style("position", "absolute")
                      .style("background-color", "#121212")
                      .style("color", "#f2f2f2")
                      .style("border-radius", "5px")
                      .style("padding", "10px")
                      .style("display", "none");

    // 開始建立折線圖
    svg.append("g")
       .selectAll("path")
       .data(sumName)
       .join("path")
       .attr("d", d => {
         return d3.line()
                  .x((d) => xScale(d.observeDate.substr(4, 6)))
                  .y((d) => {
                    let rainfall = parseFloat(d.rainfall);
                    rainfall = rainfall || 0;
                    return yScale(rainfall);
                  })(d[1])  // 因為是從sumName裡面取資料，除了觀測站（observatory）以外的資料都在d[1]裡
       })
       .attr("fill", "none")
       .attr("stroke", d => color(d))
       .attr("stroke-width", 1.5)
       .style("cursor", "pointer")
       .on("mouseover", handleMouseover)
       .on("mouseleave", handleMouseleave);

    function handleMouseover(e) {
      let pt = d3.pointer(e, e.target);
      d3.select(this).style("stroke-width", "5");

      nameTag.style("display", "block")
             .html(e.target.__data__[0])  // 因為已用"d3.group()"分組，所以此處"e.target.__data__[0]"代表觀測站名稱
             .style("left", pt[0] + 10 + "px")
             .style("top", pt[1] + "px");
    };

    function handleMouseleave() {
      d3.select(this).style("stroke-width", "1.5");
      nameTag.style("display", "none");
    };
  };
  multiLineChart();
<\/script>`,jsCode:null,vueCode:`<template>
  <div ref="multiLineChartContainerRef"></div>
</template>

<script setup>
import { ref, onMounted } from "vue";
import * as d3 from "d3";

const multiLineChartContainerRef = ref(null);

// 圖表尺寸與內邊距設定
const width = 600;
const height = 400;
const margin = 50;

onMounted(async () => {
  const svg = d3.select(multiLineChartContainerRef.value)
                .append("svg")
                .attr("width", width)
                .attr("height", height);

  // 取資料集
  const res = await d3.json("https://data.moa.gov.tw/Service/OpenData/TransService.aspx?UnitId=5n9c3AlEJ2DH&IsTransData=1");
  const data = res.filter(d => d.observeDate.substring(0, 4) === "2023");  // 只取2023年的資料
  const xData = data.map((i) => i.observeDate.substring(4, 6));
  const yData = data.map((i) => {
    let rainfall = parseFloat(i.rainfall);
    return rainfall = rainfall || 0;  // 如果rainfall的值是NaN、null、undefined、0或""（空字串），那麼rainfall會被設定為0，否則保持原來的值
  });

  // X軸
  const xScale = d3.scaleLinear()
                   .domain(d3.extent(xData))
                   .range([margin, width - margin])
                   .nice();
  const xAxisGenerator = d3.axisBottom(xScale)
                           .ticks(8)
                           .tickFormat(d => d + "月");
  const xAxis = svg.append("g")
                   .attr("transform", \`translate(0, \${height - margin})\`)
                   .call(xAxisGenerator);

  // Y軸
  const yScale = d3.scaleLinear()
                   .domain(d3.extent(yData))
                   .range([height - margin, margin])
                   .nice();
  const yAxisGenerator = d3.axisLeft(yScale).tickFormat(d => d + "mm");
  const yAxis = svg.append("g")
                   .attr("transform", \`translate(\${margin}, 0)\`)
                   .call(yAxisGenerator);

  // 把資料按照name分組
  const sumName = d3.group(data, d => d.observatory);
  const color = d3.scaleOrdinal()
                  .domain(data.map(d => d.item))  // 此資料沒有item項，因此此同'.domain()'，即domain是空的
                  .range(d3.schemeCategory10);

  // 建立tooltip
  const nameTag = d3.select(multiLineChartContainerRef.value)
                    .style("position", "relative")
                    .append("div")
                    .attr("class", "multiLineChartNameTag")
                    .style("position", "absolute")
                    .style("background-color", "#121212")
                    .style("color", "#f2f2f2")
                    .style("border-radius", "5px")
                    .style("padding", "10px")
                    .style("display", "none");

  // 開始建立折線圖
  svg.append("g")
     .selectAll("path")
     .data(sumName)
     .join("path")
     .attr("d", d => {
       return d3.line()
                .x((d) => xScale(d.observeDate.substr(4, 6)))
                .y((d) => {
                  let rainfall = parseFloat(d.rainfall);
                  rainfall = rainfall || 0;
                  return yScale(rainfall);
                })(d[1])  // 因為是從sumName裡面取資料，除了觀測站（observatory）以外的資料都在d[1]裡
     })
     .attr("fill", "none")
     .attr("stroke", d => color(d))
     .attr("stroke-width", 1.5)
     .style("cursor", "pointer")
     .on("mouseover", handleMouseover)
     .on("mouseleave", handleMouseleave);

  function handleMouseover(e) {
    let pt = d3.pointer(e, e.target);
    d3.select(this).style("stroke-width", "5");

    nameTag.style("display", "block")
           .html(e.target.__data__[0])  // 因為已用"d3.group()"分組，所以此處"e.target.__data__[0]"代表觀測站名稱
           .style("left", pt[0] + 10 + "px")
           .style("top", pt[1] + "px");
  };

  function handleMouseleave() {
    d3.select(this).style("stroke-width", "1.5");
    nameTag.style("display", "none");
  };
});
<\/script>

<style scoped></style>`}},{detailTitle:"多線折線圖搭配選取刷",detailSubtitle:"書本範例改編。資料為 2010 年 1 月以來各觀測站之降雨量。",detailComponent:t(()=>e(()=>import("./D3jsMultiLineChartWithBrushDemo-D3GNxcim.js"),__vite__mapDeps([126,72,1,24,4,73,74,41,23,25,26,34,22,27,77,31,78,2,3,29,11,12,13,14]))),detailCode:{htmlCode:`<div id="multiLineChartExampleWithBrush"></div>

<script>
  const multiLineChartWithBrush = async () => {
    // svg
    const width = 600;
    const height = 400;
    const margin = 50;
    const svg = d3.select("#multiLineChartExampleWithBrush")
                  .append("svg")
                  .attr("width", width)
                  .attr("height", height);

    // 取資料集
    const data = await d3.json("https://data.moa.gov.tw/Service/OpenData/TransService.aspx?UnitId=5n9c3AlEJ2DH&IsTransData=1");
    const xData = data.map((d) => d3.timeParse("%Y%m")(d.observeDate));
    const yData = data.map((d) => {
      let rainfall = parseFloat(d.rainfall);
      return rainfall = rainfall || 0;  // 如果rainfall的值是NaN、null、undefined、0或""（空字串），那麼rainfall會被設定為0，否則保持原來的值
    });

    // X軸
    const xScale = d3.scaleTime()
                     .domain(d3.extent(xData))
                     .range([margin, width - margin])
                     .nice();
    const xAxisGenerator = d3.axisBottom(xScale).tickFormat(d => d3.timeFormat("%Y/%m")(d)).ticks(6);
    const xAxis = svg.append("g")
                     .attr("transform", \`translate(0, \${height - margin})\`)
                     .call(xAxisGenerator);

    // Y軸
    const yScale = d3.scaleLinear()
                     .domain(d3.extent(yData))
                     .range([height - margin, margin])
                     .nice();
    const yAxisGenerator = d3.axisLeft(yScale).tickFormat(d => d + "mm");
    const yAxis = svg.append("g")
                     .attr("transform", \`translate(\${margin}, 0)\`)
                     .call(yAxisGenerator);

    // 把資料按照name分組
    const sumName = d3.group(data, d => d.observatory);
    const color = d3.scaleOrdinal()
                    .domain(data.map(d => d.item))  // 此資料沒有item項，因此此同'.domain()'，即domain是空的
                    .range(d3.schemeCategory10);

    // 建立一個畫布範圍，超過此畫布的畫面都不會被渲染，這樣才能控制縮放的大小
    const clip = svg.append("defs")
                    .append("clipPath")
                    .attr("id", "multiLineChartWithBrushClip")
                    .append("rect")
                    .attr("x", margin)
                    .attr("y", margin)
                    .attr("width", width - margin * 2)
                    .attr("height", height - margin * 2);

    // 設定brush
    const brush = d3.brushX()
                    .extent([[margin, margin], [width - margin, height - margin]])
                    .on("end", updateChart);

    // 開始建立折線圖
    const line = svg.append("g");

    // 畫上折線
    line.selectAll("path")
        .data(sumName)
        .join("path")
        .attr("class", "multiLineChartWithBrushLine")
        .attr("d", d => {
          return d3.line()
                   .x((d) => xScale(d3.timeParse("%Y%m")(d.observeDate)))
                   .y((d) => {
                    let rainfall = parseFloat(d.rainfall);
                    rainfall = rainfall || 0;
                    return yScale(rainfall);
                   })(d[1])  // 因為是從sumName裡面取資料，除了觀測站（observatory）以外的資料都在d[1]裡
        })
        .attr("fill", "none")
        .attr("stroke", d => color(d))
        .attr("stroke-width", 1.5)
        .style("cursor", "pointer");

    // 加上brush
    line.attr("clip-path", "url(#multiLineChartWithBrushClip)")
        .append("g")
        .attr("class", "multiLineChartWithBrushBrush")
        .call(brush);

    // 設定brush後的動作
    function updateChart(e, d) {
      // xBrush的範圍，會回傳一個[x0, x1]的陣列
      const brushExtent = e.selection;
      if (brushExtent) {
        // xScale.invert是把回傳的x0和x1變成xScale接受的數值
        xScale.domain([xScale.invert(brushExtent[0]), xScale.invert(brushExtent[1])]);
        // 移除brush的灰色區域
        // 'brush.move'是用來改變或移動brush的選取範圍，將第二個參數設定為'null'，可以清除目前的選取區域
        line.select(".multiLineChartWithBrushBrush").call(brush.move, null);
      };

      // 按照更新的domain範圍值重新選染圖表
      xAxis.transition().duration(1000).call(xAxisGenerator);
      line.selectAll(".multiLineChartWithBrushLine")
          .transition()
          .duration(1000)
          .attr("d", d => {
            return d3.line()
                     .x((d) => xScale(d3.timeParse("%Y%m")(d.observeDate)))
                     .y((d) => {
                       let rainfall = parseFloat(d.rainfall);
                       rainfall = rainfall || 0;
                       return yScale(rainfall);
                     })(d[1]);
          });
    };

    // 雙極svg縮回原本大小
    svg.on("dblclick", reset);

    function reset() {
      // 回到原本的大小
      xScale.domain(d3.extent(xData));

      // 重新呼叫渲染軸線和折線
      xAxis.transition().duration(1000).call(xAxisGenerator);
      line.selectAll(".multiLineChartWithBrushLine")
          .transition()
          .duration(1000)
          .attr("d", d => {
            return d3.line()
                     .x((d) => xScale(d3.timeParse("%Y%m")(d.observeDate)))
                     .y((d) => {
                       let rainfall = parseFloat(d.rainfall);
                       rainfall = rainfall || 0;
                       return yScale(rainfall);
                     })(d[1])
          });
    };
  };
  multiLineChartWithBrush();
<\/script>`,jsCode:null,vueCode:`<template>
  <div ref="multiLineChartWithBrushRef"></div>
</template>

<script setup>
import { ref, onMounted } from "vue";
import * as d3 from "d3";

const multiLineChartWithBrushRef = ref(null);

// 圖表尺寸與內邊距設定
const width = 600;
const height = 400;
const margin = 50;

onMounted(async () => {
  const svg = d3.select(multiLineChartWithBrushRef.value)
                .append("svg")
                .attr("width", width)
                .attr("height", height);

  // 取資料集
  const data = await d3.json("https://data.moa.gov.tw/Service/OpenData/TransService.aspx?UnitId=5n9c3AlEJ2DH&IsTransData=1");
  const xData = data.map((d) => d3.timeParse("%Y%m")(d.observeDate));
  const yData = data.map((d) => {
    let rainfall = parseFloat(d.rainfall);
    return rainfall = rainfall || 0;  // 如果rainfall的值是NaN、null、undefined、0或""（空字串），那麼rainfall會被設定為0，否則保持原來的值
  });

  // X軸
  const xScale = d3.scaleTime()
                   .domain(d3.extent(xData))
                   .range([margin, width - margin])
                   .nice();
  const xAxisGenerator = d3.axisBottom(xScale).tickFormat(d => d3.timeFormat("%Y/%m")(d)).ticks(6);
  const xAxis = svg.append("g")
                   .attr("transform", \`translate(0, \${height - margin})\`)
                   .call(xAxisGenerator);

  // Y軸
  const yScale = d3.scaleLinear()
                   .domain(d3.extent(yData))
                   .range([height - margin, margin])
                   .nice();
  const yAxisGenerator = d3.axisLeft(yScale).tickFormat(d => d + "mm");
  const yAxis = svg.append("g")
                   .attr("transform", \`translate(\${margin}, 0)\`)
                   .call(yAxisGenerator);

  // 把資料按照name分組
  const sumName = d3.group(data, d => d.observatory);
  const color = d3.scaleOrdinal()
                  .domain(data.map(d => d.item))  // 此資料沒有item項，因此此同'.domain()'，即domain是空的
                  .range(d3.schemeCategory10);

  // 用有隨機字串的id，避免變數全域污染
  const clipId = \`multiLineChartWithBrushClip-\${Math.random().toString(36).slice(2)}\`;
  // 建立一個畫布範圍，超過此畫布的畫面都不會被渲染，這樣才能控制縮放的大小
  const clip = svg.append("defs")
                  .append("clipPath")
                  .attr("id", clipId)
                  .append("rect")
                  .attr("x", margin)
                  .attr("y", margin)
                  .attr("width", width - margin * 2)
                  .attr("height", height - margin * 2);

  // 設定brush
  const brush = d3.brushX()
                  .extent([[margin, margin], [width - margin, height - margin]])
                  .on("end", updateChart);

  // 開始建立折線圖
  const line = svg.append("g");

  // 畫上折線
  line.selectAll("path")
      .data(sumName)
      .join("path")
      .attr("class", "multiLineChartWithBrushLine")
      .attr("d", d => {
        return d3.line()
                 .x((d) => xScale(d3.timeParse("%Y%m")(d.observeDate)))
                 .y((d) => {
                  let rainfall = parseFloat(d.rainfall);
                  rainfall = rainfall || 0;
                  return yScale(rainfall);
                 })(d[1])  // 因為是從sumName裡面取資料，除了觀測站（observatory）以外的資料都在d[1]裡
      })
      .attr("fill", "none")
      .attr("stroke", d => color(d))
      .attr("stroke-width", 1.5)
      .style("cursor", "pointer");

  // 加上brush
  line.attr("clip-path", \`url(#\${clipId})\`)
      .append("g")
      .attr("class", "multiLineChartWithBrushBrush")
      .call(brush);

  // 設定brush後的動作
  function updateChart(e, d) {
    // xBrush的範圍，會回傳一個[x0, x1]的陣列
    const brushExtent = e.selection;
    if (brushExtent) {
      // xScale.invert是把回傳的x0和x1變成xScale接受的數值
      xScale.domain([xScale.invert(brushExtent[0]), xScale.invert(brushExtent[1])]);
      // 移除brush的灰色區域
      // 'brush.move'是用來改變或移動brush的選取範圍，將第二個參數設定為'null'，可以清除目前的選取區域
      line.select(".multiLineChartWithBrushBrush").call(brush.move, null);
    };

    // 按照更新的domain範圍值重新選染圖表
    xAxis.transition().duration(1000).call(xAxisGenerator);
    line.selectAll(".multiLineChartWithBrushLine")
        .transition()
        .duration(1000)
        .attr("d", d => {
          return d3.line()
                   .x((d) => xScale(d3.timeParse("%Y%m")(d.observeDate)))
                   .y((d) => {
                     let rainfall = parseFloat(d.rainfall);
                     rainfall = rainfall || 0;
                     return yScale(rainfall);
                   })(d[1]);
        });
  };

  // 雙極svg縮回原本大小
  svg.on("dblclick", reset);

  function reset() {
    // 回到原本的大小
    xScale.domain(d3.extent(xData));

    // 重新呼叫渲染軸線和折線
    xAxis.transition().duration(1000).call(xAxisGenerator);
    line.selectAll(".multiLineChartWithBrushLine")
        .transition()
        .duration(1000)
        .attr("d", d => {
          return d3.line()
                   .x((d) => xScale(d3.timeParse("%Y%m")(d.observeDate)))
                   .y((d) => {
                     let rainfall = parseFloat(d.rainfall);
                     rainfall = rainfall || 0;
                     return yScale(rainfall);
                   })(d[1])
        });
  };
});
<\/script>

<style scoped></style>`}}]}]}],B={class:"d3js-note-view"},P={class:"layout"},$={class:"sidebar"},z=["onClick"],O={class:"content-title"},I=["innerHTML"],V={key:2,class:"content-body"},F=["innerHTML"],Y=["innerHTML"],X={key:1,class:"lists-demo"},W={key:2,class:"code"},H={key:0},N={class:"html"},K={key:1},J={class:"javascript"},U={class:"html"},q={key:3},Q=["innerHTML"],Z=["innerHTML"],tt={key:1,class:"details-demo"},et={key:2,class:"code"},at={key:0},it={class:"html"},ot={key:1},rt={class:"javascript"},nt={class:"html"},st={__name:"D3jsNoteView",setup(lt){const u=E,g=k(u[0].id),l=T(()=>u.find(m=>m.id===g.value)||u[0]);h.registerLanguage("html",j),h.registerLanguage("javascript",M),w(()=>{v(()=>h.highlightAll())});function S(){v(()=>{document.querySelectorAll("pre code").forEach(m=>{delete m.dataset.highlighted}),h.highlightAll()})}return(m,c)=>(a(),i("div",B,[s("div",P,[s("nav",$,[s("ul",null,[(a(!0),i(p,null,x(_(u),o=>(a(),i("li",{key:o.id,class:G({active:o.id===g.value}),onClick:n=>g.value=o.id},d(o.title),11,z))),128))])]),A(R,{name:"fade",mode:"out-in",onAfterEnter:S},{default:D(()=>[l.value?(a(),i("section",{class:"content",key:l.value.id},[s("h3",O,d(l.value.title),1),c[2]||(c[2]=s("hr",null,null,-1)),l.value.description?(a(),i("div",{key:0,class:"description",innerHTML:l.value.description},null,8,I)):r("",!0),l.value.descriptionComponent?(a(),i("div",{key:1,style:L(l.value.descriptionComponentStyle),class:"description-component"},[(a(),y(f(l.value.descriptionComponent)))],4)):r("",!0),l.value.lists.length&&l.value.lists[0].listTitle?(a(),i("ul",V,[(a(!0),i(p,null,x(l.value.lists,o=>(a(),i("li",{key:o.listTitle,class:"list"},[s("h4",{class:"list-title",innerHTML:o.listTitle},null,8,F),o.listSubtitle?(a(),i("div",{key:0,class:"list-subtitle",innerHTML:o.listSubtitle},null,8,Y)):r("",!0),o.listComponent?(a(),i("div",X,[(a(),y(f(o.listComponent)))])):r("",!0),o.listCode.htmlCode||o.listCode.jsCode||o.listCode.vueCode?(a(),i("div",W,[o.listCode.htmlCode?(a(),i("pre",H,[s("code",N,d(o.listCode.htmlCode),1)])):r("",!0),o.listCode.jsCode?(a(),i("pre",K,[s("code",J,d(o.listCode.jsCode),1)])):r("",!0),o.listCode.vueCode?(a(),i(p,{key:2},[c[0]||(c[0]=b(" Vue SFC 這樣寫（Vue 3 - Composition API）： ")),s("pre",null,[s("code",U,d(o.listCode.vueCode),1)])],64)):r("",!0)])):r("",!0),o.listDetails.length&&o.listDetails[0].detailTitle?(a(),i("ol",q,[(a(!0),i(p,null,x(o.listDetails,n=>(a(),i("li",{key:n.detailTitle,class:"detail"},[s("h5",{class:"detail-title",innerHTML:n.detailTitle},null,8,Q),n.detailSubtitle?(a(),i("div",{key:0,class:"detail-subtitle",innerHTML:n.detailSubtitle},null,8,Z)):r("",!0),n.detailComponent?(a(),i("div",tt,[(a(),y(f(n.detailComponent)))])):r("",!0),n.detailCode.htmlCode||n.detailCode.jsCode||n.detailCode.vueCode?(a(),i("div",et,[n.detailCode.htmlCode?(a(),i("pre",at,[s("code",it,d(n.detailCode.htmlCode),1)])):r("",!0),n.detailCode.jsCode?(a(),i("pre",ot,[s("code",rt,d(n.detailCode.jsCode),1)])):r("",!0),n.detailCode.vueCode?(a(),i(p,{key:2},[c[1]||(c[1]=b(" Vue SFC 這樣寫（Vue 3 - Composition API）： ")),s("pre",null,[s("code",nt,d(n.detailCode.vueCode),1)])],64)):r("",!0)])):r("",!0)]))),128))])):r("",!0)]))),128))])):r("",!0)])):r("",!0)]),_:1})])]))}},ut=C(st,[["__scopeId","data-v-9fa065ef"]]);export{ut as default};
